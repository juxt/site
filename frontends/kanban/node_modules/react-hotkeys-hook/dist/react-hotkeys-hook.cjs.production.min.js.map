{"version":3,"file":"react-hotkeys-hook.cjs.production.min.js","sources":["../src/useHotkeys.ts","../src/index.ts","../src/useIsHotkeyPressed.ts"],"sourcesContent":["import hotkeys, { HotkeysEvent, KeyHandler } from 'hotkeys-js';\nimport React, { useCallback, useEffect, useRef } from 'react';\n\ntype AvailableTags = 'INPUT' | 'TEXTAREA' | 'SELECT';\n\n// We implement our own custom filter system.\nhotkeys.filter = () => true;\n\nconst tagFilter = ({ target }: KeyboardEvent, enableOnTags?: AvailableTags[]) => {\n  const targetTagName = target && (target as HTMLElement).tagName;\n\n  return Boolean((targetTagName && enableOnTags && enableOnTags.includes(targetTagName as AvailableTags)));\n};\n\nconst isKeyboardEventTriggeredByInput = (ev: KeyboardEvent) => {\n  return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);\n};\n\nexport type Options = {\n  enabled?: boolean; // Main setting that determines if the hotkey is enabled or not. (Default: true)\n  filter?: typeof hotkeys.filter; // A filter function returning whether the callback should get triggered or not. (Default: undefined)\n  filterPreventDefault?: boolean; // Prevent default browser behavior if the filter function returns false. (Default: true)\n  enableOnTags?: AvailableTags[]; // Enable hotkeys on a list of tags. (Default: [])\n  enableOnContentEditable?: boolean; // Enable hotkeys on tags with contentEditable props. (Default: false)\n  splitKey?: string; // Character to split keys in hotkeys combinations. (Default +)\n  scope?: string; // Scope. Currently not doing anything.\n  keyup?: boolean; // Trigger on keyup event? (Default: undefined)\n  keydown?: boolean; // Trigger on keydown event? (Default: true)\n};\n\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: any[] | Options, deps?: any[]): React.MutableRefObject<T | null> {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n\n  const {\n    enableOnTags,\n    filter,\n    keyup,\n    keydown,\n    filterPreventDefault = true,\n    enabled = true,\n    enableOnContentEditable = false,\n  } = options as Options || {};\n  const ref = useRef<T | null>(null);\n\n  // The return value of this callback determines if the browsers default behavior is prevented.\n  const memoisedCallback = useCallback((keyboardEvent: KeyboardEvent, hotkeysEvent: HotkeysEvent) => {\n    if (filter && !filter(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n\n    // Check whether the hotkeys was triggered inside an input and that input is enabled or if it was triggered by a content editable tag and it is enabled.\n    if (\n      (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags))\n      || ((keyboardEvent.target as HTMLElement)?.isContentEditable && !enableOnContentEditable)\n    ) {\n      return true;\n    }\n\n    if (ref.current === null || document.activeElement === ref.current || ref.current?.contains(document.activeElement)) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, enableOnTags, filter, ...deps] : [ref, enableOnTags, filter]);\n\n  useEffect(() => {\n    if (!enabled) {\n      hotkeys.unbind(keys, memoisedCallback);\n\n      return;\n    }\n\n    // In this case keydown is likely undefined, so we set it to false, since hotkeys needs the `keydown` key to have a value.\n    if (keyup && keydown !== true) {\n      (options as Options).keydown = false;\n    }\n\n    hotkeys(keys, (options as Options) || {}, memoisedCallback);\n\n    return () => hotkeys.unbind(keys, memoisedCallback);\n  }, [memoisedCallback, keys, enabled]);\n\n  return ref;\n}\n","import { useIsHotkeyPressed } from './useIsHotkeyPressed';\nimport { useHotkeys, Options } from './useHotkeys';\nimport hotkeys from 'hotkeys-js';\n\nconst isHotkeyPressed = hotkeys.isPressed;\n\nexport { useHotkeys, useIsHotkeyPressed, isHotkeyPressed, Options };","import hotkeys from 'hotkeys-js';\n\n/**\n * @deprecated Use isHotkeyPressed instead. Will be removed version 4.\n */\nexport function useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}"],"names":["hotkeys","filter","tagFilter","enableOnTags","target","targetTagName","tagName","Boolean","includes","isPressed","keys","callback","options","deps","Array","undefined","keyup","keydown","filterPreventDefault","enabled","enableOnContentEditable","ref","useRef","memoisedCallback","useCallback","keyboardEvent","hotkeysEvent","isContentEditable","current","document","activeElement","_ref$current","contains","useEffect","unbind"],"mappings":"iHAMAA,EAAQC,OAAS,kBAAM,GAEvB,IAAMC,EAAY,WAA4BC,OAAzBC,IAAAA,OACbC,EAAgBD,GAAWA,EAAuBE,eAEjDC,QAASF,GAAiBF,GAAgBA,EAAaK,SAASH,6BCPjDL,EAAQS,6BD6BhC,SAA8CC,EAAcC,EAAsBC,EAA2BC,GACvGD,aAAmBE,QACrBD,EAAOD,EACPA,OAAUG,SAWRH,GAAsB,GAPxBT,IAAAA,aACAF,IAAAA,OACAe,IAAAA,MACAC,IAAAA,YACAC,qBAAAA,oBACAC,QAAAA,oBACAC,wBAAAA,gBAEIC,EAAMC,SAAiB,MAGvBC,EAAmBC,eAAY,SAACC,EAA8BC,kBAC9DzB,IAAWA,EAAOwB,IACZP,KAtCLhB,EA2C8BuB,EA3ChB,CAAC,QAAS,WAAY,aA2CavB,EAAUuB,EAAetB,aACxEsB,EAAcrB,WAAwBuB,oBAAsBP,OAK/C,OAAhBC,EAAIO,SAAoBC,SAASC,gBAAkBT,EAAIO,kBAAWP,EAAIO,UAAJG,EAAaC,SAASH,SAASC,kBACnGnB,EAASc,EAAeC,IACjB,KAIRb,GAAQQ,EAAKlB,EAAcF,UAAWY,GAAQ,CAACQ,EAAKlB,EAAcF,WAErEgC,aAAU,cACHd,SAODH,IAAqB,IAAZC,IACVL,EAAoBK,SAAU,GAGjCjB,EAAQU,EAAOE,GAAuB,GAAIW,GAEnC,kBAAMvB,EAAQkC,OAAOxB,EAAMa,IAZhCvB,EAAQkC,OAAOxB,EAAMa,KAatB,CAACA,EAAkBb,EAAMS,IAErBE,gDEnFArB,EAAQS"}