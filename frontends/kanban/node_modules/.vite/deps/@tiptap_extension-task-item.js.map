{
  "version": 3,
  "sources": ["../../@tiptap/extension-task-item/src/task-item.ts", "dep:@tiptap_extension-task-item"],
  "sourcesContent": ["import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\nimport { Node as ProseMirrorNode } from 'prosemirror-model'\n\nexport interface TaskItemOptions {\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n  nested: boolean\n  HTMLAttributes: Record<string, any>\n}\n\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => element.getAttribute('data-checked') === 'true',\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({\n      node, HTMLAttributes, getPos, editor,\n    }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('change', event => {\n        // if the editor isn\u2019t editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      if (node.attrs.checked) {\n        checkbox.setAttribute('checked', 'checked')\n      }\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          if (updatedNode.attrs.checked) {\n            checkbox.setAttribute('checked', 'checked')\n          } else {\n            checkbox.removeAttribute('checked')\n          }\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n", "import d from \"./node_modules/@tiptap/extension-task-item/dist/tiptap-extension-task-item.esm.js\";export default d;\nexport * from \"./node_modules/@tiptap/extension-task-item/dist/tiptap-extension-task-item.esm.js\""],
  "mappings": "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",
  "names": []
}
