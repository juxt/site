"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.YupSchemaVisitor = void 0;
const graphql_1 = require("./../graphql");
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
const typescript_1 = require("@graphql-codegen/typescript");
const directive_1 = require("../directive");
const importYup = `import * as yup from 'yup'`;
const YupSchemaVisitor = (schema, config) => {
    const tsVisitor = new typescript_1.TsVisitor(schema, config);
    const importTypes = [];
    return {
        buildImports: () => {
            if (config.importFrom && importTypes.length > 0) {
                return [importYup, `import { ${importTypes.join(', ')} } from '${config.importFrom}'`];
            }
            return [importYup];
        },
        initialEmit: () => '',
        InputObjectTypeDefinition: (node) => {
            var _a;
            const name = tsVisitor.convertName(node.name.value);
            importTypes.push(name);
            const shape = (_a = node.fields) === null || _a === void 0 ? void 0 : _a.map(field => generateInputObjectFieldYupSchema(config, tsVisitor, schema, field, 2)).join(',\n');
            return new visitor_plugin_common_1.DeclarationBlock({})
                .export()
                .asKind('function')
                .withName(`${name}Schema(): yup.SchemaOf<${name}>`)
                .withBlock([(0, visitor_plugin_common_1.indent)(`return yup.object({`), shape, (0, visitor_plugin_common_1.indent)('})')].join('\n')).string;
        },
        EnumTypeDefinition: (node) => {
            var _a, _b;
            const enumname = tsVisitor.convertName(node.name.value);
            importTypes.push(enumname);
            if (config.enumsAsTypes) {
                return new visitor_plugin_common_1.DeclarationBlock({})
                    .export()
                    .asKind('const')
                    .withName(`${enumname}Schema`)
                    .withContent(`yup.mixed().oneOf([${(_a = node.values) === null || _a === void 0 ? void 0 : _a.map(enumOption => `'${enumOption.name.value}'`).join(', ')}])`).string;
            }
            const values = (_b = node.values) === null || _b === void 0 ? void 0 : _b.map(enumOption => `${enumname}.${tsVisitor.convertName(enumOption.name, {
                useTypesPrefix: false,
                transformUnderscore: true,
            })}`).join(', ');
            return new visitor_plugin_common_1.DeclarationBlock({})
                .export()
                .asKind('const')
                .withName(`${enumname}Schema`)
                .withContent(`yup.mixed().oneOf([${values}])`).string;
        },
        // ScalarTypeDefinition: (node) => {
        //   const decl = new DeclarationBlock({})
        //     .export()
        //     .asKind("const")
        //     .withName(`${node.name.value}Schema`);
        //   if (tsVisitor.scalars[node.name.value]) {
        //     const tsType = tsVisitor.scalars[node.name.value];
        //     switch (tsType) {
        //       case "string":
        //         return decl.withContent(`yup.string()`).string;
        //       case "number":
        //         return decl.withContent(`yup.number()`).string;
        //       case "boolean":
        //         return decl.withContent(`yup.boolean()`).string;
        //     }
        //   }
        //   return decl.withContent(`yup.mixed()`).string;
        // },
    };
};
exports.YupSchemaVisitor = YupSchemaVisitor;
const generateInputObjectFieldYupSchema = (config, tsVisitor, schema, field, indentCount) => {
    let gen = generateInputObjectFieldTypeYupSchema(config, tsVisitor, schema, field.type);
    if (config.directives && field.directives) {
        const formatted = (0, directive_1.formatDirectiveConfig)(config.directives);
        gen += (0, directive_1.buildApi)(formatted, field.directives);
    }
    return (0, visitor_plugin_common_1.indent)(`${field.name.value}: ${maybeLazy(field.type, gen)}`, indentCount);
};
const generateInputObjectFieldTypeYupSchema = (config, tsVisitor, schema, type, parentType) => {
    if ((0, graphql_1.isListType)(type)) {
        const gen = generateInputObjectFieldTypeYupSchema(config, tsVisitor, schema, type.type, type);
        if (!(0, graphql_1.isNonNullType)(parentType)) {
            return `yup.array().of(${maybeLazy(type.type, gen)}).optional()`;
        }
        return `yup.array().of(${maybeLazy(type.type, gen)})`;
    }
    if ((0, graphql_1.isNonNullType)(type)) {
        const gen = generateInputObjectFieldTypeYupSchema(config, tsVisitor, schema, type.type, type);
        const nonNullGen = maybeNonEmptyString(config, tsVisitor, gen, type.type);
        return maybeLazy(type.type, nonNullGen);
    }
    if ((0, graphql_1.isNamedType)(type)) {
        return generateNameNodeYupSchema(config, tsVisitor, schema, type.name);
    }
    console.warn('unhandled type:', type);
    return '';
};
const generateNameNodeYupSchema = (config, tsVisitor, schema, node) => {
    var _a, _b;
    const typ = schema.getType(node.value);
    if (typ && ((_a = typ.astNode) === null || _a === void 0 ? void 0 : _a.kind) === 'InputObjectTypeDefinition') {
        const enumName = tsVisitor.convertName(typ.astNode.name.value);
        return `${enumName}Schema()`;
    }
    if (typ && ((_b = typ.astNode) === null || _b === void 0 ? void 0 : _b.kind) === 'EnumTypeDefinition') {
        const enumName = tsVisitor.convertName(typ.astNode.name.value);
        return `${enumName}Schema`;
    }
    const primitive = yup4Scalar(config, tsVisitor, node.value);
    return primitive;
};
const maybeLazy = (type, schema) => {
    if ((0, graphql_1.isNamedType)(type) && (0, graphql_1.isInput)(type.name.value)) {
        // https://github.com/jquense/yup/issues/1283#issuecomment-786559444
        return `yup.lazy(() => ${schema}) as never`;
    }
    return schema;
};
const maybeNonEmptyString = (config, tsVisitor, schema, childType) => {
    if (config.notAllowEmptyString === true && (0, graphql_1.isNamedType)(childType)) {
        const maybeScalarName = childType.name.value;
        const tsType = tsVisitor.scalars[maybeScalarName];
        if (tsType === 'string') {
            return `${schema}.required()`;
        }
    }
    // fallback
    return `${schema}.defined()`;
};
const yup4Scalar = (config, tsVisitor, scalarName) => {
    var _a;
    if ((_a = config.scalarSchemas) === null || _a === void 0 ? void 0 : _a[scalarName]) {
        return config.scalarSchemas[scalarName];
    }
    const tsType = tsVisitor.scalars[scalarName];
    switch (tsType) {
        case 'string':
            return `yup.string()`;
        case 'number':
            return `yup.number()`;
        case 'boolean':
            return `yup.boolean()`;
    }
    console.warn('unhandled name:', scalarName);
    return `yup.mixed()`;
};
