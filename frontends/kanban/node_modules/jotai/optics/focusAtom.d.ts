import * as O from 'optics-ts';
import type { SetStateAction, WritableAtom } from 'jotai';
declare type NonFunction<T> = [T] extends [(...args: any[]) => any] ? never : T;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<Promise<S>, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Prism<S, any, A>): WritableAtom<A | undefined, SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<Promise<S>, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Traversal<S, any, A>): WritableAtom<A[], SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<Promise<S>, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<S, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Prism<S, any, A>): WritableAtom<A | undefined, SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<S, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Traversal<S, any, A>): WritableAtom<A[], SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<S, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, SetStateAction<A>, R>;
export {};
