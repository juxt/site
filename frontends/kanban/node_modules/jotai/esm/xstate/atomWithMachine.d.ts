import type { AnyStateMachine, AreAllImplementationsAssumedToBeProvided, EventObject, InternalMachineOptions, InterpreterFrom, InterpreterOptions, Prop, StateConfig, StateFrom } from 'xstate';
import type { Getter, WritableAtom } from 'jotai';
export declare const RESTART: unique symbol;
export interface MachineAtomOptions<TContext, TEvent extends EventObject> {
    /**
     * If provided, will be merged with machine's `context`.
     */
    context?: Partial<TContext>;
    /**
     * The state to rehydrate the machine to. The machine will
     * start at this state instead of its `initialState`.
     */
    state?: StateConfig<TContext, TEvent>;
}
declare type Options<TMachine extends AnyStateMachine> = AreAllImplementationsAssumedToBeProvided<TMachine['__TResolvedTypesMeta']> extends false ? InterpreterOptions & MachineAtomOptions<TMachine['__TContext'], TMachine['__TEvent']> & InternalMachineOptions<TMachine['__TContext'], TMachine['__TEvent'], TMachine['__TResolvedTypesMeta'], true> : InterpreterOptions & MachineAtomOptions<TMachine['__TContext'], TMachine['__TEvent']> & InternalMachineOptions<TMachine['__TContext'], TMachine['__TEvent'], TMachine['__TResolvedTypesMeta']>;
declare type MaybeParam<T> = T extends (v: infer V) => unknown ? V : never;
export declare function atomWithMachine<TMachine extends AnyStateMachine, TInterpreter = InterpreterFrom<TMachine>>(getMachine: TMachine | ((get: Getter) => TMachine), getOptions?: Options<TMachine> | ((get: Getter) => Options<TMachine>)): WritableAtom<StateFrom<TMachine>, MaybeParam<Prop<TInterpreter, 'send'>> | typeof RESTART, void>;
export {};
