{"version":3,"file":"use-uncontrolled.js","sources":["../../src/use-uncontrolled/use-uncontrolled.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nexport type UncontrolledMode = 'initial' | 'controlled' | 'uncontrolled';\n\nexport interface UncontrolledOptions<T> {\n  value: T | null | undefined;\n  defaultValue: T | null | undefined;\n  finalValue: T | null;\n  onChange(value: T | null): void;\n  onValueUpdate?(value: T | null): void;\n  rule: (value: T | null | undefined) => boolean;\n}\n\nexport function useUncontrolled<T>({\n  value,\n  defaultValue,\n  finalValue,\n  rule,\n  onChange,\n  onValueUpdate,\n}: UncontrolledOptions<T>): readonly [T | null, (nextValue: T | null) => void, UncontrolledMode] {\n  // determine, whether new props indicate controlled state\n  const shouldBeControlled = rule(value);\n\n  // initialize state\n  const modeRef = useRef<UncontrolledMode>('initial');\n  const initialValue = rule(defaultValue) ? defaultValue : finalValue;\n  const [uncontrolledValue, setUncontrolledValue] = useState(initialValue);\n\n  // compute effective value\n  let effectiveValue = shouldBeControlled ? value : uncontrolledValue;\n\n  if (!shouldBeControlled && modeRef.current === 'controlled') {\n    // We are transitioning from controlled to uncontrolled\n    // this transition is special as it happens when clearing out\n    // the input using \"invalid\" value (typically null or undefined).\n    //\n    // Since the value is invalid, doing nothing would mean just\n    // transitioning to uncontrolled state and using whatever value\n    // it currently holds which is likely not the behavior\n    // user expects, so lets change the state to finalValue.\n    //\n    // The value will be propagated to internal state by useEffect below.\n\n    effectiveValue = finalValue;\n  }\n\n  modeRef.current = shouldBeControlled ? 'controlled' : 'uncontrolled';\n  const mode = modeRef.current;\n\n  const handleChange = (nextValue: T | null) => {\n    typeof onChange === 'function' && onChange(nextValue);\n\n    // Controlled input only triggers onChange event and expects\n    // the controller to propagate new value back.\n    if (mode === 'uncontrolled') {\n      setUncontrolledValue(nextValue);\n    }\n  };\n\n  useEffect(() => {\n    if (mode === 'uncontrolled') {\n      setUncontrolledValue(effectiveValue);\n    }\n    typeof onValueUpdate === 'function' && onValueUpdate(effectiveValue);\n  }, [mode, effectiveValue]);\n\n  return [effectiveValue, handleChange, modeRef.current] as const;\n}\n"],"names":["useRef","useState","useEffect"],"mappings":";;;;;;AACO,SAAS,eAAe,CAAC;AAChC,EAAE,KAAK;AACP,EAAE,YAAY;AACd,EAAE,UAAU;AACZ,EAAE,IAAI;AACN,EAAE,QAAQ;AACV,EAAE,aAAa;AACf,CAAC,EAAE;AACH,EAAE,MAAM,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;AACzC,EAAE,MAAM,OAAO,GAAGA,YAAM,CAAC,SAAS,CAAC,CAAC;AACpC,EAAE,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,YAAY,GAAG,UAAU,CAAC;AACtE,EAAE,MAAM,CAAC,iBAAiB,EAAE,oBAAoB,CAAC,GAAGC,cAAQ,CAAC,YAAY,CAAC,CAAC;AAC3E,EAAE,IAAI,cAAc,GAAG,kBAAkB,GAAG,KAAK,GAAG,iBAAiB,CAAC;AACtE,EAAE,IAAI,CAAC,kBAAkB,IAAI,OAAO,CAAC,OAAO,KAAK,YAAY,EAAE;AAC/D,IAAI,cAAc,GAAG,UAAU,CAAC;AAChC,GAAG;AACH,EAAE,OAAO,CAAC,OAAO,GAAG,kBAAkB,GAAG,YAAY,GAAG,cAAc,CAAC;AACvE,EAAE,MAAM,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC;AAC/B,EAAE,MAAM,YAAY,GAAG,CAAC,SAAS,KAAK;AACtC,IAAI,OAAO,QAAQ,KAAK,UAAU,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC;AAC1D,IAAI,IAAI,IAAI,KAAK,cAAc,EAAE;AACjC,MAAM,oBAAoB,CAAC,SAAS,CAAC,CAAC;AACtC,KAAK;AACL,GAAG,CAAC;AACJ,EAAEC,eAAS,CAAC,MAAM;AAClB,IAAI,IAAI,IAAI,KAAK,cAAc,EAAE;AACjC,MAAM,oBAAoB,CAAC,cAAc,CAAC,CAAC;AAC3C,KAAK;AACL,IAAI,OAAO,aAAa,KAAK,UAAU,IAAI,aAAa,CAAC,cAAc,CAAC,CAAC;AACzE,GAAG,EAAE,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC,CAAC;AAC7B,EAAE,OAAO,CAAC,cAAc,EAAE,YAAY,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;AACzD;;;;"}