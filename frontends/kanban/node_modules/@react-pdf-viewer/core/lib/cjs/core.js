'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var PdfJsApi = require('pdfjs-dist');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var PdfJsApi__namespace = /*#__PURE__*/_interopNamespace(PdfJsApi);

exports.AnnotationType = void 0;
(function (AnnotationType) {
    AnnotationType[AnnotationType["Text"] = 1] = "Text";
    AnnotationType[AnnotationType["Link"] = 2] = "Link";
    AnnotationType[AnnotationType["FreeText"] = 3] = "FreeText";
    AnnotationType[AnnotationType["Line"] = 4] = "Line";
    AnnotationType[AnnotationType["Square"] = 5] = "Square";
    AnnotationType[AnnotationType["Circle"] = 6] = "Circle";
    AnnotationType[AnnotationType["Polygon"] = 7] = "Polygon";
    AnnotationType[AnnotationType["Polyline"] = 8] = "Polyline";
    AnnotationType[AnnotationType["Highlight"] = 9] = "Highlight";
    AnnotationType[AnnotationType["Underline"] = 10] = "Underline";
    AnnotationType[AnnotationType["Squiggly"] = 11] = "Squiggly";
    AnnotationType[AnnotationType["StrikeOut"] = 12] = "StrikeOut";
    AnnotationType[AnnotationType["Stamp"] = 13] = "Stamp";
    AnnotationType[AnnotationType["Caret"] = 14] = "Caret";
    AnnotationType[AnnotationType["Ink"] = 15] = "Ink";
    AnnotationType[AnnotationType["Popup"] = 16] = "Popup";
    AnnotationType[AnnotationType["FileAttachment"] = 17] = "FileAttachment";
})(exports.AnnotationType || (exports.AnnotationType = {}));

exports.LayerRenderStatus = void 0;
(function (LayerRenderStatus) {
    LayerRenderStatus[LayerRenderStatus["PreRender"] = 0] = "PreRender";
    LayerRenderStatus[LayerRenderStatus["DidRender"] = 1] = "DidRender";
})(exports.LayerRenderStatus || (exports.LayerRenderStatus = {}));

exports.Position = void 0;
(function (Position) {
    Position["TopLeft"] = "TOP_LEFT";
    Position["TopCenter"] = "TOP_CENTER";
    Position["TopRight"] = "TOP_RIGHT";
    Position["RightTop"] = "RIGHT_TOP";
    Position["RightCenter"] = "RIGHT_CENTER";
    Position["RightBottom"] = "RIGHT_BOTTOM";
    Position["BottomLeft"] = "BOTTOM_LEFT";
    Position["BottomCenter"] = "BOTTOM_CENTER";
    Position["BottomRight"] = "BOTTOM_RIGHT";
    Position["LeftTop"] = "LEFT_TOP";
    Position["LeftCenter"] = "LEFT_CENTER";
    Position["LeftBottom"] = "LEFT_BOTTOM";
})(exports.Position || (exports.Position = {}));

exports.ScrollMode = void 0;
(function (ScrollMode) {
    ScrollMode["Horizontal"] = "Horizontal";
    ScrollMode["Vertical"] = "Vertical";
    ScrollMode["Wrapped"] = "Wrapped";
})(exports.ScrollMode || (exports.ScrollMode = {}));

exports.SpecialZoomLevel = void 0;
(function (SpecialZoomLevel) {
    SpecialZoomLevel["ActualSize"] = "ActualSize";
    SpecialZoomLevel["PageFit"] = "PageFit";
    SpecialZoomLevel["PageWidth"] = "PageWidth";
})(exports.SpecialZoomLevel || (exports.SpecialZoomLevel = {}));

exports.ToggleStatus = void 0;
(function (ToggleStatus) {
    ToggleStatus["Close"] = "Close";
    ToggleStatus["Open"] = "Open";
    ToggleStatus["Toggle"] = "Toggle";
})(exports.ToggleStatus || (exports.ToggleStatus = {}));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

exports.TextDirection = void 0;
(function (TextDirection) {
    TextDirection["RightToLeft"] = "RTL";
    TextDirection["LeftToRight"] = "LTR";
})(exports.TextDirection || (exports.TextDirection = {}));
var ThemeContext = React__namespace.createContext({
    currentTheme: 'light',
    direction: exports.TextDirection.LeftToRight,
    setCurrentTheme: function () { },
});

var classNames = function (classes) {
    var result = [];
    Object.keys(classes).forEach(function (clazz) {
        if (clazz && classes[clazz]) {
            result.push(clazz);
        }
    });
    return result.join(' ');
};

var Button = function (_a) {
    var children = _a.children, testId = _a.testId, onClick = _a.onClick;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var attrs = testId ? { 'data-testid': testId } : {};
    return (React__namespace.createElement("button", __assign({ className: classNames({
            'rpv-core__button': true,
            'rpv-core__button--rtl': isRtl,
        }), type: "button", onClick: onClick }, attrs), children));
};

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;

var useIntersectionObserver = function (props) {
    var containerRef = React__namespace.useRef(null);
    var once = props.once, threshold = props.threshold, onVisibilityChanged = props.onVisibilityChanged;
    useIsomorphicLayoutEffect(function () {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        var intersectionTracker = new IntersectionObserver(function (entries) {
            entries.forEach(function (entry) {
                var isVisible = entry.isIntersecting;
                var ratio = entry.intersectionRatio;
                onVisibilityChanged({ isVisible: isVisible, ratio: ratio });
                if (isVisible && once) {
                    intersectionTracker.unobserve(container);
                    intersectionTracker.disconnect();
                }
            });
        }, {
            threshold: threshold || 0,
        });
        intersectionTracker.observe(container);
        return function () {
            intersectionTracker.unobserve(container);
            intersectionTracker.disconnect();
        };
    }, []);
    return containerRef;
};

var LazyRender = function (_a) {
    var attrs = _a.attrs, children = _a.children, testId = _a.testId;
    var _b = React__namespace.useState(false), visible = _b[0], setVisible = _b[1];
    var containerAttrs = testId ? __assign(__assign({}, attrs), { 'data-testid': testId }) : attrs;
    var handleVisibilityChanged = function (params) {
        if (params.isVisible) {
            setVisible(true);
        }
    };
    var containerRef = useIntersectionObserver({
        once: true,
        onVisibilityChanged: handleVisibilityChanged,
    });
    return (React__namespace.createElement("div", __assign({ ref: containerRef }, containerAttrs), visible && children));
};

var Menu = function (_a) {
    var children = _a.children;
    var containerRef = React__namespace.useRef();
    var visibleMenuItemsRef = React__namespace.useRef([]);
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var handleKeyDown = function (e) {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        switch (e.key) {
            case 'Tab':
                e.preventDefault();
                break;
            case 'ArrowDown':
                e.preventDefault();
                moveToItem(function (_, currentIndex) { return currentIndex + 1; });
                break;
            case 'ArrowUp':
                e.preventDefault();
                moveToItem(function (_, currentIndex) { return currentIndex - 1; });
                break;
            case 'End':
                e.preventDefault();
                moveToItem(function (items, _) { return items.length - 1; });
                break;
            case 'Home':
                e.preventDefault();
                moveToItem(function (_, __) { return 0; });
                break;
        }
    };
    var moveToItem = function (getNextItem) {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        var items = visibleMenuItemsRef.current;
        var currentIndex = items.findIndex(function (item) { return item.getAttribute('tabindex') === '0'; });
        var targetIndex = Math.min(items.length - 1, Math.max(0, getNextItem(items, currentIndex)));
        if (currentIndex >= 0 && currentIndex <= items.length - 1) {
            items[currentIndex].setAttribute('tabindex', '-1');
        }
        items[targetIndex].setAttribute('tabindex', '0');
        items[targetIndex].focus();
    };
    var findVisibleItems = function (container) {
        var visibleItems = [];
        container.querySelectorAll('.rpv-core__menu-item[role="menuitem"]').forEach(function (item) {
            if (item instanceof HTMLElement) {
                var parent_1 = item.parentElement;
                if (parent_1 === container) {
                    visibleItems.push(item);
                }
                else {
                    if (window.getComputedStyle(parent_1).display !== 'none') {
                        visibleItems.push(item);
                    }
                }
            }
        });
        return visibleItems;
    };
    useIsomorphicLayoutEffect(function () {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        var visibleItems = findVisibleItems(container);
        visibleMenuItemsRef.current = visibleItems;
    }, []);
    useIsomorphicLayoutEffect(function () {
        document.addEventListener('keydown', handleKeyDown);
        return function () {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, []);
    return (React__namespace.createElement("div", { ref: containerRef, "aria-orientation": "vertical", className: classNames({
            'rpv-core__menu': true,
            'rpv-core__menu--rtl': isRtl,
        }), role: "menu", tabIndex: 0 }, children));
};

var MenuDivider = function () { return (React__namespace.createElement("div", { "aria-orientation": "horizontal", className: "rpv-core__menu-divider", role: "separator" })); };

var Icon = function (_a) {
    var children = _a.children, _b = _a.ignoreDirection, ignoreDirection = _b === void 0 ? false : _b, _c = _a.size, size = _c === void 0 ? 24 : _c;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = !ignoreDirection && direction === exports.TextDirection.RightToLeft;
    var width = "".concat(size || 24, "px");
    return (React__namespace.createElement("svg", { "aria-hidden": "true", className: classNames({
            'rpv-core__icon': true,
            'rpv-core__icon--rtl': isRtl,
        }), focusable: "false", height: width, viewBox: "0 0 24 24", width: width }, children));
};

var CheckIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M23.5,0.499l-16.5,23l-6.5-6.5" }))); };

var MenuItem = function (_a) {
    var _b = _a.checked, checked = _b === void 0 ? false : _b, children = _a.children, _c = _a.icon, icon = _c === void 0 ? null : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, testId = _a.testId, onClick = _a.onClick;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var attrs = testId ? { 'data-testid': testId } : {};
    return (React__namespace.createElement("button", __assign({ className: classNames({
            'rpv-core__menu-item': true,
            'rpv-core__menu-item--disabled': isDisabled,
            'rpv-core__menu-item--ltr': !isRtl,
            'rpv-core__menu-item--rtl': isRtl,
        }), role: "menuitem", tabIndex: -1, type: "button", onClick: onClick }, attrs),
        React__namespace.createElement("div", { className: classNames({
                'rpv-core__menu-item-icon': true,
                'rpv-core__menu-item-icon--ltr': !isRtl,
                'rpv-core__menu-item-icon--rtl': isRtl,
            }) }, icon),
        React__namespace.createElement("div", { className: classNames({
                'rpv-core__menu-item-label': true,
                'rpv-core__menu-item-label--ltr': !isRtl,
                'rpv-core__menu-item-label--rtl': isRtl,
            }) }, children),
        React__namespace.createElement("div", { className: classNames({
                'rpv-core__menu-item-check': true,
                'rpv-core__menu-item-check--ltr': !isRtl,
                'rpv-core__menu-item-check--rtl': isRtl,
            }) }, checked && React__namespace.createElement(CheckIcon, null))));
};

var MinimalButton = function (_a) {
    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.ariaKeyShortcuts, ariaKeyShortcuts = _c === void 0 ? '' : _c, children = _a.children, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.isSelected, isSelected = _e === void 0 ? false : _e, testId = _a.testId, onClick = _a.onClick;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var attrs = testId ? { 'data-testid': testId } : {};
    return (React__namespace.createElement("button", __assign({ "aria-label": ariaLabel }, (ariaKeyShortcuts && { 'aria-keyshortcuts': ariaKeyShortcuts }), (isDisabled && { 'aria-disabled': true }), { className: classNames({
            'rpv-core__minimal-button': true,
            'rpv-core__minimal-button--disabled': isDisabled,
            'rpv-core__minimal-button--rtl': isRtl,
            'rpv-core__minimal-button--selected': isSelected,
        }), type: "button", onClick: onClick }, attrs), children));
};

var PrimaryButton = function (_a) {
    var children = _a.children, testId = _a.testId, onClick = _a.onClick;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var attrs = testId ? { 'data-testid': testId } : {};
    return (React__namespace.createElement("button", __assign({ className: classNames({
            'rpv-core__primary-button': true,
            'rpv-core__primary-button--rtl': isRtl,
        }), type: "button", onClick: onClick }, attrs), children));
};

var ProgressBar = function (_a) {
    var progress = _a.progress;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    return (React__namespace.createElement("div", { className: classNames({
            'rpv-core__progress-bar': true,
            'rpv-core__progress-bar--rtl': isRtl,
        }) },
        React__namespace.createElement("div", { className: "rpv-core__progress-bar-progress", style: { width: "".concat(progress, "%") } },
            progress,
            "%")));
};

var Separator = function () { return React__namespace.createElement("div", { className: "rpv-core__separator" }); };

var Spinner = function (_a) {
    var _b = _a.size, size = _b === void 0 ? '4rem' : _b, testId = _a.testId;
    var _c = React__namespace.useState(false), visible = _c[0], setVisible = _c[1];
    var attrs = testId ? { 'data-testid': testId } : {};
    var handleVisibilityChanged = function (params) {
        setVisible(params.isVisible);
    };
    var containerRef = useIntersectionObserver({
        onVisibilityChanged: handleVisibilityChanged,
    });
    return (React__namespace.createElement("div", __assign({}, attrs, { className: classNames({
            'rpv-core__spinner': true,
            'rpv-core__spinner--animating': visible,
        }), ref: containerRef, style: { height: size, width: size } })));
};

var Splitter = function (_a) {
    var constrain = _a.constrain;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var resizerRef = React__namespace.useRef();
    var leftSideRef = React__namespace.useRef();
    var rightSideRef = React__namespace.useRef();
    var xRef = React__namespace.useRef(0);
    var yRef = React__namespace.useRef(0);
    var leftWidthRef = React__namespace.useRef(0);
    var resizerWidthRef = React__namespace.useRef(0);
    var eventOptions = {
        capture: true,
    };
    var handleMouseMove = function (e) {
        var resizerEle = resizerRef.current;
        var leftSide = leftSideRef.current;
        var rightSide = rightSideRef.current;
        if (!resizerEle || !leftSide || !rightSide) {
            return;
        }
        var resizerWidth = resizerWidthRef.current;
        var dx = e.clientX - xRef.current;
        var firstHalfSize = leftWidthRef.current + (isRtl ? -dx : dx);
        var containerWidth = resizerEle.parentElement.getBoundingClientRect().width;
        var firstHalfPercentage = (firstHalfSize * 100) / containerWidth;
        resizerEle.classList.add('rpv-core__splitter--resizing');
        if (constrain) {
            var secondHalfSize = containerWidth - firstHalfSize - resizerWidth;
            var secondHalfPercentage = (secondHalfSize * 100) / containerWidth;
            if (!constrain({ firstHalfPercentage: firstHalfPercentage, firstHalfSize: firstHalfSize, secondHalfPercentage: secondHalfPercentage, secondHalfSize: secondHalfSize })) {
                return;
            }
        }
        leftSide.style.width = "".concat(firstHalfPercentage, "%");
        document.body.classList.add('rpv-core__splitter-body--resizing');
        leftSide.classList.add('rpv-core__splitter-sibling--resizing');
        rightSide.classList.add('rpv-core__splitter-sibling--resizing');
    };
    var handleMouseUp = function (e) {
        var resizerEle = resizerRef.current;
        var leftSide = leftSideRef.current;
        var rightSide = rightSideRef.current;
        if (!resizerEle || !leftSide || !rightSide) {
            return;
        }
        document.body.classList.remove('rpv-core__splitter-body--resizing');
        resizerEle.classList.remove('rpv-core__splitter--resizing');
        leftSide.classList.remove('rpv-core__splitter-sibling--resizing');
        rightSide.classList.remove('rpv-core__splitter-sibling--resizing');
        document.removeEventListener('mousemove', handleMouseMove, eventOptions);
        document.removeEventListener('mouseup', handleMouseUp, eventOptions);
    };
    var handleMouseDown = function (e) {
        var leftSide = leftSideRef.current;
        if (!leftSide) {
            return;
        }
        xRef.current = e.clientX;
        yRef.current = e.clientY;
        leftWidthRef.current = leftSide.getBoundingClientRect().width;
        document.addEventListener('mousemove', handleMouseMove, eventOptions);
        document.addEventListener('mouseup', handleMouseUp, eventOptions);
    };
    React__namespace.useEffect(function () {
        var resizerEle = resizerRef.current;
        if (!resizerEle) {
            return;
        }
        resizerWidthRef.current = resizerEle.getBoundingClientRect().width;
        leftSideRef.current = resizerEle.previousElementSibling;
        rightSideRef.current = resizerEle.nextElementSibling;
    }, []);
    return React__namespace.createElement("div", { ref: resizerRef, className: "rpv-core__splitter", onMouseDown: handleMouseDown });
};

var TextBox = function (_a) {
    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.autoFocus, autoFocus = _c === void 0 ? false : _c, _d = _a.placeholder, placeholder = _d === void 0 ? '' : _d, testId = _a.testId, _e = _a.type, type = _e === void 0 ? 'text' : _e, _f = _a.value, value = _f === void 0 ? '' : _f, onChange = _a.onChange, _g = _a.onKeyDown, onKeyDown = _g === void 0 ? function () { } : _g;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var textboxRef = React__namespace.useRef();
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var attrs = {
        ref: textboxRef,
        'data-testid': '',
        'aria-label': ariaLabel,
        className: classNames({
            'rpv-core__textbox': true,
            'rpv-core__textbox--rtl': isRtl,
        }),
        placeholder: placeholder,
        value: value,
        onChange: function (e) { return onChange(e.target.value); },
        onKeyDown: onKeyDown,
    };
    if (testId) {
        attrs['data-testid'] = testId;
    }
    useIsomorphicLayoutEffect(function () {
        if (autoFocus) {
            var textboxEle = textboxRef.current;
            if (textboxEle) {
                var x = window.scrollX;
                var y = window.scrollY;
                textboxEle.focus();
                window.scrollTo(x, y);
            }
        }
    }, []);
    return type === 'text' ? React__namespace.createElement("input", __assign({ type: "text" }, attrs)) : React__namespace.createElement("input", __assign({ type: "password" }, attrs));
};

var useClickOutside = function (closeOnClickOutside, targetRef, onClickOutside) {
    var clickHandler = function (e) {
        var target = targetRef.current;
        if (target && !target.contains(e.target)) {
            onClickOutside();
        }
    };
    React__namespace.useEffect(function () {
        if (!closeOnClickOutside) {
            return;
        }
        var eventOptions = {
            capture: true,
        };
        document.addEventListener('click', clickHandler, eventOptions);
        return function () {
            document.removeEventListener('click', clickHandler, eventOptions);
        };
    }, []);
};

var useEscape = function (handler) {
    var keyUpHandler = function (e) {
        if (e.key === 'Escape') {
            handler();
        }
    };
    React__namespace.useEffect(function () {
        document.addEventListener('keyup', keyUpHandler);
        return function () {
            document.removeEventListener('keyup', keyUpHandler);
        };
    }, []);
};

var useLockScroll = function () {
    React__namespace.useEffect(function () {
        var originalStyle = window.getComputedStyle(document.body).overflow;
        document.body.style.overflow = 'hidden';
        return function () {
            document.body.style.overflow = originalStyle;
        };
    }, []);
};

var ModalBody = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, onToggle = _a.onToggle;
    var contentRef = React__namespace.useRef();
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    useLockScroll();
    useEscape(function () {
        if (contentRef.current && closeOnEscape) {
            onToggle();
        }
    });
    useClickOutside(closeOnClickOutside, contentRef, onToggle);
    useIsomorphicLayoutEffect(function () {
        var contentEle = contentRef.current;
        if (!contentEle) {
            return;
        }
        var maxHeight = document.body.clientHeight * 0.75;
        if (contentEle.getBoundingClientRect().height >= maxHeight) {
            contentEle.style.overflow = 'auto';
            contentEle.style.maxHeight = "".concat(maxHeight, "px");
        }
    }, []);
    return (React__namespace.createElement("div", { "aria-modal": "true", className: classNames({
            'rpv-core__modal-body': true,
            'rpv-core__modal-body--rtl': isRtl,
        }), id: "rpv-core__modal-body-".concat(ariaControlsSuffix), ref: contentRef, role: "dialog", tabIndex: -1 }, children));
};

var ModalOverlay = function (_a) {
    var children = _a.children;
    return React__namespace.createElement("div", { className: "rpv-core__modal-overlay" }, children);
};

var useToggle = function (isOpened) {
    var _a = React__namespace.useState(isOpened), opened = _a[0], setOpened = _a[1];
    var toggle = function (status) {
        switch (status) {
            case exports.ToggleStatus.Close:
                setOpened(false);
                break;
            case exports.ToggleStatus.Open:
                setOpened(true);
                break;
            case exports.ToggleStatus.Toggle:
            default:
                setOpened(function (isOpened) { return !isOpened; });
                break;
        }
    };
    return { opened: opened, toggle: toggle };
};

var Portal = function (_a) {
    var content = _a.content, _b = _a.isOpened, isOpened = _b === void 0 ? false : _b, target = _a.target;
    var _c = useToggle(isOpened), opened = _c.opened, toggle = _c.toggle;
    return (React__namespace.createElement(React__namespace.Fragment, null,
        target && target(toggle, opened),
        opened && content(toggle)));
};

var id = 0;
var uniqueId = function () { return id++; };

var Modal = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, _b = _a.isOpened, isOpened = _b === void 0 ? false : _b, target = _a.target;
    var controlsSuffix = ariaControlsSuffix || "".concat(uniqueId());
    var renderTarget = function (toggle, opened) { return (React__namespace.createElement("div", { "aria-expanded": opened ? 'true' : 'false', "aria-haspopup": "dialog", "aria-controls": "rpv-core__modal-body-".concat(controlsSuffix) }, target(toggle, opened))); };
    var renderContent = function (toggle) { return (React__namespace.createElement(ModalOverlay, null,
        React__namespace.createElement(ModalBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, closeOnEscape: closeOnEscape, onToggle: toggle }, content(toggle)))); };
    return React__namespace.createElement(Portal, { target: target ? renderTarget : null, content: renderContent, isOpened: isOpened });
};

var calculatePosition = function (content, target, position, offset) {
    var targetRect = target.getBoundingClientRect();
    var contentRect = content.getBoundingClientRect();
    var height = contentRect.height, width = contentRect.width;
    var top = 0;
    var left = 0;
    switch (position) {
        case exports.Position.TopLeft:
            top = targetRect.top - height;
            left = targetRect.left;
            break;
        case exports.Position.TopCenter:
            top = targetRect.top - height;
            left = targetRect.left + targetRect.width / 2 - width / 2;
            break;
        case exports.Position.TopRight:
            top = targetRect.top - height;
            left = targetRect.left + targetRect.width - width;
            break;
        case exports.Position.RightTop:
            top = targetRect.top;
            left = targetRect.left + targetRect.width;
            break;
        case exports.Position.RightCenter:
            top = targetRect.top + targetRect.height / 2 - height / 2;
            left = targetRect.left + targetRect.width;
            break;
        case exports.Position.RightBottom:
            top = targetRect.top + targetRect.height - height;
            left = targetRect.left + targetRect.width;
            break;
        case exports.Position.BottomLeft:
            top = targetRect.top + targetRect.height;
            left = targetRect.left;
            break;
        case exports.Position.BottomCenter:
            top = targetRect.top + targetRect.height;
            left = targetRect.left + targetRect.width / 2 - width / 2;
            break;
        case exports.Position.BottomRight:
            top = targetRect.top + targetRect.height;
            left = targetRect.left + targetRect.width - width;
            break;
        case exports.Position.LeftTop:
            top = targetRect.top;
            left = targetRect.left - width;
            break;
        case exports.Position.LeftCenter:
            top = targetRect.top + targetRect.height / 2 - height / 2;
            left = targetRect.left - width;
            break;
        case exports.Position.LeftBottom:
            top = targetRect.top + targetRect.height - height;
            left = targetRect.left - width;
            break;
    }
    return {
        left: left + (offset.left || 0),
        top: top + (offset.top || 0),
    };
};

var usePosition = function (contentRef, targetRef, anchorRef, position, offset) {
    useIsomorphicLayoutEffect(function () {
        var targetEle = targetRef.current;
        var contentEle = contentRef.current;
        var anchorEle = anchorRef.current;
        if (!contentEle || !targetEle || !anchorEle) {
            return;
        }
        var anchorRect = anchorEle.getBoundingClientRect();
        var _a = calculatePosition(contentEle, targetEle, position, offset), top = _a.top, left = _a.left;
        contentEle.style.top = "".concat(top - anchorRect.top, "px");
        contentEle.style.left = "".concat(left - anchorRect.left, "px");
    }, []);
};

var Arrow = function (_a) {
    var _b;
    var customClassName = _a.customClassName, position = _a.position;
    return (React__namespace.createElement("div", { className: classNames((_b = {
                'rpv-core__arrow': true,
                'rpv-core__arrow--tl': position === exports.Position.TopLeft,
                'rpv-core__arrow--tc': position === exports.Position.TopCenter,
                'rpv-core__arrow--tr': position === exports.Position.TopRight,
                'rpv-core__arrow--rt': position === exports.Position.RightTop,
                'rpv-core__arrow--rc': position === exports.Position.RightCenter,
                'rpv-core__arrow--rb': position === exports.Position.RightBottom,
                'rpv-core__arrow--bl': position === exports.Position.BottomLeft,
                'rpv-core__arrow--bc': position === exports.Position.BottomCenter,
                'rpv-core__arrow--br': position === exports.Position.BottomRight,
                'rpv-core__arrow--lt': position === exports.Position.LeftTop,
                'rpv-core__arrow--lc': position === exports.Position.LeftCenter,
                'rpv-core__arrow--lb': position === exports.Position.LeftBottom
            },
            _b["".concat(customClassName)] = customClassName !== '',
            _b)) }));
};

var PopoverBody = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, offset = _a.offset, position = _a.position, targetRef = _a.targetRef, onClose = _a.onClose;
    var contentRef = React__namespace.useRef();
    var innerRef = React__namespace.useRef();
    var anchorRef = React__namespace.useRef();
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    useClickOutside(closeOnClickOutside, contentRef, onClose);
    usePosition(contentRef, targetRef, anchorRef, position, offset);
    useIsomorphicLayoutEffect(function () {
        var innerContentEle = innerRef.current;
        if (!innerContentEle) {
            return;
        }
        var maxHeight = document.body.clientHeight * 0.75;
        if (innerContentEle.getBoundingClientRect().height >= maxHeight) {
            innerContentEle.style.overflow = 'auto';
            innerContentEle.style.maxHeight = "".concat(maxHeight, "px");
        }
    }, []);
    var innerId = "rpv-core__popover-body-inner-".concat(ariaControlsSuffix);
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),
        React__namespace.createElement("div", { "aria-describedby": innerId, className: classNames({
                'rpv-core__popover-body': true,
                'rpv-core__popover-body--rtl': isRtl,
            }), id: "rpv-core__popover-body-".concat(ariaControlsSuffix), ref: contentRef, role: "dialog", tabIndex: -1 },
            React__namespace.createElement(Arrow, { customClassName: "rpv-core__popover-body-arrow", position: position }),
            React__namespace.createElement("div", { id: innerId, ref: innerRef }, children))));
};

var PopoverOverlay = function (_a) {
    var closeOnEscape = _a.closeOnEscape, onClose = _a.onClose;
    var containerRef = React__namespace.useRef();
    useEscape(function () {
        if (containerRef.current && closeOnEscape) {
            onClose();
        }
    });
    return React__namespace.createElement("div", { className: "rpv-core__popover-overlay", ref: containerRef });
};

var Popover = function (_a) {
    var _b = _a.ariaHasPopup, ariaHasPopup = _b === void 0 ? 'dialog' : _b, ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, offset = _a.offset, position = _a.position, target = _a.target;
    var _c = useToggle(false), opened = _c.opened, toggle = _c.toggle;
    var targetRef = React__namespace.useRef();
    var controlsSuffix = ariaControlsSuffix || "".concat(uniqueId());
    return (React__namespace.createElement("div", { ref: targetRef, "aria-expanded": opened ? 'true' : 'false', "aria-haspopup": ariaHasPopup, "aria-controls": "rpv-core__popver-body-".concat(controlsSuffix) },
        target(toggle, opened),
        opened && (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement(PopoverOverlay, { closeOnEscape: closeOnEscape, onClose: toggle }),
            React__namespace.createElement(PopoverBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, offset: offset, position: position, targetRef: targetRef, onClose: toggle }, content(toggle))))));
};

var TooltipBody = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, contentRef = _a.contentRef, offset = _a.offset, position = _a.position, targetRef = _a.targetRef;
    var anchorRef = React__namespace.useRef();
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    usePosition(contentRef, targetRef, anchorRef, position, offset);
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),
        React__namespace.createElement("div", { className: classNames({
                'rpv-core__tooltip-body': true,
                'rpv-core__tooltip-body--rtl': isRtl,
            }), id: "rpv-core__tooltip-body-".concat(ariaControlsSuffix), ref: contentRef, role: "tooltip" },
            React__namespace.createElement(Arrow, { customClassName: "rpv-core__tooltip-body-arrow", position: position }),
            React__namespace.createElement("div", { className: "rpv-core__tooltip-body-content" }, children))));
};

var Tooltip = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, content = _a.content, offset = _a.offset, position = _a.position, target = _a.target;
    var _b = useToggle(false), opened = _b.opened, toggle = _b.toggle;
    var targetRef = React__namespace.useRef();
    var contentRef = React__namespace.useRef();
    var controlsSuffix = ariaControlsSuffix || "".concat(uniqueId());
    useEscape(function () {
        if (targetRef.current && document.activeElement && targetRef.current.contains(document.activeElement)) {
            close();
        }
    });
    var open = function () {
        toggle(exports.ToggleStatus.Open);
    };
    var close = function () {
        toggle(exports.ToggleStatus.Close);
    };
    var onBlur = function (e) {
        var shouldHideTooltip = e.relatedTarget instanceof HTMLElement &&
            e.currentTarget.parentElement &&
            e.currentTarget.parentElement.contains(e.relatedTarget);
        if (shouldHideTooltip) {
            if (contentRef.current) {
                contentRef.current.style.display = 'none';
            }
        }
        else {
            close();
        }
    };
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", { ref: targetRef, "aria-describedby": "rpv-core__tooltip-body-".concat(controlsSuffix), onBlur: onBlur, onFocus: open, onMouseEnter: open, onMouseLeave: close }, target),
        opened && (React__namespace.createElement(TooltipBody, { ariaControlsSuffix: controlsSuffix, contentRef: contentRef, offset: offset, position: position, targetRef: targetRef }, content()))));
};

var PageRenderStatus;
(function (PageRenderStatus) {
    PageRenderStatus["NotRenderedYet"] = "NotRenderedYet";
    PageRenderStatus["Rendering"] = "Rendering";
    PageRenderStatus["Rendered"] = "Rendered";
})(PageRenderStatus || (PageRenderStatus = {}));
var OUT_OF_RANGE_VISIBILITY = -9999;
var pageVisibilities = {};
var renderQueueService = function (_a) {
    var doc = _a.doc, queueName = _a.queueName; _a.priority;
    var numPages = doc.numPages;
    var queue = "".concat(queueName, "___").concat(doc.loadingTask.docId);
    var getInitialPageVisibilities = function () {
        return Array(numPages)
            .fill(null)
            .map(function (_, pageIndex) { return ({
            pageIndex: pageIndex,
            renderStatus: PageRenderStatus.NotRenderedYet,
            visibility: OUT_OF_RANGE_VISIBILITY,
        }); });
    };
    var cleanup = function () {
        pageVisibilities[queue] = [];
    };
    var resetQueue = function () {
        pageVisibilities[queue] = getInitialPageVisibilities();
    };
    var markRendered = function (pageIndex) {
        pageVisibilities[queue][pageIndex].renderStatus = PageRenderStatus.Rendered;
    };
    var markRendering = function (pageIndex) {
        pageVisibilities[queue][pageIndex].renderStatus = PageRenderStatus.Rendering;
    };
    var setRange = function (startIndex, endIndex) {
        for (var i = 0; i < numPages; i++) {
            if (i < startIndex || i > endIndex) {
                pageVisibilities[queue][i].visibility = OUT_OF_RANGE_VISIBILITY;
                pageVisibilities[queue][i].renderStatus = PageRenderStatus.NotRenderedYet;
            }
        }
    };
    var setVisibility = function (pageIndex, visibility) {
        pageVisibilities[queue][pageIndex].visibility = visibility;
    };
    var getHighestPriorityPage = function () {
        var visiblePages = pageVisibilities[queue].filter(function (item) { return item.visibility > OUT_OF_RANGE_VISIBILITY; });
        if (!visiblePages.length) {
            return -1;
        }
        var firstVisiblePage = visiblePages[0].pageIndex;
        var lastVisiblePage = visiblePages[visiblePages.length - 1].pageIndex;
        var numVisiblePages = visiblePages.length;
        for (var i = 0; i < numVisiblePages; i++) {
            if (visiblePages[i].renderStatus === PageRenderStatus.Rendering) {
                return -1;
            }
            if (visiblePages[i].renderStatus === PageRenderStatus.NotRenderedYet) {
                return visiblePages[i].pageIndex;
            }
        }
        if (lastVisiblePage + 1 < numPages &&
            pageVisibilities[queue][lastVisiblePage + 1].renderStatus !== PageRenderStatus.Rendered) {
            return lastVisiblePage + 1;
        }
        else if (firstVisiblePage - 1 >= 0 &&
            pageVisibilities[queue][firstVisiblePage - 1].renderStatus !== PageRenderStatus.Rendered) {
            return firstVisiblePage - 1;
        }
        return -1;
    };
    resetQueue();
    return {
        OUT_OF_RANGE_VISIBILITY: OUT_OF_RANGE_VISIBILITY,
        cleanup: cleanup,
        getHighestPriorityPage: getHighestPriorityPage,
        markRendered: markRendered,
        markRendering: markRendering,
        resetQueue: resetQueue,
        setRange: setRange,
        setVisibility: setVisibility,
    };
};

function createStore(initialState) {
    var state = initialState || {};
    var listeners = {};
    return {
        subscribe: function (key, handler) {
            listeners[key] = (listeners[key] || []).concat(handler);
        },
        unsubscribe: function (key, handler) {
            listeners[key] = (listeners[key] || []).filter(function (f) { return f !== handler; });
        },
        update: function (key, data) {
            var _a;
            state = __assign(__assign({}, state), (_a = {}, _a[key] = data, _a));
            (listeners[key] || []).forEach(function (handler) { return handler(state[key]); });
        },
        get: function (key) {
            return state[key];
        },
    };
}

var core = {
	askingPassword: {
		requirePasswordToOpen: "This document requires a password to open",
		submit: "Submit"
	},
	wrongPassword: {
		tryAgain: "The password is wrong. Please try again"
	},
	pageLabel: "Page {{pageIndex}}"
};
var enUs = {
	core: core
};

var DefaultLocalization = enUs;
var LocalizationContext = React__namespace.createContext({
    l10n: DefaultLocalization,
    setL10n: function () { },
});

function usePrevious(value) {
    var ref = React__namespace.useRef(value);
    React__namespace.useEffect(function () {
        ref.current = value;
    }, [value]);
    return ref.current;
}

var useTrackResize = function (_a) {
    var targetRef = _a.targetRef, onResize = _a.onResize;
    useIsomorphicLayoutEffect(function () {
        var io = new ResizeObserver(function (entries) {
            entries.forEach(function (entry) {
                onResize(entry.target);
            });
        });
        var container = targetRef.current;
        if (!container) {
            return;
        }
        io.observe(container);
        return function () {
            io.unobserve(container);
        };
    }, []);
};

var rectReducer = function (state, action) {
    var rect = action.rect;
    return state.height !== rect.height || state.width !== rect.width ? rect : state;
};
var useMeasureRect = function (_a) {
    var elementRef = _a.elementRef;
    var _b = React__namespace.useState(elementRef.current), element = _b[0], setElement = _b[1];
    var initializedRectRef = React__namespace.useRef(false);
    var _c = React__namespace.useReducer(rectReducer, { height: 0, width: 0 }), rect = _c[0], dispatch = _c[1];
    useIsomorphicLayoutEffect(function () {
        if (elementRef.current !== element) {
            setElement(elementRef.current);
        }
    });
    useIsomorphicLayoutEffect(function () {
        if (element && !initializedRectRef.current) {
            initializedRectRef.current = true;
            var _a = element.getBoundingClientRect(), height = _a.height, width = _a.width;
            dispatch({
                rect: { height: height, width: width },
            });
        }
    }, [element]);
    React__namespace.useEffect(function () {
        if (!element) {
            return;
        }
        var tracker = new ResizeObserver(function (entries, __) {
            entries.forEach(function (entry) {
                if (entry.target === element) {
                    var _a = entry.contentRect, height = _a.height, width = _a.width;
                    dispatch({
                        rect: { height: height, width: width },
                    });
                }
            });
        });
        tracker.observe(element);
        return function () {
            tracker.unobserve(element);
        };
    }, [element]);
    return rect;
};

var useIsMounted = function () {
    var isMountedRef = React__namespace.useRef(false);
    React__namespace.useEffect(function () {
        isMountedRef.current = true;
        return function () {
            isMountedRef.current = false;
        };
    }, []);
    return isMountedRef;
};

var useRafState = function (initialState) {
    var isMounted = useIsMounted();
    var rafRef = React__namespace.useRef(0);
    var _a = React__namespace.useState(initialState), state = _a[0], setState = _a[1];
    var setRafState = React__namespace.useCallback(function (value) {
        cancelAnimationFrame(rafRef.current);
        rafRef.current = requestAnimationFrame(function () {
            isMounted.current && setState(value);
        });
    }, []);
    React__namespace.useEffect(function () {
        return function () {
            cancelAnimationFrame(rafRef.current);
        };
    }, []);
    return [state, setRafState];
};

var ZERO_OFFSET$1 = {
    left: 0,
    top: 0,
};
var SCROLL_EVENT_OPTIONS = {
    capture: false,
    passive: true,
};
var useScroll = function (_a) {
    var elementRef = _a.elementRef, isRtl = _a.isRtl, scrollMode = _a.scrollMode;
    var _b = useRafState(ZERO_OFFSET$1), scrollOffset = _b[0], setScrollOffset = _b[1];
    var _c = React__namespace.useState(elementRef.current), element = _c[0], setElement = _c[1];
    var factor = isRtl ? -1 : 1;
    var latestRef = React__namespace.useRef(scrollMode);
    latestRef.current = scrollMode;
    useIsomorphicLayoutEffect(function () {
        setElement(elementRef.current);
    });
    useIsomorphicLayoutEffect(function () {
        if (!element) {
            return;
        }
        var handleScroll = function () {
            switch (latestRef.current) {
                case exports.ScrollMode.Horizontal:
                    setScrollOffset({
                        left: factor * element.scrollLeft,
                        top: 0,
                    });
                    break;
                case exports.ScrollMode.Vertical:
                default:
                    setScrollOffset({
                        left: 0,
                        top: element.scrollTop,
                    });
                    break;
            }
        };
        element.addEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);
        return function () {
            element.removeEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);
        };
    }, [element]);
    var scrollTo = React__namespace.useCallback(function (offset) {
        var ele = elementRef.current;
        if (ele) {
            switch (latestRef.current) {
                case exports.ScrollMode.Horizontal:
                    ele.scrollLeft = factor * offset.left;
                    break;
                case exports.ScrollMode.Vertical:
                default:
                    ele.scrollTop = offset.top;
                    break;
            }
        }
    }, [elementRef]);
    return {
        scrollOffset: scrollOffset,
        scrollTo: scrollTo,
    };
};

var clamp = function (min, max, value) { return Math.max(min, Math.min(value, max)); };

var findNearest = function (low, high, value, getItemValue) {
    while (low <= high) {
        var middle = ((low + high) / 2) | 0;
        var currentValue = getItemValue(middle);
        if (currentValue < value) {
            low = middle + 1;
        }
        else if (currentValue > value) {
            high = middle - 1;
        }
        else {
            return middle;
        }
    }
    return low > 0 ? low - 1 : 0;
};

var ZERO_RECT = {
    height: 0,
    width: 0,
};
var ZERO_OFFSET = {
    left: 0,
    top: 0,
};
var calculateRange = function (scrollMode, measurements, outerSize, scrollOffset) {
    var currentOffset = 0;
    switch (scrollMode) {
        case exports.ScrollMode.Horizontal:
            currentOffset = scrollOffset.left;
            break;
        case exports.ScrollMode.Vertical:
        default:
            currentOffset = scrollOffset.top;
            break;
    }
    var size = measurements.length - 1;
    var getOffset = function (index) {
        switch (scrollMode) {
            case exports.ScrollMode.Horizontal:
                return measurements[index].start.left;
            case exports.ScrollMode.Wrapped:
            case exports.ScrollMode.Vertical:
            default:
                return measurements[index].start.top;
        }
    };
    var start = findNearest(0, size, currentOffset, getOffset);
    if (scrollMode === exports.ScrollMode.Wrapped) {
        var startTop = measurements[start].start.top;
        while (start - 1 >= 0 &&
            measurements[start - 1].start.top === startTop &&
            measurements[start - 1].start.left >= scrollOffset.left) {
            start--;
        }
    }
    var end = start;
    var visibilities = {};
    var maxVisbilityIndex = start;
    var maxVisbility = -1;
    while (end <= size) {
        var itemRect = measurements[end].size;
        var visibility = {
            width: 0,
            height: 0,
        };
        var topLeftCorner = {
            top: measurements[end].start.top - scrollOffset.top,
            left: measurements[end].start.left - scrollOffset.left,
        };
        var visibleSize = {
            height: outerSize.height - topLeftCorner.top,
            width: outerSize.width - topLeftCorner.left,
        };
        if (scrollMode === exports.ScrollMode.Horizontal && visibleSize.width < 0) {
            end--;
            break;
        }
        if (scrollMode === exports.ScrollMode.Vertical && visibleSize.height < 0) {
            end--;
            break;
        }
        if (scrollMode === exports.ScrollMode.Wrapped && (visibleSize.width < 0 || visibleSize.height < 0)) {
            end--;
            break;
        }
        if (scrollMode === exports.ScrollMode.Vertical) {
            visibility.width = 1;
        }
        else if (topLeftCorner.left < 0) {
            var visibleWidth = itemRect.width - -topLeftCorner.left;
            visibility.width = visibleWidth <= outerSize.width ? visibleWidth / outerSize.width : 1;
        }
        else {
            visibility.width = itemRect.width <= visibleSize.width ? 1 : visibleSize.width / itemRect.width;
        }
        if (scrollMode === exports.ScrollMode.Horizontal) {
            visibility.height = 1;
        }
        else if (topLeftCorner.top < 0) {
            var visibleHeight = itemRect.height - -topLeftCorner.top;
            visibility.height = visibleHeight <= outerSize.height ? visibleHeight / outerSize.height : 1;
        }
        else {
            visibility.height = itemRect.height <= visibleSize.height ? 1 : visibleSize.height / itemRect.height;
        }
        visibilities[end] = visibility.width * visibility.height;
        if (maxVisbility < visibilities[end]) {
            maxVisbility = visibilities[end];
            maxVisbilityIndex = end;
        }
        end++;
    }
    return {
        start: start,
        end: end,
        maxVisbilityIndex: maxVisbilityIndex,
        visibilities: visibilities,
    };
};
var useVirtual = function (_a) {
    var estimateSize = _a.estimateSize, isRtl = _a.isRtl, numberOfItems = _a.numberOfItems, setStartRange = _a.setStartRange, setEndRange = _a.setEndRange, parentRef = _a.parentRef, scrollMode = _a.scrollMode;
    var _b = useScroll({
        elementRef: parentRef,
        isRtl: isRtl,
        scrollMode: scrollMode,
    }), scrollOffset = _b.scrollOffset, scrollTo = _b.scrollTo;
    var parentRect = useMeasureRect({
        elementRef: parentRef,
    });
    var latestRef = React__namespace.useRef({
        scrollOffset: ZERO_OFFSET,
        measurements: [],
        parentRect: ZERO_RECT,
        totalSize: ZERO_RECT,
    });
    latestRef.current.scrollOffset = scrollOffset;
    latestRef.current.parentRect = parentRect;
    var measurements = React__namespace.useMemo(function () {
        var measurements = [];
        var totalWidth = 0;
        var firstOfRow = {
            height: 0,
            left: 0,
            top: 0,
        };
        for (var i = 0; i < numberOfItems; i++) {
            var size = estimateSize(i);
            var start_1 = ZERO_OFFSET;
            if (i === 0) {
                totalWidth = size.width;
                firstOfRow = {
                    height: size.height,
                    left: 0,
                    top: 0,
                };
            }
            else {
                switch (scrollMode) {
                    case exports.ScrollMode.Wrapped:
                        totalWidth += size.width;
                        if (totalWidth < parentRect.width) {
                            start_1 = {
                                left: measurements[i - 1].end.left,
                                top: firstOfRow.top,
                            };
                        }
                        else {
                            totalWidth = size.width;
                            start_1 = {
                                left: firstOfRow.left,
                                top: firstOfRow.top + firstOfRow.height,
                            };
                            firstOfRow = {
                                height: size.height,
                                left: start_1.left,
                                top: start_1.top,
                            };
                        }
                        break;
                    case exports.ScrollMode.Horizontal:
                    case exports.ScrollMode.Vertical:
                    default:
                        start_1 = measurements[i - 1].end;
                        break;
                }
            }
            var end_1 = {
                left: start_1.left + size.width,
                top: start_1.top + size.height,
            };
            measurements[i] = {
                index: i,
                start: start_1,
                size: size,
                end: end_1,
                visibility: -1,
            };
        }
        return measurements;
    }, [estimateSize, scrollMode, parentRect]);
    var totalSize = measurements[numberOfItems - 1]
        ? {
            height: measurements[numberOfItems - 1].end.top,
            width: measurements[numberOfItems - 1].end.left,
        }
        : ZERO_RECT;
    latestRef.current.measurements = measurements;
    latestRef.current.totalSize = totalSize;
    var _c = calculateRange(scrollMode, latestRef.current.measurements, latestRef.current.parentRect, latestRef.current.scrollOffset), maxVisbilityIndex = _c.maxVisbilityIndex, visibilities = _c.visibilities, start = _c.start, end = _c.end;
    var startRange = setStartRange(start);
    var endRange = setEndRange(end);
    var virtualItems = [];
    for (var i = startRange; i <= endRange; i++) {
        virtualItems.push(__assign(__assign({}, measurements[i]), { visibility: visibilities[i] !== undefined ? visibilities[i] : -1 }));
    }
    var scrollToItem = React__namespace.useCallback(function (index, offset) {
        var measurements = latestRef.current.measurements;
        var measurement = measurements[clamp(0, numberOfItems - 1, index)];
        if (measurement) {
            scrollTo({
                left: offset.left + measurement.start.left,
                top: offset.top + measurement.start.top,
            });
        }
    }, [scrollTo]);
    var getContainerStyles = React__namespace.useCallback(function () {
        switch (scrollMode) {
            case exports.ScrollMode.Horizontal:
                return {
                    position: 'relative',
                    height: '100%',
                    width: "".concat(totalSize.width, "px"),
                };
            case exports.ScrollMode.Vertical:
            default:
                return {
                    position: 'relative',
                    height: "".concat(totalSize.height, "px"),
                    width: '100%',
                };
        }
    }, [scrollMode, totalSize]);
    var getItemStyles = React__namespace.useCallback(function (item) {
        var _a, _b, _c;
        var sideProperty = isRtl ? 'right' : 'left';
        var factor = isRtl ? -1 : 1;
        switch (scrollMode) {
            case exports.ScrollMode.Horizontal:
                return _a = {
                        height: '100%',
                        width: "".concat(item.size.width, "px")
                    },
                    _a[sideProperty] = 0,
                    _a.position = 'absolute',
                    _a.top = 0,
                    _a.transform = "translateX(".concat(item.start.left * factor, "px)"),
                    _a;
            case exports.ScrollMode.Wrapped:
                return _b = {
                        height: "".concat(item.size.height, "px"),
                        width: "".concat(item.size.width, "px")
                    },
                    _b[sideProperty] = 0,
                    _b.position = 'absolute',
                    _b.top = 0,
                    _b.transform = "translate(".concat(item.start.left * factor, "px, ").concat(item.start.top, "px)"),
                    _b;
            case exports.ScrollMode.Vertical:
            default:
                return _c = {
                        height: "".concat(item.size.height, "px"),
                        width: '100%'
                    },
                    _c[sideProperty] = 0,
                    _c.position = 'absolute',
                    _c.top = 0,
                    _c.transform = "translateY(".concat(item.start.top, "px)"),
                    _c;
        }
    }, [isRtl, scrollMode]);
    return {
        startIndex: start,
        startRange: startRange,
        endIndex: end,
        endRange: endRange,
        maxVisbilityIndex: maxVisbilityIndex,
        getContainerStyles: getContainerStyles,
        getItemStyles: getItemStyles,
        scrollToItem: scrollToItem,
        virtualItems: virtualItems,
    };
};

var AnnotationBorderStyleType;
(function (AnnotationBorderStyleType) {
    AnnotationBorderStyleType[AnnotationBorderStyleType["Solid"] = 1] = "Solid";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Dashed"] = 2] = "Dashed";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Beveled"] = 3] = "Beveled";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Inset"] = 4] = "Inset";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Underline"] = 5] = "Underline";
})(AnnotationBorderStyleType || (AnnotationBorderStyleType = {}));

var dateRegex = new RegExp('^D:' +
    '(\\d{4})' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '([Z|+|-])?' +
    '(\\d{2})?' +
    "'?" +
    '(\\d{2})?' +
    "'?");
var parse = function (value, min, max, defaultValue) {
    var parsed = parseInt(value, 10);
    return parsed >= min && parsed <= max ? parsed : defaultValue;
};
var convertDate = function (input) {
    var matches = dateRegex.exec(input);
    if (!matches) {
        return null;
    }
    var year = parseInt(matches[1], 10);
    var month = parse(matches[2], 1, 12, 1) - 1;
    var day = parse(matches[3], 1, 31, 1);
    var hour = parse(matches[4], 0, 23, 0);
    var minute = parse(matches[5], 0, 59, 0);
    var second = parse(matches[6], 0, 59, 0);
    var universalTimeRelation = matches[7] || 'Z';
    var offsetHour = parse(matches[8], 0, 23, 0);
    var offsetMinute = parse(matches[9], 0, 59, 0);
    switch (universalTimeRelation) {
        case '-':
            hour += offsetHour;
            minute += offsetMinute;
            break;
        case '+':
            hour -= offsetHour;
            minute -= offsetMinute;
            break;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
};

var PopupWrapper = function (_a) {
    var annotation = _a.annotation;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var containerRef = React__namespace.useRef();
    var dateStr = '';
    if (annotation.modificationDate) {
        var date = convertDate(annotation.modificationDate);
        dateStr = date ? "".concat(date.toLocaleDateString(), ", ").concat(date.toLocaleTimeString()) : '';
    }
    React__namespace.useLayoutEffect(function () {
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        var annotationEle = document.querySelector("[data-annotation-id=\"".concat(annotation.id, "\"]"));
        if (!annotationEle) {
            return;
        }
        var ele = annotationEle;
        ele.style.zIndex += 1;
        return function () {
            ele.style.zIndex = "".concat(parseInt(ele.style.zIndex, 10) - 1);
        };
    }, []);
    return (React__namespace.createElement("div", { ref: containerRef, className: classNames({
            'rpv-core__annotation-popup-wrapper': true,
            'rpv-core__annotation-popup-wrapper--rtl': isRtl,
        }), style: {
            top: annotation.annotationType === exports.AnnotationType.Popup ? '' : '100%',
        } },
        annotation.title && (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement("div", { className: classNames({
                    'rpv-core__annotation-popup-title': true,
                    'rpv-core__annotation-popup-title--ltr': !isRtl,
                    'rpv-core__annotation-popup-title--rtl': isRtl,
                }) }, annotation.title),
            React__namespace.createElement("div", { className: "rpv-core__annotation-popup-date" }, dateStr))),
        annotation.contents && (React__namespace.createElement("div", { className: "rpv-core__annotation-popup-content" }, annotation.contents.split('\n').map(function (item, index) { return (React__namespace.createElement(React__namespace.Fragment, { key: index },
            item,
            React__namespace.createElement("br", null))); })))));
};

var TogglePopupBy;
(function (TogglePopupBy) {
    TogglePopupBy["Click"] = "Click";
    TogglePopupBy["Hover"] = "Hover";
})(TogglePopupBy || (TogglePopupBy = {}));
var useTogglePopup = function () {
    var _a = useToggle(false), opened = _a.opened, toggle = _a.toggle;
    var _b = React__namespace.useState(TogglePopupBy.Hover), togglePopupBy = _b[0], setTooglePopupBy = _b[1];
    var toggleOnClick = function () {
        switch (togglePopupBy) {
            case TogglePopupBy.Click:
                opened && setTooglePopupBy(TogglePopupBy.Hover);
                toggle(exports.ToggleStatus.Toggle);
                break;
            case TogglePopupBy.Hover:
                setTooglePopupBy(TogglePopupBy.Click);
                toggle(exports.ToggleStatus.Open);
                break;
        }
    };
    var openOnHover = function () {
        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Open);
    };
    var closeOnHover = function () {
        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Close);
    };
    return {
        opened: opened,
        closeOnHover: closeOnHover,
        openOnHover: openOnHover,
        toggleOnClick: toggleOnClick,
    };
};

var Annotation = function (_a) {
    var annotation = _a.annotation, children = _a.children, ignoreBorder = _a.ignoreBorder, hasPopup = _a.hasPopup, isRenderable = _a.isRenderable, page = _a.page, viewport = _a.viewport;
    var rect = annotation.rect;
    var _b = useTogglePopup(), closeOnHover = _b.closeOnHover, opened = _b.opened, openOnHover = _b.openOnHover, toggleOnClick = _b.toggleOnClick;
    var normalizeRect = function (r) { return [
        Math.min(r[0], r[2]),
        Math.min(r[1], r[3]),
        Math.max(r[0], r[2]),
        Math.max(r[1], r[3]),
    ]; };
    var bound = normalizeRect([
        rect[0],
        page.view[3] + page.view[1] - rect[1],
        rect[2],
        page.view[3] + page.view[1] - rect[3],
    ]);
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var styles = {
        borderColor: '',
        borderRadius: '',
        borderStyle: '',
        borderWidth: '',
    };
    if (!ignoreBorder && annotation.borderStyle.width > 0) {
        switch (annotation.borderStyle.style) {
            case AnnotationBorderStyleType.Dashed:
                styles.borderStyle = 'dashed';
                break;
            case AnnotationBorderStyleType.Solid:
                styles.borderStyle = 'solid';
                break;
            case AnnotationBorderStyleType.Underline:
                styles = Object.assign({
                    borderBottomStyle: 'solid',
                }, styles);
                break;
            case AnnotationBorderStyleType.Beveled:
            case AnnotationBorderStyleType.Inset:
        }
        var borderWidth = annotation.borderStyle.width;
        styles.borderWidth = "".concat(borderWidth, "px");
        if (annotation.borderStyle.style !== AnnotationBorderStyleType.Underline) {
            width = width - 2 * borderWidth;
            height = height - 2 * borderWidth;
        }
        var _c = annotation.borderStyle, horizontalCornerRadius = _c.horizontalCornerRadius, verticalCornerRadius = _c.verticalCornerRadius;
        if (horizontalCornerRadius > 0 || verticalCornerRadius > 0) {
            styles.borderRadius = "".concat(horizontalCornerRadius, "px / ").concat(verticalCornerRadius, "px");
        }
        annotation.color
            ? (styles.borderColor = "rgb(".concat(annotation.color[0] | 0, ", ").concat(annotation.color[1] | 0, ", ").concat(annotation.color[2] | 0, ")"))
            :
                (styles.borderWidth = '0');
    }
    return (React__namespace.createElement(React__namespace.Fragment, null, isRenderable &&
        children({
            popup: {
                opened: opened,
                closeOnHover: closeOnHover,
                openOnHover: openOnHover,
                toggleOnClick: toggleOnClick,
            },
            slot: {
                attrs: {
                    style: Object.assign({
                        height: "".concat(height, "px"),
                        left: "".concat(bound[0], "px"),
                        top: "".concat(bound[1], "px"),
                        transform: "matrix(".concat(viewport.transform.join(','), ")"),
                        transformOrigin: "-".concat(bound[0], "px -").concat(bound[1], "px"),
                        width: "".concat(width, "px"),
                    }, styles),
                },
                children: React__namespace.createElement(React__namespace.Fragment, null, hasPopup && opened && React__namespace.createElement(PopupWrapper, { annotation: annotation })),
            },
        })));
};

var Caret = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--caret", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var Circle = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--circle", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        React__namespace.createElement("svg", { height: "".concat(height, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(width, " ").concat(height), width: "".concat(width, "px") },
            React__namespace.createElement("circle", { cy: height / 2, fill: "none", rx: width / 2 - borderWidth / 2, ry: height / 2 - borderWidth / 2, stroke: "transparent", strokeWidth: borderWidth || 1 })),
        props.slot.children)); }));
};

var getFileName = function (url) {
    var str = url.split('/').pop();
    return str ? str.split('#')[0].split('?')[0] : url;
};

var downloadFile = function (url, data) {
    var blobUrl = typeof data === 'string' ? '' : URL.createObjectURL(new Blob([data], { type: '' }));
    var link = document.createElement('a');
    link.style.display = 'none';
    link.href = blobUrl || url;
    link.setAttribute('download', getFileName(url));
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    if (blobUrl) {
        URL.revokeObjectURL(blobUrl);
    }
};

var FileAttachment = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false && (!!annotation.title || !!annotation.contents);
    var doubleClick = function () {
        var file = annotation.file;
        file && downloadFile(file.filename, file.content);
    };
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: true, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--file-attachment", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onDoubleClick: doubleClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var FreeText = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--free-text", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var Popup = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var isRenderable = !!(annotation.title || annotation.contents);
    var ignoredParents = ['Circle', 'Ink', 'Line', 'Polygon', 'PolyLine', 'Square'];
    var hasPopup = !annotation.parentType || ignoredParents.indexOf(annotation.parentType) !== -1;
    useIsomorphicLayoutEffect(function () {
        if (!annotation.parentId) {
            return;
        }
        var parent = document.querySelector("[data-annotation-id=\"".concat(annotation.parentId, "\"]"));
        var container = document.querySelector("[data-annotation-id=\"".concat(annotation.id, "\"]"));
        if (!parent || !container) {
            return;
        }
        var left = parseFloat(parent.style.left);
        var top = parseFloat(parent.style.top) + parseFloat(parent.style.height);
        container.style.left = "".concat(left, "px");
        container.style.top = "".concat(top, "px");
        container.style.transformOrigin = "-".concat(left, "px -").concat(top, "px");
    }, []);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--popup", "data-annotation-id": annotation.id }),
        React__namespace.createElement(PopupWrapper, { annotation: annotation }))); }));
};

var Highlight = function (_a) {
    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var hasQuadPoints = annotation.quadPoints && annotation.quadPoints.length > 0;
    if (hasQuadPoints) {
        var annotations = annotation.quadPoints.map(function (quadPoint) {
            return Object.assign({}, annotation, {
                rect: [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y],
                quadPoints: [],
            });
        });
        return (React__namespace.createElement(React__namespace.Fragment, null, annotations.map(function (ann, index) { return (React__namespace.createElement(Highlight, { key: index, annotation: ann, childAnnotation: childAnnotation, page: page, viewport: viewport })); })));
    }
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--highlight", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children),
        childAnnotation &&
            childAnnotation.annotationType === exports.AnnotationType.Popup &&
            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));
};

var Ink = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--ink", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        annotation.inkLists && annotation.inkLists.length && (React__namespace.createElement("svg", { height: "".concat(height, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(width, " ").concat(height), width: "".concat(width, "px") }, annotation.inkLists.map(function (inkList, index) { return (React__namespace.createElement("polyline", { key: index, fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, points: inkList.map(function (item) { return "".concat(item.x - rect[0], ",").concat(rect[3] - item.y); }).join(' ') })); }))),
        props.slot.children)); }));
};

var Line = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--line", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        React__namespace.createElement("svg", { height: "".concat(height, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(width, " ").concat(height), width: "".concat(width, "px") },
            React__namespace.createElement("line", { stroke: "transparent", strokeWidth: borderWidth || 1, x1: rect[2] - annotation.lineCoordinates[0], x2: rect[2] - annotation.lineCoordinates[2], y1: rect[3] - annotation.lineCoordinates[1], y2: rect[3] - annotation.lineCoordinates[3] })),
        props.slot.children)); }));
};

var normalizeDestination = function (pageIndex, destArray) {
    switch (destArray[1].name) {
        case 'XYZ':
            return {
                bottomOffset: destArray[3],
                leftOffset: destArray[2] || 0,
                pageIndex: pageIndex,
                scaleTo: destArray[4],
            };
        case 'Fit':
        case 'FitB':
            return {
                bottomOffset: 0,
                leftOffset: 0,
                pageIndex: pageIndex,
                scaleTo: exports.SpecialZoomLevel.PageFit,
            };
        case 'FitH':
        case 'FitBH':
            return {
                bottomOffset: destArray[2],
                leftOffset: 0,
                pageIndex: pageIndex,
                scaleTo: exports.SpecialZoomLevel.PageWidth,
            };
        default:
            return {
                bottomOffset: 0,
                leftOffset: 0,
                pageIndex: pageIndex,
                scaleTo: 1,
            };
    }
};
var pageOutlinesMap = new Map();
var pagesMap = new Map();
var generateRefKey = function (doc, outline) {
    return "".concat(doc.loadingTask.docId, "___").concat(outline.num, "R").concat(outline.gen === 0 ? '' : outline.gen);
};
var getPageIndex = function (doc, outline) {
    return pageOutlinesMap.get(generateRefKey(doc, outline)) || null;
};
var cacheOutlineRef = function (doc, outline, pageIndex) {
    pageOutlinesMap.set(generateRefKey(doc, outline), pageIndex);
};
var clearPagesCache = function () {
    pageOutlinesMap.clear();
    pagesMap.clear();
};
var getPage = function (doc, pageIndex) {
    if (!doc) {
        return Promise.reject('The document is not loaded yet');
    }
    var pageKey = "".concat(doc.loadingTask.docId, "___").concat(pageIndex);
    var page = pagesMap.get(pageKey);
    if (page) {
        return Promise.resolve(page);
    }
    return new Promise(function (resolve, _) {
        doc.getPage(pageIndex + 1).then(function (page) {
            pagesMap.set(pageKey, page);
            if (page.ref) {
                cacheOutlineRef(doc, page.ref, pageIndex);
            }
            resolve(page);
        });
    });
};
var getDestination = function (doc, dest) {
    return new Promise(function (res) {
        new Promise(function (resolve) {
            if (typeof dest === 'string') {
                doc.getDestination(dest).then(function (destArray) {
                    resolve(destArray);
                });
            }
            else {
                resolve(dest);
            }
        }).then(function (destArray) {
            if ('object' === typeof destArray[0] && destArray[0] !== null) {
                var outlineRef_1 = destArray[0];
                var pageIndex = getPageIndex(doc, outlineRef_1);
                if (pageIndex === null) {
                    doc.getPageIndex(outlineRef_1).then(function (pageIndex) {
                        cacheOutlineRef(doc, outlineRef_1, pageIndex);
                        getDestination(doc, dest).then(function (result) { return res(result); });
                    });
                }
                else {
                    res(normalizeDestination(pageIndex, destArray));
                }
            }
            else {
                var target = normalizeDestination(destArray[0], destArray);
                res(target);
            }
        });
    });
};

var Link = function (_a) {
    var annotation = _a.annotation, doc = _a.doc, page = _a.page, viewport = _a.viewport, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest;
    var link = function (e) {
        e.preventDefault();
        annotation.action
            ? onExecuteNamedAction(annotation.action)
            : getDestination(doc, annotation.dest).then(function (target) {
                var pageIndex = target.pageIndex, bottomOffset = target.bottomOffset, leftOffset = target.leftOffset, scaleTo = target.scaleTo;
                onJumpToDest(pageIndex, bottomOffset, leftOffset, scaleTo);
            });
    };
    var isRenderable = !!(annotation.url || annotation.dest || annotation.action);
    var attrs = annotation.url
        ? {
            href: annotation.url,
            rel: 'noopener noreferrer nofollow',
            target: annotation.newWindow ? '_blank' : '',
            title: annotation.url,
        }
        : {
            href: '',
            'data-annotation-link-dest': annotation.dest,
            onClick: link,
        };
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: false, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--link", "data-annotation-id": annotation.id }),
        React__namespace.createElement("a", __assign({}, attrs)))); }));
};

var Polygon = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polygon", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        annotation.vertices && annotation.vertices.length && (React__namespace.createElement("svg", { height: "".concat(height, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(width, " ").concat(height), width: "".concat(width, "px") },
            React__namespace.createElement("polygon", { fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, points: annotation.vertices
                    .map(function (item) { return "".concat(item.x - rect[0], ",").concat(rect[3] - item.y); })
                    .join(' ') }))),
        props.slot.children)); }));
};

var Polyline = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polyline", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        annotation.vertices && annotation.vertices.length && (React__namespace.createElement("svg", { height: "".concat(height, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(width, " ").concat(height), width: "".concat(width, "px") },
            React__namespace.createElement("polyline", { fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, points: annotation.vertices
                    .map(function (item) { return "".concat(item.x - rect[0], ",").concat(rect[3] - item.y); })
                    .join(' ') }))),
        props.slot.children)); }));
};

var Square = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--square", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        React__namespace.createElement("svg", { height: "".concat(height, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(width, " ").concat(height), width: "".concat(width, "px") },
            React__namespace.createElement("rect", { height: height - borderWidth, fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, x: borderWidth / 2, y: borderWidth / 2, width: width - borderWidth })),
        props.slot.children)); }));
};

var Squiggly = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--squiggly", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var Stamp = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--stamp", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var StrikeOut = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--strike-out", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var CommentIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z" }),
    React__namespace.createElement("path", { d: "M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25" }),
    React__namespace.createElement("path", { d: "M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75" }),
    React__namespace.createElement("path", { d: "M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25" }))); };

var HelpIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z" }),
    React__namespace.createElement("path", { d: "M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z" }),
    React__namespace.createElement("path", { d: "M21.423 5.406L17.415 9.414" }),
    React__namespace.createElement("path", { d: "M14.587 6.585L18.607 2.565" }),
    React__namespace.createElement("path", { d: "M5.405 21.424L9.413 17.416" }),
    React__namespace.createElement("path", { d: "M6.585 14.588L2.577 18.596" }),
    React__namespace.createElement("path", { d: "M18.602 21.419L14.595 17.412" }),
    React__namespace.createElement("path", { d: "M17.419 14.58L21.428 18.589" }),
    React__namespace.createElement("path", { d: "M2.582 5.399L6.588 9.406" }),
    React__namespace.createElement("path", { d: "M9.421 6.581L5.412 2.572" }))); };

var KeyIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z" }),
    React__namespace.createElement("path", { d: "M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z" }))); };

var NoteIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z" }),
    React__namespace.createElement("path", { d: "M6 4.5L6 0.5" }),
    React__namespace.createElement("path", { d: "M18 4.5L18 0.5" }),
    React__namespace.createElement("path", { d: "M10 4.5L10 0.5" }),
    React__namespace.createElement("path", { d: "M14 4.5L14 0.5" }))); };

var ParagraphIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M17.5 0.498L17.5 23.498" }),
    React__namespace.createElement("path", { d: "M10.5 0.498L10.5 23.498" }),
    React__namespace.createElement("path", { d: "M23.5.5H6.5a6,6,0,0,0,0,12h4" }))); };

var TriangleIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z" }))); };

var Text = function (_a) {
    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var name = annotation.name ? annotation.name.toLowerCase() : '';
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--text", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
            name && (React__namespace.createElement("div", { className: "rpv-core__annotation-text-icon" },
                name === 'check' && React__namespace.createElement(CheckIcon, null),
                name === 'comment' && React__namespace.createElement(CommentIcon, null),
                name === 'help' && React__namespace.createElement(HelpIcon, null),
                name === 'insert' && React__namespace.createElement(TriangleIcon, null),
                name === 'key' && React__namespace.createElement(KeyIcon, null),
                name === 'note' && React__namespace.createElement(NoteIcon, null),
                (name === 'newparagraph' || name === 'paragraph') && React__namespace.createElement(ParagraphIcon, null))),
            props.slot.children),
        childAnnotation &&
            childAnnotation.annotationType === exports.AnnotationType.Popup &&
            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));
};

var Underline = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--underline", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var AnnotationLayerBody = function (_a) {
    var annotations = _a.annotations, containerRef = _a.containerRef, doc = _a.doc, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest;
    var viewport = page.getViewport({ rotation: rotation, scale: scale });
    var clonedViewPort = viewport.clone({ dontFlip: true });
    var filterAnnotations = annotations.filter(function (annotation) { return !annotation.parentId; });
    React__namespace.useEffect(function () {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        plugins.forEach(function (plugin) {
            if (plugin.onAnnotationLayerRender) {
                plugin.onAnnotationLayerRender({
                    annotations: filterAnnotations,
                    container: container,
                    pageIndex: pageIndex,
                    rotation: rotation,
                    scale: scale,
                });
            }
        });
    }, []);
    return (React__namespace.createElement(React__namespace.Fragment, null, filterAnnotations.map(function (annotation) {
        var childAnnotation = annotations.find(function (item) { return item.parentId === annotation.id; });
        switch (annotation.annotationType) {
            case exports.AnnotationType.Caret:
                return (React__namespace.createElement(Caret, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Circle:
                return (React__namespace.createElement(Circle, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.FileAttachment:
                return (React__namespace.createElement(FileAttachment, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.FreeText:
                return (React__namespace.createElement(FreeText, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Highlight:
                return (React__namespace.createElement(Highlight, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Ink:
                return (React__namespace.createElement(Ink, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Line:
                return (React__namespace.createElement(Line, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Link:
                return (React__namespace.createElement(Link, { key: annotation.id, annotation: annotation, doc: doc, page: page, viewport: clonedViewPort, onExecuteNamedAction: onExecuteNamedAction, onJumpToDest: onJumpToDest }));
            case exports.AnnotationType.Polygon:
                return (React__namespace.createElement(Polygon, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Polyline:
                return (React__namespace.createElement(Polyline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Popup:
                return (React__namespace.createElement(Popup, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Square:
                return (React__namespace.createElement(Square, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Squiggly:
                return (React__namespace.createElement(Squiggly, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Stamp:
                return (React__namespace.createElement(Stamp, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.StrikeOut:
                return (React__namespace.createElement(StrikeOut, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Text:
                return (React__namespace.createElement(Text, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Underline:
                return (React__namespace.createElement(Underline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            default:
                return React__namespace.createElement(React__namespace.Fragment, { key: annotation.id });
        }
    })));
};

var AnnotationLoader = function (_a) {
    var page = _a.page, renderAnnotations = _a.renderAnnotations;
    var isMounted = useIsMounted();
    var _b = React__namespace.useState({
        loading: true,
        annotations: [],
    }), status = _b[0], setStatus = _b[1];
    React__namespace.useEffect(function () {
        page.getAnnotations({ intent: 'display' }).then(function (result) {
            if (isMounted.current) {
                setStatus({
                    loading: false,
                    annotations: result,
                });
            }
        });
    }, []);
    return status.loading ? React__namespace.createElement(React__namespace.Fragment, null) : renderAnnotations(status.annotations);
};

var AnnotationLayer = function (_a) {
    var doc = _a.doc, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest;
    var containerRef = React__namespace.useRef();
    var renderAnnotations = function (annotations) {
        return (React__namespace.createElement(AnnotationLayerBody, { annotations: annotations, containerRef: containerRef, doc: doc, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotation, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpToDest: onJumpToDest }));
    };
    return (React__namespace.createElement("div", { ref: containerRef, className: "rpv-core__annotation-layer" },
        React__namespace.createElement(AnnotationLoader, { page: page, renderAnnotations: renderAnnotations })));
};

var floatToRatio = function (x, limit) {
    var _a, _b;
    if (Math.floor(x) === x) {
        return [x, 1];
    }
    var y = 1 / x;
    if (y > limit) {
        return [1, limit];
    }
    if (Math.floor(y) === y) {
        return [1, y];
    }
    var value = x > 1 ? y : x;
    var a = 0;
    var b = 1;
    var c = 1;
    var d = 1;
    while (true) {
        var numerator = a + c;
        var denominator = b + d;
        if (denominator > limit) {
            break;
        }
        value <= numerator / denominator ? (_a = [numerator, denominator], c = _a[0], d = _a[1], _a) : (_b = [numerator, denominator], a = _b[0], b = _b[1], _b);
    }
    var middle = (a / b + c / d) / 2;
    return value < middle ? (value === x ? [a, b] : [b, a]) : value === x ? [c, d] : [d, c];
};

var roundToDivide = function (a, b) {
    var remainder = a % b;
    return remainder === 0 ? a : Math.floor(a - remainder);
};

var MAX_CANVAS_SIZE = 4096 * 4096;
var CanvasLayer = function (_a) {
    var height = _a.height, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, width = _a.width, onRenderCanvasCompleted = _a.onRenderCanvasCompleted;
    useIsMounted();
    var canvasRef = React__namespace.useRef();
    var renderTask = React__namespace.useRef();
    useIsomorphicLayoutEffect(function () {
        var task = renderTask.current;
        if (task) {
            task.cancel();
        }
        var canvasEle = canvasRef.current;
        plugins.forEach(function (plugin) {
            if (plugin.onCanvasLayerRender) {
                plugin.onCanvasLayerRender({
                    ele: canvasEle,
                    pageIndex: pageIndex,
                    rotation: rotation,
                    scale: scale,
                    status: exports.LayerRenderStatus.PreRender,
                });
            }
        });
        var viewport = page.getViewport({
            rotation: rotation,
            scale: scale,
        });
        var outputScale = window.devicePixelRatio || 1;
        var maxScale = Math.sqrt(MAX_CANVAS_SIZE / (viewport.width * viewport.height));
        var shouldScaleByCSS = outputScale > maxScale;
        shouldScaleByCSS ? (canvasEle.style.transform = "scale(1, 1)") : canvasEle.style.removeProperty('transform');
        var possibleScale = Math.min(maxScale, outputScale);
        var _a = floatToRatio(possibleScale, 8), x = _a[0], y = _a[1];
        canvasEle.width = roundToDivide(viewport.width * possibleScale, x);
        canvasEle.height = roundToDivide(viewport.height * possibleScale, x);
        canvasEle.style.width = "".concat(roundToDivide(viewport.width, y), "px");
        canvasEle.style.height = "".concat(roundToDivide(viewport.height, y), "px");
        canvasEle.style.opacity = '0';
        var canvasContext = canvasEle.getContext('2d', { alpha: false });
        var transform = shouldScaleByCSS || outputScale !== 1 ? [possibleScale, 0, 0, possibleScale, 0, 0] : null;
        renderTask.current = page.render({ canvasContext: canvasContext, transform: transform, viewport: viewport });
        renderTask.current.promise.then(function () {
            canvasEle.style.removeProperty('opacity');
            plugins.forEach(function (plugin) {
                if (plugin.onCanvasLayerRender) {
                    plugin.onCanvasLayerRender({
                        ele: canvasEle,
                        pageIndex: pageIndex,
                        rotation: rotation,
                        scale: scale,
                        status: exports.LayerRenderStatus.DidRender,
                    });
                }
            });
            onRenderCanvasCompleted();
        }, function () {
            onRenderCanvasCompleted();
        });
        return function () {
            var _a;
            (_a = renderTask.current) === null || _a === void 0 ? void 0 : _a.cancel();
            if (canvasEle) {
                canvasEle.width = 0;
                canvasEle.height = 0;
            }
        };
    }, []);
    return (React__namespace.createElement("div", { className: "rpv-core__canvas-layer", style: {
            height: "".concat(height, "px"),
            width: "".concat(width, "px"),
        } },
        React__namespace.createElement("canvas", { ref: canvasRef, style: { opacity: 0 } })));
};

var SvgLayer = function (_a) {
    var height = _a.height, page = _a.page, rotation = _a.rotation, scale = _a.scale, width = _a.width;
    var containerRef = React__namespace.useRef();
    var empty = function () {
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        containerEle.innerHTML = '';
    };
    useIsomorphicLayoutEffect(function () {
        var containerEle = containerRef.current;
        var viewport = page.getViewport({ rotation: rotation, scale: scale });
        page.getOperatorList().then(function (operatorList) {
            empty();
            var graphic = new PdfJsApi__namespace.SVGGraphics(page.commonObjs, page.objs);
            graphic.getSVG(operatorList, viewport).then(function (svg) {
                svg.style.height = "".concat(height, "px");
                svg.style.width = "".concat(width, "px");
                containerEle.appendChild(svg);
            });
        });
    }, []);
    return React__namespace.createElement("div", { className: "rpv-core__svg-layer", ref: containerRef });
};

var TextLayer = function (_a) {
    var page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onRenderTextCompleted = _a.onRenderTextCompleted;
    var containerRef = React__namespace.useRef();
    var renderTask = React__namespace.useRef();
    var empty = function () {
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        var spans = [].slice.call(containerEle.querySelectorAll('span.rpv-core__text-layer-text'));
        spans.forEach(function (span) { return containerEle.removeChild(span); });
        var breaks = [].slice.call(containerEle.querySelectorAll('br[role="presentation"]'));
        breaks.forEach(function (br) { return containerEle.removeChild(br); });
    };
    useIsomorphicLayoutEffect(function () {
        var task = renderTask.current;
        if (task) {
            task.cancel();
        }
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        containerEle.removeAttribute('data-testid');
        var viewport = page.getViewport({ rotation: rotation, scale: scale });
        plugins.forEach(function (plugin) {
            if (plugin.onTextLayerRender) {
                plugin.onTextLayerRender({
                    ele: containerEle,
                    pageIndex: pageIndex,
                    scale: scale,
                    status: exports.LayerRenderStatus.PreRender,
                });
            }
        });
        page.getTextContent().then(function (textContent) {
            empty();
            renderTask.current = PdfJsApi__namespace.renderTextLayer({
                container: containerEle,
                textContent: textContent,
                viewport: viewport,
                enhanceTextSelection: true,
            });
            renderTask.current.promise.then(function () {
                containerEle.setAttribute('data-testid', "core__text-layer-".concat(pageIndex));
                var spans = [].slice.call(containerEle.children);
                spans.forEach(function (span) { return span.classList.add('rpv-core__text-layer-text'); });
                plugins.forEach(function (plugin) {
                    if (plugin.onTextLayerRender) {
                        plugin.onTextLayerRender({
                            ele: containerEle,
                            pageIndex: pageIndex,
                            scale: scale,
                            status: exports.LayerRenderStatus.DidRender,
                        });
                    }
                });
                onRenderTextCompleted();
            }, function () {
                containerEle.removeAttribute('data-testid');
                onRenderTextCompleted();
            });
        });
        return function () {
            var _a;
            (_a = renderTask.current) === null || _a === void 0 ? void 0 : _a.cancel();
        };
    }, []);
    return React__namespace.createElement("div", { className: "rpv-core__text-layer", ref: containerRef });
};

var PageLayer = function (_a) {
    var doc = _a.doc, height = _a.height, pageIndex = _a.pageIndex, plugins = _a.plugins, renderPage = _a.renderPage, rotation = _a.rotation, scale = _a.scale, shouldRender = _a.shouldRender, width = _a.width, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest, onRenderCompleted = _a.onRenderCompleted;
    var isMounted = useIsMounted();
    var _b = React__namespace.useState({
        page: null,
        pageHeight: height,
        pageWidth: width,
        viewportRotation: 0,
    }), pageSize = _b[0], setPageSize = _b[1];
    var _c = React__namespace.useState(false), canvasLayerRendered = _c[0], setCanvasLayerRendered = _c[1];
    var _d = React__namespace.useState(false), textLayerRendered = _d[0], setTextLayerRendered = _d[1];
    var page = pageSize.page, pageHeight = pageSize.pageHeight, pageWidth = pageSize.pageWidth;
    var scaledWidth = pageWidth * scale;
    var scaledHeight = pageHeight * scale;
    var isVertical = Math.abs(rotation) % 180 === 0;
    var w = isVertical ? scaledWidth : scaledHeight;
    var h = isVertical ? scaledHeight : scaledWidth;
    var determinePageSize = function () {
        getPage(doc, pageIndex).then(function (pdfPage) {
            var viewport = pdfPage.getViewport({ scale: 1 });
            isMounted.current &&
                setPageSize({
                    page: pdfPage,
                    pageHeight: viewport.height,
                    pageWidth: viewport.width,
                    viewportRotation: viewport.rotation,
                });
        });
    };
    var defaultPageRenderer = function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,
        props.canvasLayer.children,
        props.textLayer.children,
        props.annotationLayer.children)); };
    var renderPageLayer = renderPage || defaultPageRenderer;
    var rotationNumber = (rotation + pageSize.viewportRotation) % 360;
    var handleRenderCanvasCompleted = function () {
        if (isMounted.current) {
            setCanvasLayerRendered(true);
        }
    };
    var handleRenderTextCompleted = function () {
        if (isMounted.current) {
            setTextLayerRendered(true);
        }
    };
    React__namespace.useEffect(function () {
        setPageSize({
            page: null,
            pageHeight: height,
            pageWidth: width,
            viewportRotation: 0,
        });
        setCanvasLayerRendered(false);
        setTextLayerRendered(false);
    }, [rotation, scale]);
    React__namespace.useEffect(function () {
        if (shouldRender && isMounted.current && !page) {
            determinePageSize();
        }
    }, [shouldRender, page]);
    React__namespace.useEffect(function () {
        if (canvasLayerRendered && textLayerRendered) {
            onRenderCompleted(pageIndex);
        }
    }, [canvasLayerRendered, textLayerRendered]);
    return (React__namespace.createElement("div", { className: "rpv-core__page-layer", "data-testid": "core__page-layer-".concat(pageIndex), style: {
            height: "".concat(h, "px"),
            width: "".concat(w, "px"),
        } }, !page ? (React__namespace.createElement(Spinner, { testId: "core__page-layer-loading-".concat(pageIndex) })) : (React__namespace.createElement(React__namespace.Fragment, null,
        renderPageLayer({
            annotationLayer: {
                attrs: {},
                children: (React__namespace.createElement(AnnotationLayer, { doc: doc, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationNumber, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpToDest: onJumpToDest })),
            },
            canvasLayer: {
                attrs: {},
                children: (React__namespace.createElement(CanvasLayer, { height: h, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationNumber, scale: scale, width: w, onRenderCanvasCompleted: handleRenderCanvasCompleted })),
            },
            canvasLayerRendered: canvasLayerRendered,
            doc: doc,
            height: h,
            pageIndex: pageIndex,
            rotation: rotation,
            scale: scale,
            svgLayer: {
                attrs: {},
                children: (React__namespace.createElement(SvgLayer, { height: h, page: page, rotation: rotationNumber, scale: scale, width: w })),
            },
            textLayer: {
                attrs: {},
                children: (React__namespace.createElement(TextLayer, { page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationNumber, scale: scale, onRenderTextCompleted: handleRenderTextCompleted })),
            },
            textLayerRendered: textLayerRendered,
            width: w,
            markRendered: onRenderCompleted,
        }),
        plugins.map(function (plugin, idx) {
            return plugin.renderPageLayer ? (React__namespace.createElement(React__namespace.Fragment, { key: idx }, plugin.renderPageLayer({
                doc: doc,
                height: h,
                pageIndex: pageIndex,
                rotation: rotation,
                scale: scale,
                width: w,
            }))) : (React__namespace.createElement(React__namespace.Fragment, { key: idx }));
        })))));
};

var getFileExt = function (url) {
    var str = url.split(/\./).pop();
    return str ? str.toLowerCase() : '';
};

var SCROLL_BAR_WIDTH = 17;
var PAGE_PADDING$1 = 8;
var calculateScale = function (container, pageHeight, pageWidth, scale) {
    switch (scale) {
        case exports.SpecialZoomLevel.ActualSize:
            return 1;
        case exports.SpecialZoomLevel.PageFit:
            return Math.min((container.clientWidth - SCROLL_BAR_WIDTH) / pageWidth, (container.clientHeight - 2 * PAGE_PADDING$1) / pageHeight);
        case exports.SpecialZoomLevel.PageWidth:
            return (container.clientWidth - SCROLL_BAR_WIDTH) / pageWidth;
    }
};

var NUM_OVERSCAN_PAGES = 3;
var PAGE_PADDING = 16;
var Inner = function (_a) {
    var currentFile = _a.currentFile, defaultScale = _a.defaultScale, doc = _a.doc, initialPage = _a.initialPage, pageSize = _a.pageSize, plugins = _a.plugins, renderPage = _a.renderPage, scrollMode = _a.scrollMode, viewerState = _a.viewerState, onDocumentLoad = _a.onDocumentLoad, onOpenFile = _a.onOpenFile, onPageChange = _a.onPageChange, onZoom = _a.onZoom;
    var numPages = doc.numPages;
    var docId = doc.loadingTask.docId;
    var l10n = React__namespace.useContext(LocalizationContext).l10n;
    var themeContext = React__namespace.useContext(ThemeContext);
    var isRtl = themeContext.direction === exports.TextDirection.RightToLeft;
    var containerRef = React__namespace.useRef();
    var pagesRef = React__namespace.useRef();
    var _b = React__namespace.useState(0), currentPage = _b[0], setCurrentPage = _b[1];
    var _c = React__namespace.useState(0), rotation = _c[0], setRotation = _c[1];
    var _d = React__namespace.useState(scrollMode), currentScrollMode = _d[0], setCurrentScrollMode = _d[1];
    var stateRef = React__namespace.useRef(viewerState);
    var _e = React__namespace.useState(pageSize.scale), scale = _e[0], setScale = _e[1];
    var keepSpecialZoomLevelRef = React__namespace.useRef(typeof defaultScale === 'string' ? defaultScale : null);
    var _f = React__namespace.useState(-1), renderPageIndex = _f[0], setRenderPageIndex = _f[1];
    var renderQueueInstance = React__namespace.useMemo(function () { return renderQueueService({ doc: doc, queueName: 'core-pages', priority: 0 }); }, [docId]);
    var estimateSize = React__namespace.useCallback(function () {
        var sizes = [pageSize.pageHeight, pageSize.pageWidth];
        var rect = Math.abs(rotation) % 180 === 0
            ? {
                height: sizes[0],
                width: sizes[1],
            }
            : {
                height: sizes[1],
                width: sizes[0],
            };
        return {
            height: rect.height * scale + PAGE_PADDING,
            width: rect.width * scale + PAGE_PADDING,
        };
    }, [rotation, scale]);
    var setStartRange = React__namespace.useCallback(function (startIndex) { return Math.max(startIndex - NUM_OVERSCAN_PAGES, 0); }, []);
    var setEndRange = React__namespace.useCallback(function (endIndex) { return Math.min(endIndex + NUM_OVERSCAN_PAGES, numPages - 1); }, [numPages]);
    var virtualizer = useVirtual({
        estimateSize: estimateSize,
        isRtl: isRtl,
        numberOfItems: numPages,
        parentRef: pagesRef,
        scrollMode: currentScrollMode,
        setStartRange: setStartRange,
        setEndRange: setEndRange,
    });
    var handlePagesResize = function (target) {
        if (keepSpecialZoomLevelRef.current) {
            zoom(keepSpecialZoomLevelRef.current);
        }
    };
    useTrackResize({
        targetRef: pagesRef,
        onResize: handlePagesResize,
    });
    var pageWidth = pageSize.pageWidth, pageHeight = pageSize.pageHeight;
    var setViewerState = function (viewerState) {
        var newState = viewerState;
        plugins.forEach(function (plugin) {
            if (plugin.onViewerStateChange) {
                newState = plugin.onViewerStateChange(newState);
            }
        });
        stateRef.current = newState;
    };
    var getPagesContainer = function () { return pagesRef.current; };
    var getViewerState = function () { return stateRef.current; };
    var jumpToDestination = React__namespace.useCallback(function (pageIndex, bottomOffset, leftOffset, scaleTo) {
        var pagesContainer = pagesRef.current;
        var currentState = stateRef.current;
        if (!pagesContainer || !currentState) {
            return;
        }
        getPage(doc, pageIndex).then(function (page) {
            var viewport = page.getViewport({ scale: 1 });
            var top = 0;
            var bottom = (typeof bottomOffset === 'function'
                ? bottomOffset(viewport.width, viewport.height)
                : bottomOffset) || 0;
            var left = (typeof leftOffset === 'function' ? leftOffset(viewport.width, viewport.height) : leftOffset) || 0;
            var updateScale = currentState.scale;
            switch (scaleTo) {
                case exports.SpecialZoomLevel.PageFit:
                    top = 0;
                    left = 0;
                    zoom(exports.SpecialZoomLevel.PageFit);
                    break;
                case exports.SpecialZoomLevel.PageWidth:
                    updateScale = calculateScale(pagesContainer, pageHeight, pageWidth, exports.SpecialZoomLevel.PageWidth);
                    top = (viewport.height - bottom) * updateScale;
                    left = left * updateScale;
                    zoom(updateScale);
                    break;
                default:
                    var boundingRect = viewport.convertToViewportPoint(left, bottom);
                    left = Math.max(boundingRect[0] * currentState.scale, 0);
                    top = Math.max(boundingRect[1] * currentState.scale, 0);
                    break;
            }
            switch (currentState.scrollMode) {
                case exports.ScrollMode.Horizontal:
                    virtualizer.scrollToItem(pageIndex, { left: left, top: 0 });
                    break;
                case exports.ScrollMode.Vertical:
                default:
                    virtualizer.scrollToItem(pageIndex, { left: 0, top: top });
                    break;
            }
        });
    }, []);
    var jumpToPage = React__namespace.useCallback(function (pageIndex) {
        if (0 <= pageIndex && pageIndex < numPages) {
            virtualizer.scrollToItem(pageIndex, { left: 0, top: 0 });
        }
    }, []);
    var openFile = React__namespace.useCallback(function (file) {
        if (getFileExt(file.name).toLowerCase() !== 'pdf') {
            return;
        }
        new Promise(function (resolve) {
            var reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = function () {
                var bytes = new Uint8Array(reader.result);
                resolve(bytes);
            };
        }).then(function (data) {
            onOpenFile(file.name, data);
        });
    }, [onOpenFile]);
    var rotate = React__namespace.useCallback(function (updateRotation) {
        renderQueueInstance.resetQueue();
        setRotation(updateRotation);
        setViewerState({
            file: viewerState.file,
            pageIndex: currentPage,
            pageHeight: pageHeight,
            pageWidth: pageWidth,
            rotation: updateRotation,
            scale: scale,
            scrollMode: currentScrollMode,
        });
    }, []);
    var switchScrollMode = React__namespace.useCallback(function (scrollMode) {
        setViewerState({
            file: viewerState.file,
            pageIndex: stateRef.current.pageIndex,
            pageHeight: pageHeight,
            pageWidth: pageWidth,
            rotation: rotation,
            scale: scale,
            scrollMode: scrollMode,
        });
        setCurrentScrollMode(scrollMode);
    }, []);
    var zoom = React__namespace.useCallback(function (newScale) {
        renderQueueInstance.resetQueue();
        var pagesEle = pagesRef.current;
        var updateScale = pagesEle
            ? typeof newScale === 'string'
                ? calculateScale(pagesEle, pageHeight, pageWidth, newScale)
                : newScale
            : 1;
        keepSpecialZoomLevelRef.current = typeof newScale === 'string' ? newScale : null;
        pagesEle.scrollTop = (pagesEle.scrollTop * updateScale) / stateRef.current.scale;
        pagesEle.scrollLeft = (pagesEle.scrollLeft * updateScale) / stateRef.current.scale;
        setScale(updateScale);
        onZoom({ doc: doc, scale: updateScale });
        setViewerState({
            file: viewerState.file,
            pageIndex: currentPage,
            pageHeight: pageHeight,
            pageWidth: pageWidth,
            rotation: rotation,
            scale: updateScale,
            scrollMode: currentScrollMode,
        });
    }, []);
    React__namespace.useEffect(function () {
        var latestPage = stateRef.current.pageIndex;
        if (latestPage > -1) {
            virtualizer.scrollToItem(latestPage, { left: 0, top: 0 });
        }
    }, [currentScrollMode]);
    React__namespace.useEffect(function () {
        var startRange = virtualizer.startRange, endRange = virtualizer.endRange, maxVisbilityIndex = virtualizer.maxVisbilityIndex, virtualItems = virtualizer.virtualItems;
        var currentPage = maxVisbilityIndex;
        setCurrentPage(currentPage);
        if (stateRef.current.pageIndex !== currentPage) {
            onPageChange({ currentPage: currentPage, doc: doc });
        }
        setViewerState({
            file: viewerState.file,
            pageIndex: currentPage,
            pageHeight: pageHeight,
            pageWidth: pageWidth,
            rotation: rotation,
            scale: scale,
            scrollMode: currentScrollMode,
        });
        renderQueueInstance.setRange(startRange, endRange);
        var _loop_1 = function (i) {
            var item = virtualItems.find(function (item) { return item.index === i; });
            if (item) {
                renderQueueInstance.setVisibility(i, item.visibility);
            }
        };
        for (var i = startRange; i <= endRange; i++) {
            _loop_1(i);
        }
        renderNextPage();
    }, [virtualizer.startRange, virtualizer.endRange, virtualizer.maxVisbilityIndex, rotation, scale]);
    React__namespace.useEffect(function () {
        var pluginMethods = {
            getPagesContainer: getPagesContainer,
            getViewerState: getViewerState,
            jumpToDestination: jumpToDestination,
            jumpToPage: jumpToPage,
            openFile: openFile,
            rotate: rotate,
            setViewerState: setViewerState,
            switchScrollMode: switchScrollMode,
            zoom: zoom,
        };
        plugins.forEach(function (plugin) {
            if (plugin.install) {
                plugin.install(pluginMethods);
            }
        });
        return function () {
            plugins.forEach(function (plugin) {
                if (plugin.uninstall) {
                    plugin.uninstall(pluginMethods);
                }
            });
        };
    }, [docId]);
    React__namespace.useEffect(function () {
        onDocumentLoad({ doc: doc, file: currentFile });
        plugins.forEach(function (plugin) {
            plugin.onDocumentLoad && plugin.onDocumentLoad({ doc: doc, file: currentFile });
        });
        if (initialPage) {
            jumpToPage(initialPage);
        }
    }, [docId]);
    var handlePageRenderCompleted = React__namespace.useCallback(function (pageIndex) {
        renderQueueInstance.markRendered(pageIndex);
        renderNextPage();
    }, []);
    var renderNextPage = function () {
        var nextPage = renderQueueInstance.getHighestPriorityPage();
        if (nextPage > -1) {
            renderQueueInstance.markRendering(nextPage);
            setRenderPageIndex(nextPage);
        }
    };
    var executeNamedAction = function (action) {
        var previousPage = currentPage - 1;
        var nextPage = currentPage + 1;
        switch (action) {
            case 'FirstPage':
                jumpToPage(0);
                break;
            case 'LastPage':
                jumpToPage(numPages - 1);
                break;
            case 'NextPage':
                nextPage < numPages && jumpToPage(nextPage);
                break;
            case 'PrevPage':
                previousPage >= 0 && jumpToPage(previousPage);
                break;
        }
    };
    var renderViewer = React__namespace.useCallback(function () {
        var pageLabel = (l10n && l10n.core ? l10n.core.pageLabel : 'Page {{pageIndex}}');
        var slot = {
            attrs: {
                'data-testid': 'core__inner-container',
                ref: containerRef,
                style: {
                    height: '100%',
                },
            },
            children: React__namespace.createElement(React__namespace.Fragment, null),
            subSlot: {
                attrs: {
                    'data-testid': 'core__inner-pages',
                    className: classNames({
                        'rpv-core__inner-pages': true,
                        'rpv-core__inner-pages--horizontal': currentScrollMode === exports.ScrollMode.Horizontal,
                        'rpv-core__inner-pages--rtl': isRtl,
                        'rpv-core__inner-pages--vertical': currentScrollMode === exports.ScrollMode.Vertical,
                        'rpv-core__inner-pages--wrapped': currentScrollMode === exports.ScrollMode.Wrapped,
                    }),
                    ref: pagesRef,
                    style: {
                        height: '100%',
                        overflow: 'auto',
                        position: 'relative',
                    },
                },
                children: (React__namespace.createElement("div", { style: virtualizer.getContainerStyles() }, virtualizer.virtualItems.map(function (item) { return (React__namespace.createElement("div", { "aria-label": pageLabel.replace('{{pageIndex}}', "".concat(item.index + 1)), className: "rpv-core__inner-page", key: item.index, role: "region", style: virtualizer.getItemStyles(item) },
                    React__namespace.createElement(PageLayer, { doc: doc, height: pageHeight, pageIndex: item.index, plugins: plugins, renderPage: renderPage, rotation: rotation, scale: scale, shouldRender: renderPageIndex === item.index, width: pageWidth, onExecuteNamedAction: executeNamedAction, onJumpToDest: jumpToDestination, onRenderCompleted: handlePageRenderCompleted }))); }))),
            },
        };
        plugins.forEach(function (plugin) {
            if (plugin.renderViewer) {
                slot = plugin.renderViewer({
                    containerRef: containerRef,
                    doc: doc,
                    pageHeight: pageHeight,
                    pageWidth: pageWidth,
                    rotation: rotation,
                    slot: slot,
                    themeContext: themeContext,
                    jumpToPage: jumpToPage,
                    openFile: openFile,
                    rotate: rotate,
                    switchScrollMode: switchScrollMode,
                    zoom: zoom,
                });
            }
        });
        return slot;
    }, [plugins, virtualizer]);
    var renderSlot = React__namespace.useCallback(function (slot) { return (React__namespace.createElement("div", __assign({}, slot.attrs, { style: slot.attrs && slot.attrs.style ? slot.attrs.style : {} }),
        slot.children,
        slot.subSlot && renderSlot(slot.subSlot))); }, []);
    React__namespace.useEffect(function () {
        return function () {
            renderQueueInstance.cleanup();
            clearPagesCache();
        };
    }, []);
    return renderSlot(renderViewer());
};

var LEVELS = [
    0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9, 2.1, 2.4, 2.7, 3.0, 3.3, 3.7, 4.1, 4.6,
    5.1, 5.7, 6.3, 7.0, 7.7, 8.5, 9.4, 10,
];
var decrease = function (currentLevel) {
    var found = LEVELS.findIndex(function (item) { return item >= currentLevel; });
    return found === -1 || found === 0 ? currentLevel : LEVELS[found - 1];
};

var RESERVE_HEIGHT = 45;
var RESERVE_WIDTH = 45;
var PageSizeCalculator = function (_a) {
    var defaultScale = _a.defaultScale, doc = _a.doc, render = _a.render, scrollMode = _a.scrollMode;
    var pagesRef = React__namespace.useRef();
    var _b = React__namespace.useState({
        pageHeight: 0,
        pageWidth: 0,
        scale: 1,
    }), pageSize = _b[0], setPageSize = _b[1];
    React__namespace.useLayoutEffect(function () {
        getPage(doc, 0).then(function (pdfPage) {
            var viewport = pdfPage.getViewport({ scale: 1 });
            var w = viewport.width;
            var h = viewport.height;
            var pagesEle = pagesRef.current;
            if (!pagesEle) {
                return;
            }
            var parentEle = pagesEle.parentElement;
            var scaleWidth = (parentEle.clientWidth - RESERVE_WIDTH) / w;
            var scaleHeight = (parentEle.clientHeight - RESERVE_HEIGHT) / h;
            var scaled = scaleWidth;
            switch (scrollMode) {
                case exports.ScrollMode.Horizontal:
                    scaled = Math.min(scaleWidth, scaleHeight);
                    break;
                case exports.ScrollMode.Vertical:
                default:
                    scaled = scaleWidth;
                    break;
            }
            var scale = defaultScale
                ? typeof defaultScale === 'string'
                    ? calculateScale(parentEle, h, w, defaultScale)
                    : defaultScale
                : decrease(scaled);
            setPageSize({
                pageHeight: h,
                pageWidth: w,
                scale: scale,
            });
        });
    }, [doc]);
    var pageWidth = pageSize.pageWidth;
    return pageWidth === 0 ? (React__namespace.createElement("div", { className: "rpv-core__page-size-calculator", ref: pagesRef },
        React__namespace.createElement(Spinner, null))) : (render(pageSize));
};

var LoadingStatus = (function () {
    function LoadingStatus() {
    }
    return LoadingStatus;
}());

var SubmitPassword;
(function (SubmitPassword) {
    SubmitPassword[SubmitPassword["REQUIRE_PASSWORD"] = 0] = "REQUIRE_PASSWORD";
    SubmitPassword[SubmitPassword["WRONG_PASSWORD"] = 1] = "WRONG_PASSWORD";
})(SubmitPassword || (SubmitPassword = {}));
var AskForPasswordState = (function (_super) {
    __extends(AskForPasswordState, _super);
    function AskForPasswordState(verifyPassword, submitPassword) {
        var _this = _super.call(this) || this;
        _this.verifyPassword = verifyPassword;
        _this.submitPassword = submitPassword;
        return _this;
    }
    return AskForPasswordState;
}(LoadingStatus));

var AskingPassword = function (_a) {
    var submitPassword = _a.submitPassword, verifyPassword = _a.verifyPassword, onDocumentAskPassword = _a.onDocumentAskPassword;
    var l10n = React__namespace.useContext(LocalizationContext).l10n;
    var _b = React__namespace.useState(''), password = _b[0], setPassword = _b[1];
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var submit = function () { return verifyPassword(password); };
    var handleKeyDown = function (e) {
        if (e.key === 'Enter') {
            submit();
        }
    };
    React__namespace.useEffect(function () {
        if (onDocumentAskPassword) {
            onDocumentAskPassword({
                verifyPassword: verifyPassword,
            });
        }
    }, []);
    return (React__namespace.createElement("div", { className: "rpv-core__asking-password-wrapper" },
        React__namespace.createElement("div", { className: classNames({
                'rpv-core__asking-password': true,
                'rpv-core__asking-password--rtl': isRtl,
            }) },
            React__namespace.createElement("div", { className: "rpv-core__asking-password-message" },
                submitPassword === SubmitPassword.REQUIRE_PASSWORD &&
                    l10n.core.askingPassword.requirePasswordToOpen,
                submitPassword === SubmitPassword.WRONG_PASSWORD && l10n.core.wrongPassword.tryAgain),
            React__namespace.createElement("div", { className: "rpv-core__asking-password-body" },
                React__namespace.createElement("div", { className: classNames({
                        'rpv-core__asking-password-input': true,
                        'rpv-core__asking-password-input--ltr': !isRtl,
                        'rpv-core__asking-password-input--rtl': isRtl,
                    }) },
                    React__namespace.createElement(TextBox, { testId: "core__asking-password-input", type: "password", value: password, onChange: setPassword, onKeyDown: handleKeyDown })),
                React__namespace.createElement(PrimaryButton, { onClick: submit }, l10n.core.askingPassword.submit)))));
};

var CompletedState = (function (_super) {
    __extends(CompletedState, _super);
    function CompletedState(doc) {
        var _this = _super.call(this) || this;
        _this.doc = doc;
        return _this;
    }
    return CompletedState;
}(LoadingStatus));

var FailureState = (function (_super) {
    __extends(FailureState, _super);
    function FailureState(error) {
        var _this = _super.call(this) || this;
        _this.error = error;
        return _this;
    }
    return FailureState;
}(LoadingStatus));

var LoadingState = (function (_super) {
    __extends(LoadingState, _super);
    function LoadingState(percentages) {
        var _this = _super.call(this) || this;
        _this.percentages = percentages;
        return _this;
    }
    return LoadingState;
}(LoadingStatus));

var DocumentLoader = function (_a) {
    var characterMap = _a.characterMap, file = _a.file, httpHeaders = _a.httpHeaders, render = _a.render, renderError = _a.renderError, renderLoader = _a.renderLoader, transformGetDocumentParams = _a.transformGetDocumentParams, withCredentials = _a.withCredentials, onDocumentAskPassword = _a.onDocumentAskPassword;
    var direction = React__namespace.useContext(ThemeContext).direction;
    var isRtl = direction === exports.TextDirection.RightToLeft;
    var _b = React__namespace.useState(new LoadingState(0)), status = _b[0], setStatus = _b[1];
    var _c = React__namespace.useState(0), percentages = _c[0], setPercentages = _c[1];
    var _d = React__namespace.useState(null), loadedDocument = _d[0], setLoadedDocument = _d[1];
    var isMounted = useIsMounted();
    React__namespace.useEffect(function () {
        setStatus(new LoadingState(0));
        var worker = new PdfJsApi__namespace.PDFWorker({ name: "PDFWorker_".concat(Date.now()) });
        var params = Object.assign({
            httpHeaders: httpHeaders,
            withCredentials: withCredentials,
            worker: worker,
        }, 'string' === typeof file ? { url: file } : { data: file }, characterMap
            ? {
                cMapUrl: characterMap.url,
                cMapPacked: characterMap.isCompressed,
            }
            : {});
        var transformParams = transformGetDocumentParams ? transformGetDocumentParams(params) : params;
        var loadingTask = PdfJsApi__namespace.getDocument(transformParams);
        loadingTask.onPassword = function (verifyPassword, reason) {
            switch (reason) {
                case PdfJsApi__namespace.PasswordResponses.NEED_PASSWORD:
                    isMounted.current &&
                        setStatus(new AskForPasswordState(verifyPassword, SubmitPassword.REQUIRE_PASSWORD));
                    break;
                case PdfJsApi__namespace.PasswordResponses.INCORRECT_PASSWORD:
                    isMounted.current &&
                        setStatus(new AskForPasswordState(verifyPassword, SubmitPassword.WRONG_PASSWORD));
                    break;
            }
        };
        loadingTask.onProgress = function (progress) {
            progress.total > 0
                ?
                    isMounted.current && setPercentages(Math.min(100, (100 * progress.loaded) / progress.total))
                : isMounted.current && setPercentages(100);
        };
        loadingTask.promise.then(function (doc) { return isMounted.current && setLoadedDocument(doc); }, function (err) {
            return isMounted.current &&
                !worker.destroyed &&
                setStatus(new FailureState({
                    message: err.message || 'Cannot load document',
                    name: err.name,
                }));
        });
        return function () {
            loadingTask.destroy();
            worker.destroy();
        };
    }, [file]);
    React__namespace.useEffect(function () {
        percentages === 100 && loadedDocument
            ? isMounted.current && setStatus(new CompletedState(loadedDocument))
            : isMounted.current && setStatus(new LoadingState(percentages));
    }, [percentages, loadedDocument]);
    if (status instanceof AskForPasswordState) {
        return (React__namespace.createElement(AskingPassword, { submitPassword: status.submitPassword, verifyPassword: status.verifyPassword, onDocumentAskPassword: onDocumentAskPassword }));
    }
    if (status instanceof CompletedState) {
        return render(status.doc);
    }
    if (status instanceof FailureState) {
        return renderError ? (renderError(status.error)) : (React__namespace.createElement("div", { className: classNames({
                'rpv-core__doc-error': true,
                'rpv-core__doc-error--rtl': isRtl,
            }) },
            React__namespace.createElement("div", { className: "rpv-core__doc-error-text" }, status.error.message)));
    }
    return (React__namespace.createElement("div", { "data-testid": "core__doc-loading", className: classNames({
            'rpv-core__doc-loading': true,
            'rpv-core__doc-loading--rtl': isRtl,
        }) }, renderLoader ? renderLoader(status.percentages) : React__namespace.createElement(Spinner, null)));
};

var isDarkMode = function () {
    return typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
};

var withTheme = function (theme, onSwitchTheme) {
    var initialTheme = React__namespace.useMemo(function () { return (theme === 'auto' ? (isDarkMode() ? 'dark' : 'light') : theme); }, []);
    var _a = React__namespace.useState(initialTheme), currentTheme = _a[0], setCurrentTheme = _a[1];
    var prevTheme = usePrevious(currentTheme);
    React__namespace.useEffect(function () {
        if (theme !== 'auto') {
            return;
        }
        var media = window.matchMedia('(prefers-color-scheme: dark)');
        var handler = function (e) {
            setCurrentTheme(e.matches ? 'dark' : 'light');
        };
        media.addEventListener('change', handler);
        return function () { return media.removeEventListener('change', handler); };
    }, []);
    React__namespace.useEffect(function () {
        if (currentTheme !== prevTheme && onSwitchTheme) {
            onSwitchTheme(currentTheme);
        }
    }, [currentTheme]);
    React__namespace.useEffect(function () {
        if (theme !== currentTheme) {
            setCurrentTheme(theme);
        }
    }, [theme]);
    return {
        currentTheme: currentTheme,
        setCurrentTheme: setCurrentTheme,
    };
};

var isSameUrl = function (a, b) {
    var typeA = typeof a;
    var typeB = typeof b;
    if (typeA === 'string' && typeB === 'string' && a === b) {
        return true;
    }
    if (typeA === 'object' && typeB === 'object') {
        return a.length === b.length && a.every(function (v, i) { return v === b[i]; });
    }
    return false;
};

var Viewer = function (_a) {
    var characterMap = _a.characterMap, defaultScale = _a.defaultScale, fileUrl = _a.fileUrl, _b = _a.httpHeaders, httpHeaders = _b === void 0 ? {} : _b, _c = _a.initialPage, initialPage = _c === void 0 ? 0 : _c, localization = _a.localization, _d = _a.plugins, plugins = _d === void 0 ? [] : _d, renderError = _a.renderError, renderPage = _a.renderPage, renderLoader = _a.renderLoader, _e = _a.scrollMode, scrollMode = _e === void 0 ? exports.ScrollMode.Vertical : _e, transformGetDocumentParams = _a.transformGetDocumentParams, _f = _a.theme, theme = _f === void 0 ? {
        direction: exports.TextDirection.LeftToRight,
        theme: 'light',
    } : _f, _g = _a.withCredentials, withCredentials = _g === void 0 ? false : _g, onDocumentAskPassword = _a.onDocumentAskPassword, _h = _a.onDocumentLoad, onDocumentLoad = _h === void 0 ? function () {
    } : _h, _j = _a.onPageChange, onPageChange = _j === void 0 ? function () {
    } : _j, _k = _a.onSwitchTheme, onSwitchTheme = _k === void 0 ? function () {
    } : _k, _l = _a.onZoom, onZoom = _l === void 0 ? function () {
    } : _l;
    var _m = React__namespace.useState({
        data: fileUrl,
        name: typeof fileUrl === 'string' ? fileUrl : '',
        shouldLoad: false,
    }), file = _m[0], setFile = _m[1];
    var openFile = function (fileName, data) {
        setFile({
            data: data,
            name: fileName,
            shouldLoad: true,
        });
    };
    var _o = React__namespace.useState(false), visible = _o[0], setVisible = _o[1];
    var prevFile = usePrevious(file);
    React__namespace.useEffect(function () {
        if (!isSameUrl(prevFile.data, fileUrl)) {
            setFile({
                data: fileUrl,
                name: typeof fileUrl === 'string' ? fileUrl : '',
                shouldLoad: visible,
            });
        }
    }, [fileUrl, visible]);
    var visibilityChanged = function (params) {
        setVisible(params.isVisible);
        if (params.isVisible) {
            setFile(function (currentFile) { return Object.assign({}, currentFile, { shouldLoad: true }); });
        }
    };
    var containerRef = useIntersectionObserver({
        onVisibilityChanged: visibilityChanged,
    });
    var themeProps = typeof theme === 'string' ? { direction: exports.TextDirection.LeftToRight, theme: theme } : theme;
    var _p = React__namespace.useState(localization || DefaultLocalization), l10n = _p[0], setL10n = _p[1];
    var localizationContext = { l10n: l10n, setL10n: setL10n };
    var themeContext = Object.assign({}, { direction: themeProps.direction }, withTheme(themeProps.theme || 'light', onSwitchTheme));
    React__namespace.useEffect(function () {
        if (localization) {
            setL10n(localization);
        }
    }, [localization]);
    return (React__namespace.createElement(LocalizationContext.Provider, { value: localizationContext },
        React__namespace.createElement(ThemeContext.Provider, { value: themeContext },
            React__namespace.createElement("div", { ref: containerRef, className: "rpv-core__viewer rpv-core__viewer--".concat(themeContext.currentTheme), "data-testid": "core__viewer", style: {
                    height: '100%',
                    width: '100%',
                } }, file.shouldLoad && (React__namespace.createElement(DocumentLoader, { characterMap: characterMap, file: file.data, httpHeaders: httpHeaders, render: function (doc) { return (React__namespace.createElement(PageSizeCalculator, { defaultScale: defaultScale, doc: doc, render: function (ps) { return (React__namespace.createElement(Inner, { currentFile: {
                            data: file.data,
                            name: file.name,
                        }, defaultScale: defaultScale, doc: doc, initialPage: initialPage, pageSize: ps, plugins: plugins, renderPage: renderPage, scrollMode: scrollMode, viewerState: {
                            file: file,
                            pageIndex: -1,
                            pageHeight: ps.pageHeight,
                            pageWidth: ps.pageWidth,
                            rotation: 0,
                            scale: ps.scale,
                            scrollMode: scrollMode,
                        }, onDocumentLoad: onDocumentLoad, onOpenFile: openFile, onPageChange: onPageChange, onZoom: onZoom })); }, scrollMode: scrollMode })); }, renderError: renderError, renderLoader: renderLoader, transformGetDocumentParams: transformGetDocumentParams, withCredentials: withCredentials, onDocumentAskPassword: onDocumentAskPassword }))))));
};

var Worker = function (_a) {
    var children = _a.children, workerUrl = _a.workerUrl;
    PdfJsApi__namespace.GlobalWorkerOptions.workerSrc = workerUrl;
    return React__namespace.createElement(React__namespace.Fragment, null, children);
};

var isMac = function () { return (typeof window !== 'undefined' ? /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) : false); };

exports.Button = Button;
exports.Icon = Icon;
exports.LazyRender = LazyRender;
exports.LocalizationContext = LocalizationContext;
exports.Menu = Menu;
exports.MenuDivider = MenuDivider;
exports.MenuItem = MenuItem;
exports.MinimalButton = MinimalButton;
exports.Modal = Modal;
exports.Popover = Popover;
exports.PrimaryButton = PrimaryButton;
exports.ProgressBar = ProgressBar;
exports.Separator = Separator;
exports.Spinner = Spinner;
exports.Splitter = Splitter;
exports.TextBox = TextBox;
exports.ThemeContext = ThemeContext;
exports.Tooltip = Tooltip;
exports.Viewer = Viewer;
exports.Worker = Worker;
exports.classNames = classNames;
exports.createStore = createStore;
exports.getDestination = getDestination;
exports.getPage = getPage;
exports.isMac = isMac;
exports.renderQueueService = renderQueueService;
exports.useIntersectionObserver = useIntersectionObserver;
exports.useIsMounted = useIsMounted;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
