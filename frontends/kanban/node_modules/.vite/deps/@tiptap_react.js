import {
  tippy_esm_default
} from "./chunk-QQZCBNLI.js";
import {
  CommandManager,
  Editor,
  Extension,
  InputRule,
  Mark,
  Node,
  NodeView,
  PasteRule,
  Tracker,
  callOrReturn,
  combineTransactionSteps,
  defaultBlockAt,
  escapeForRegEx,
  extensions,
  findChildren,
  findChildrenInRange,
  findParentNode,
  findParentNodeClosestToPos,
  generateHTML,
  generateJSON,
  generateText,
  getAttributes,
  getChangedRanges,
  getDebugJSON,
  getExtensionField,
  getHTMLFromFragment,
  getMarkAttributes,
  getMarkRange,
  getMarkType,
  getMarksBetween,
  getNodeAttributes,
  getNodeType,
  getSchema,
  getText,
  getTextBetween,
  getTextContentFromNodes,
  getTextSerializersFromSchema,
  inputRulesPlugin,
  isActive,
  isList,
  isMarkActive,
  isNodeActive,
  isNodeEmpty,
  isNodeSelection,
  isTextSelection,
  markInputRule,
  markPasteRule,
  mergeAttributes,
  nodeInputRule,
  nodePasteRule,
  pasteRulesPlugin,
  posToDOMRect,
  textInputRule,
  textPasteRule,
  textblockTypeInputRule,
  wrappingInputRule
} from "./chunk-NLKFJLJH.js";
import {
  Plugin,
  PluginKey
} from "./chunk-XB6JRJJM.js";
import {
  require_react_dom
} from "./chunk-QKYHKZPX.js";
import {
  require_react
} from "./chunk-KQJKTEOQ.js";
import {
  __toESM
} from "./chunk-4ACCWERV.js";

// node_modules/@tiptap/extension-bubble-menu/dist/tiptap-extension-bubble-menu.esm.js
var BubbleMenuView = class {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from, to }) => {
      const { doc, selection } = state;
      const { empty } = selection;
      const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty || isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a, _b, _c;
    const { state, composing } = view;
    const { doc, selection } = state;
    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);
    if (composing || isSame) {
      return;
    }
    this.createTooltip();
    const { ranges } = selection;
    const from = Math.min(...ranges.map((range) => range.$from.pos));
    const to = Math.max(...ranges.map((range) => range.$to.pos));
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state,
      oldState,
      from,
      to
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
        if (isNodeSelection(state.selection)) {
          const node = view.nodeDOM(from);
          if (node) {
            return node.getBoundingClientRect();
          }
        }
        return posToDOMRect(view, from, to);
      })
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// node_modules/@tiptap/react/dist/tiptap-react.esm.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@tiptap/extension-floating-menu/dist/tiptap-extension-floating-menu.esm.js
var FloatingMenuView = class {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state }) => {
      const { selection } = state;
      const { $anchor, empty } = selection;
      const isRootDepth = $anchor.depth === 1;
      const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;
      if (!view2.hasFocus() || !empty || !isRootDepth || !isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a, _b, _c;
    const { state } = view;
    const { doc, selection } = state;
    const { from, to } = selection;
    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state,
      oldState
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => posToDOMRect(view, from, to))
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var FloatingMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new FloatingMenuView({ view, ...options })
  });
};
var FloatingMenu = Extension.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      FloatingMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// node_modules/@tiptap/react/dist/tiptap-react.esm.js
var BubbleMenu2 = (props) => {
  const [element, setElement] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (!element) {
      return;
    }
    if (props.editor.isDestroyed) {
      return;
    }
    const { pluginKey = "bubbleMenu", editor, tippyOptions = {}, shouldShow = null } = props;
    const plugin = BubbleMenuPlugin({
      pluginKey,
      editor,
      element,
      tippyOptions,
      shouldShow
    });
    editor.registerPlugin(plugin);
    return () => editor.unregisterPlugin(pluginKey);
  }, [
    props.editor,
    element
  ]);
  return import_react.default.createElement("div", { ref: setElement, className: props.className, style: { visibility: "hidden" } }, props.children);
};
var Editor2 = class extends Editor {
  constructor() {
    super(...arguments);
    this.contentComponent = null;
  }
};
var Portals = ({ renderers }) => {
  return import_react.default.createElement(import_react.default.Fragment, null, Array.from(renderers).map(([key, renderer]) => {
    return import_react_dom.default.createPortal(renderer.reactElement, renderer.element, key);
  }));
};
var PureEditorContent = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.editorContentRef = import_react.default.createRef();
    this.state = {
      renderers: /* @__PURE__ */ new Map()
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const { editor } = this.props;
    if (editor && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = this;
      editor.createNodeViews();
    }
  }
  componentWillUnmount() {
    const { editor } = this.props;
    if (!editor) {
      return;
    }
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const { editor, ...rest } = this.props;
    return import_react.default.createElement(
      import_react.default.Fragment,
      null,
      import_react.default.createElement("div", { ref: this.editorContentRef, ...rest }),
      import_react.default.createElement(Portals, { renderers: this.state.renderers })
    );
  }
};
var EditorContent = import_react.default.memo(PureEditorContent);
var FloatingMenu2 = (props) => {
  const [element, setElement] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (!element) {
      return;
    }
    if (props.editor.isDestroyed) {
      return;
    }
    const { pluginKey = "floatingMenu", editor, tippyOptions = {}, shouldShow = null } = props;
    const plugin = FloatingMenuPlugin({
      pluginKey,
      editor,
      element,
      tippyOptions,
      shouldShow
    });
    editor.registerPlugin(plugin);
    return () => editor.unregisterPlugin(pluginKey);
  }, [
    props.editor,
    element
  ]);
  return import_react.default.createElement("div", { ref: setElement, className: props.className, style: { visibility: "hidden" } }, props.children);
};
var ReactNodeViewContext = (0, import_react.createContext)({
  onDragStart: void 0
});
var useReactNodeView = () => (0, import_react.useContext)(ReactNodeViewContext);
var NodeViewContent = (props) => {
  const Tag = props.as || "div";
  const { nodeViewContentRef } = useReactNodeView();
  return import_react.default.createElement(Tag, { ...props, ref: nodeViewContentRef, "data-node-view-content": "", style: {
    whiteSpace: "pre-wrap",
    ...props.style
  } });
};
var NodeViewWrapper = import_react.default.forwardRef((props, ref) => {
  const { onDragStart } = useReactNodeView();
  const Tag = props.as || "div";
  return import_react.default.createElement(Tag, { ...props, ref, "data-node-view-wrapper": "", onDragStart, style: {
    whiteSpace: "normal",
    ...props.style
  } });
});
function isClassComponent(Component) {
  return !!(typeof Component === "function" && Component.prototype && Component.prototype.isReactComponent);
}
function isForwardRefComponent(Component) {
  var _a;
  return !!(typeof Component === "object" && ((_a = Component.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === "Symbol(react.forward_ref)");
}
var ReactRenderer = class {
  constructor(component, { editor, props = {}, as = "div", className = "" }) {
    this.ref = null;
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.component = component;
    this.editor = editor;
    this.props = props;
    this.element = document.createElement(as);
    this.element.classList.add("react-renderer");
    if (className) {
      this.element.classList.add(...className.split(" "));
    }
    this.render();
  }
  render() {
    const Component = this.component;
    const props = this.props;
    if (isClassComponent(Component) || isForwardRefComponent(Component)) {
      props.ref = (ref) => {
        this.ref = ref;
      };
    }
    this.reactElement = import_react.default.createElement(Component, { ...props });
    (0, import_react_dom.flushSync)(() => {
      var _a;
      if ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) {
        this.editor.contentComponent.setState({
          renderers: this.editor.contentComponent.state.renderers.set(this.id, this)
        });
      }
    });
  }
  updateProps(props = {}) {
    this.props = {
      ...this.props,
      ...props
    };
    this.render();
  }
  destroy() {
    (0, import_react_dom.flushSync)(() => {
      var _a;
      if ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) {
        const { renderers } = this.editor.contentComponent.state;
        renderers.delete(this.id);
        this.editor.contentComponent.setState({
          renderers
        });
      }
    });
  }
};
var ReactNodeView = class extends NodeView {
  mount() {
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: false,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode()
    };
    if (!this.component.displayName) {
      const capitalizeFirstChar = (string) => {
        return string.charAt(0).toUpperCase() + string.substring(1);
      };
      this.component.displayName = capitalizeFirstChar(this.extension.name);
    }
    const ReactNodeViewProvider = (componentProps) => {
      const Component = this.component;
      const onDragStart = this.onDragStart.bind(this);
      const nodeViewContentRef = (element) => {
        if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {
          element.appendChild(this.contentDOMElement);
        }
      };
      return import_react.default.createElement(
        ReactNodeViewContext.Provider,
        { value: { onDragStart, nodeViewContentRef } },
        import_react.default.createElement(Component, { ...componentProps })
      );
    };
    ReactNodeViewProvider.displayName = "ReactNodeView";
    this.contentDOMElement = this.node.isLeaf ? null : document.createElement(this.node.isInline ? "span" : "div");
    if (this.contentDOMElement) {
      this.contentDOMElement.style.whiteSpace = "inherit";
    }
    let as = this.node.isInline ? "span" : "div";
    if (this.options.as) {
      as = this.options.as;
    }
    const { className = "" } = this.options;
    this.renderer = new ReactRenderer(ReactNodeViewProvider, {
      editor: this.editor,
      props,
      as,
      className: `node-${this.node.type.name} ${className}`.trim()
    });
  }
  get dom() {
    var _a;
    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute("data-node-view-wrapper"))) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.element;
  }
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    return this.contentDOMElement;
  }
  update(node, decorations) {
    const updateProps = (props) => {
      this.renderer.updateProps(props);
    };
    if (node.type !== this.node.type) {
      return false;
    }
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      this.node = node;
      this.decorations = decorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        updateProps: () => updateProps({ node, decorations })
      });
    }
    if (node === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    updateProps({ node, decorations });
    return true;
  }
  selectNode() {
    this.renderer.updateProps({
      selected: true
    });
  }
  deselectNode() {
    this.renderer.updateProps({
      selected: false
    });
  }
  destroy() {
    this.renderer.destroy();
    this.contentDOMElement = null;
  }
};
function ReactNodeViewRenderer(component, options) {
  return (props) => {
    if (!props.editor.contentComponent) {
      return {};
    }
    return new ReactNodeView(component, props, options);
  };
}
function useForceUpdate() {
  const [, setValue] = (0, import_react.useState)(0);
  return () => setValue((value) => value + 1);
}
var useEditor = (options = {}, deps = []) => {
  const [editor, setEditor] = (0, import_react.useState)(null);
  const forceUpdate = useForceUpdate();
  (0, import_react.useEffect)(() => {
    let isMounted = true;
    const instance = new Editor2(options);
    setEditor(instance);
    instance.on("transaction", () => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (isMounted) {
            forceUpdate();
          }
        });
      });
    });
    return () => {
      instance.destroy();
      isMounted = false;
    };
  }, deps);
  return editor;
};
export {
  BubbleMenu2 as BubbleMenu,
  CommandManager,
  Editor2 as Editor,
  EditorContent,
  Extension,
  FloatingMenu2 as FloatingMenu,
  InputRule,
  Mark,
  Node,
  NodeView,
  NodeViewContent,
  NodeViewWrapper,
  PasteRule,
  PureEditorContent,
  ReactNodeViewRenderer,
  ReactRenderer,
  Tracker,
  callOrReturn,
  combineTransactionSteps,
  defaultBlockAt,
  escapeForRegEx,
  extensions,
  findChildren,
  findChildrenInRange,
  findParentNode,
  findParentNodeClosestToPos,
  generateHTML,
  generateJSON,
  generateText,
  getAttributes,
  getChangedRanges,
  getDebugJSON,
  getExtensionField,
  getHTMLFromFragment,
  getMarkAttributes,
  getMarkRange,
  getMarkType,
  getMarksBetween,
  getNodeAttributes,
  getNodeType,
  getSchema,
  getText,
  getTextBetween,
  getTextContentFromNodes,
  getTextSerializersFromSchema,
  inputRulesPlugin,
  isActive,
  isList,
  isMarkActive,
  isNodeActive,
  isNodeEmpty,
  isNodeSelection,
  isTextSelection,
  markInputRule,
  markPasteRule,
  mergeAttributes,
  nodeInputRule,
  nodePasteRule,
  pasteRulesPlugin,
  posToDOMRect,
  textInputRule,
  textPasteRule,
  textblockTypeInputRule,
  useEditor,
  wrappingInputRule
};
//# sourceMappingURL=@tiptap_react.js.map
