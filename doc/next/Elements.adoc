= Elements
:step:

This chapter introduces various elements of Site.

You should read this chapter in order to gain an overview before diving into the
details and practical examples in subsequent chapters.

== Documents

(((XTDB)))
Data in Site is stored as documents in the https://xtdb.com[XTDB] database.

A document is a set of named values, as shown in <<ex-cat-document>>.

[[ex-cat-document]]
.A Document representing a cat
====
[source,clojure]
----
{:name "Arya"
 :species "Cat"
 :color "black"
 :favorite-activity "playing with string"}
----
====

Names are 'keywords', which identifiers prefixed with a colon (:).

Values can be strings, numbers, sets, collections, nested documents and more.

All documents in Site can contain any additional attributes you need.

== Entities

Before being stored in the database, each document is identified with an entity
id, indicated by the attribute `:xt/id`.

A document can be considered a particular _version_ of an entity at a given
point in time, as shown in <<ex-cat-entity>>.

[[ex-cat-entity]]
.A cat can change
====
[source,clojure]
----
{:xt/id "https://example.org/cats/arya"
 :name "Arya"
 :species "cat"
 :color "black"
 :favorite-activity "playing with string"}
----

and, at a later dateâ€¦

[source,clojure]
----
{:xt/id "https://example.org/cats/arya"
 :name "Arya"
 :species "cat"
 :color "black"
 :favorite-activity "hunting mice"}
----
====

TIP: For more information about Documents and Entities, see https://xtdb.com.

The `juxt.site`, `juxt.pass`, `juxt.http`, `xtdb.api` and `xt` namespaces are
reserved to avoid the potential for attribute clashes.

[TIP]
--
(((property graph)))
This flexibility to compose documents from different attributes is one of the
strengths of using a property-graph database such as XTDB under the hood.

((("Halloway, Stuart")))
See this talk segment by Stu Halloway to explain the rationale for using namespaces in attribute keywords:
https://youtu.be/Qx0-pViyIDU?t=1464
--

== Users

Users are individuals that have access to Site. Users might be permitted to
query, create, update and/or delete certain documents.

A User is stored in the database as a document. Since every system has its own
requirements about what data must be captured to represent a User, Site doesn't
prescribe what a User should be, and allows the document to contain any and all
details that might be necessary footnote:[in fact, this is true for all
documents in Site].

In fact, we could designate our black cat Arya as a user.

.The cat as a User
====
This is the same document as in <<ex-cat-user-identity>>, nothing to see here.

[source,clojure]
----
{:xt/id "https://example.org/cats/arya"
 :name "Arya"
 :species "cat"
 :color "black"
 :favorite-activity "playing with string"}
----
====

== User Identities

Site can tell when a particular user is logging in by matching the User's login
credentials with the user's identity details stored in the database.

Since users might have multiple identities, a User Identity is stored as a separate
document.

Again, Site makes no prescription as to what this User Identity document contains,
except one: it must contain a `:juxt.pass.alpha/user` attribute whose value is
the `:xt/id` of the User entity it relates to. This is shown in
<<ex-cat-user-identity>>.

[[ex-cat-user-identity]]
.A cat's User Identity
====
[source,clojure]
----
{:xt/id "https://example.org/user-identities/arya"
 :username "arya"
 :password "meow" <1>
 :juxt.pass.alpha/user "https://example.org/cats/arya" <2>
}
----
<1> Of course, you'd never ever _ever_ store a password in plain-text like
this. In the real-world, this attribute might reference the AI model you'd
trained to recognise Arya's unique _meow_.
====

== Subjects

When our cat logs in, a new document is created to capture details of the login
event itself, such as which User Identity was used, perhaps the geo-location of
Arya when she logged in, and so on. These details may be important later, if we
want to write authorization rules that make use of this information.

This document is called a Subject. The document references the User Identity
document, which in turn, references the User document, which may in turn
reference numerous other documents, recursively.

Thus, the Subject can be considered a _sub-graph_ of everything we know about
the User logging in.

.The Subject's view
[[cat-model]]
====
[plantuml,cat,svg]
....
skinparam monochrome true
@startjson
include::cat.json[]
@endjson
....
====

Users, user identities and subjects are described in <<ch-users>>.

== Resources

[quote]
____
The target of an HTTP request is called a "resource".  HTTP does not
limit the nature of a resource; it merely defines an interface that
might be used to interact with resources.  Each resource is
identified by a Uniform Resource Identifier (URI).
-- https://www.rfc-editor.org/rfc/rfc7231#section-2
____

In Site, every Document is a Resource.

Technically speaking, a Document represents a Resource _at a given time_. A
Resource's configuration and state might change over time, and so really it's
more correct to say that every Entity is a Resource.

<<ex-mat>> shows a Document representing a mat.

[[ex-mat]]
.A mat
====
[source,clojure]
----
{:xt/id "https://example.org/mat"
 :location "Living room"}
----
====

Cats are resources too.

Resources are fully described in <<ch-resources>>.

== Actions

Since every Document is a Resource, and is potentially accessible over the
network, we must ensure that we protect them against unauthorized access.

Site wraps the database in a protective layer where all access is mediated
through Actions.

In the statement:

....
The cat sat on the mat
....

We can designate the 'cat' as the Subject, and the 'mat' as the object, which is also a Resource.

The verb 'sat' relates to the Action.

Actions are described in <<ch-actions>>.

== Rules

Actions also define what the cat can do, and can optionally include the
object.

For instance, is the cat allowed to sit on the mat? How about the bed? Is the
cat allowed to scratch the mat? Is the dog allowed to sit on the mat?

These prescriptions are encoded as Datalog rules, as shown in <<ex-action>>.

Each rule is a collection of clauses, the first clause is always:

----
(allowed? permission subject action resource)
----

Think of this as an equation where the 'permission' variable must be found,
in the same way as a mathematical equation might ask for solutions for latexmath:[y = 2x + 6]. If
there are no permissions which satisfy the logic, then the Action is disallowed.

Rules are applied to queries as well as to mutating writes.

[[ex-action]]
.An Action
====
[source,clojure]
----
{:xt/id "https://example.org/actions/sit"
 :just.pass.alpha/rules
 [(allowed? permission subject action resource)
  [subject :juxt.pass.alpha/identity id]
  [id :juxt.pass.alpha/user user]
  [user :species "cat"]
  [permission :resource "https://example.org/mat"]
  [permission :user user]]}
----
====

Rules can be as simple or as complex as the domain requires. The power and
expressiveness of Datalog allows for a wide range of possibilities.

When compared to other 'third-party' solutions, Site's authorization system has
two further key advantages:

* Action rules are written as graphs which are free to traverse as deep as
  necessary into the complete database of facts. Other systems must often rely
  on a small subset of facts which place limits on the flexibility of
  authorization policies.

* Action rules benefit from strong database consistency. Rules are run only
  after any pending updates to Permission have been applied. Other systems often
  cannot achieve consistency because they are implemented as services across a
  network boundary and their database of facts may be out-of-date when making
  critical authorization decisions.

== Permissions

The Action in <<ex-action>> potentially allows cats to sit on the mat, but a
Permission must still explicitly exist for the rule to be satisfied.

The reason for this is simply that we often want to be able grant and revoke
access without having to continually update rules. Permissions are documents
that mark the event when access was granted or revoked, and the history of
Permission documents is recorded on the timeline just as it is for every other
type of document.

This architecture leads to a wide number of possible designs. For example, it's
possible to construct a permission to last for a few hours. Or model actions in
terms of roles, and have the Permission document grant an individual their
membership of a particular role.

Permissions are described in <<ch-permissions>>.
