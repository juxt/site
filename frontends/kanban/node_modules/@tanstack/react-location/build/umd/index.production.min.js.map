{"version":3,"file":"index.production.min.js","sources":["../../src/qss.ts","../../src/index.tsx"],"sourcesContent":["// @ts-nocheck\n\n// We're inlining qss here for compression's sake, but we've included it as a hard dependency for the MIT license it requires.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import * as React from 'react'\n\nimport {\n  createHashHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n  BrowserHistory,\n  MemoryHistory,\n  History,\n  HashHistory,\n} from 'history'\n\nexport { createHashHistory, createBrowserHistory, createMemoryHistory }\n\nimport { decode, encode } from './qss'\n\n// Types\n\ntype Timeout = ReturnType<typeof setTimeout>\n\ntype Maybe<T, TUnknown> = T extends {} ? T : TUnknown\n\nexport type DefaultGenerics = {\n  LoaderData: LoaderData<unknown>\n  Params: Params<string>\n  Search: Search<unknown>\n  RouteMeta: RouteMeta<unknown>\n}\n\nexport type PartialGenerics = Partial<DefaultGenerics>\n\nexport type MakeGenerics<TGenerics extends PartialGenerics> = TGenerics\n\nexport type Search<T> = Record<string, T>\nexport type Params<T> = Record<string, T>\nexport type LoaderData<T> = Record<string, T>\nexport type RouteMeta<T> = Record<string, T>\n\nexport type UseGeneric<\n  TGenerics extends PartialGenerics,\n  TGeneric extends keyof PartialGenerics,\n> = TGeneric extends 'LoaderData' | 'Search'\n  ? Partial<Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>>\n  : Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>\n\nexport type ReactLocationOptions = {\n  // The history object to be used internally by react-location\n  // A history will be created automatically if not provided.\n  history?: BrowserHistory | MemoryHistory | HashHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n\nexport type Updater<TResult> = TResult | ((prev?: TResult) => TResult)\n\nexport type Location<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  href: string\n  pathname: string\n  search: UseGeneric<TGenerics, 'Search'>\n  searchStr: string\n  hash: string\n  key?: string\n  // nextAction?: 'push' | 'replace'\n}\n\nexport type Route<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  // The path to match (relative to the nearest parent `Route` component or root basepath)\n  path?: string\n  // An ID to uniquely identify this route within its siblings. This is only required for routes that *only match on search* or if you have multiple routes with the same path\n  id?: string\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // Either (1) an object that will be used to shallowly match the current location's search or (2) A function that receives the current search params and can return truthy if they are matched.\n  search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n  // The duration to wait during `loader` execution before showing the `pendingElement`\n  pendingMs?: number\n  // _If the `pendingElement` is shown_, the minimum duration for which it will be visible.\n  pendingMinMs?: number\n  // Search filters can be used to rewrite, persist, default and manipulate search params for link that\n  // point to their routes or child routes. See the \"basic\" example to see them in action.\n  searchFilters?: SearchFilter<TGenerics>[]\n  // An array of child routes\n  children?: Route<TGenerics>[]\n  // Route Loaders (see below) can be inline on the route, or resolved async\n} & RouteLoaders<TGenerics> & {\n    // If `import` is defined, this route can resolve its elements and loaders in a single asynchronous call\n    // This is particularly useful for code-splitting or module federation\n    import?: (opts: {\n      params: UseGeneric<TGenerics, 'Params'>\n      search: UseGeneric<TGenerics, 'Search'>\n    }) => Promise<RouteLoaders<TGenerics>>\n  }\n\nexport type RouteLoaders<TGenerics> = {\n  // The content to be rendered when the route is matched. If no element is provided, defaults to `<Outlet />`\n  element?: SyncOrAsyncElement<TGenerics>\n  // The content to be rendered when `loader` encounters an error\n  errorElement?: SyncOrAsyncElement<TGenerics>\n  // The content to be rendered when the duration of `loader` execution surpasses the `pendingMs` duration\n  pendingElement?: SyncOrAsyncElement<TGenerics>\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  loader?: LoaderFn<TGenerics>\n  // An asynchronous function responsible for cleaning up when the match cache is cleared. This is useful when\n  // the loader function has side effects that need to be cleaned up when the match is no longer in use.\n  unloader?: UnloaderFn<TGenerics>\n  // An integer of milliseconds representing how long data should be cached for the route\n  loaderMaxAge?: number\n  // Similar to React's useEffect hook, this function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onMatch?: (\n    match: RouteMatch<TGenerics>,\n  ) => void | undefined | ((match: RouteMatch<TGenerics>) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: RouteMatch<TGenerics>) => void\n  // An object of whatever you want! This object is accessible anywhere matches are.\n  meta?: UseGeneric<TGenerics, 'RouteMeta'>\n}\n\nexport type SearchFilter<TGenerics> = (\n  prev: UseGeneric<TGenerics, 'Search'>,\n) => UseGeneric<TGenerics, 'Search'>\n\nexport type MatchLocation<TGenerics extends PartialGenerics = DefaultGenerics> =\n  {\n    to?: string | number | null\n    search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n    fuzzy?: boolean\n    caseSensitive?: boolean\n  }\n\nexport type SearchPredicate<TSearch> = (search: TSearch) => any\n\nexport type SyncOrAsyncElement<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = React.ReactNode | AsyncElement<TGenerics>\n\nexport type AsyncElement<TGenerics extends PartialGenerics = DefaultGenerics> =\n  (opts: {\n    params: UseGeneric<TGenerics, 'Params'>\n  }) => Promise<React.ReactNode>\n\nexport type UnloadedMatch<TGenerics extends PartialGenerics = DefaultGenerics> =\n  {\n    id: string\n    route: Route<TGenerics>\n    pathname: string\n    params: UseGeneric<TGenerics, 'Params'>\n    search: UseGeneric<TGenerics, 'Search'>\n  }\n\nexport type LoaderFn<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  routeMatch: RouteMatch<TGenerics>,\n  opts: LoaderFnOptions<TGenerics>,\n) => PromiseLike<UseGeneric<TGenerics, 'LoaderData'>>\n\nexport type UnloaderFn<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  routeMatch: RouteMatch<TGenerics>,\n) => void\n\nexport type LoaderFnOptions<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = {\n  parentMatch?: RouteMatch<TGenerics>\n  dispatch: (event: LoaderDispatchEvent<TGenerics>) => void\n}\n\ntype PromiseLike<T> = Promise<T> | T\n\nexport type ListenerFn = () => void\n\nexport type Segment = {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport type RouterProps<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  // Children will default to `<Outlet />` if not provided\n  children?: React.ReactNode\n  location: ReactLocation<TGenerics>\n} & RouterOptions<TGenerics>\n\nexport type RouterOptions<TGenerics> = {\n  // An array of route objects to match\n  routes: Route<TGenerics>[]\n  basepath?: string\n  filterRoutes?: FilterRoutesFn\n  defaultLinkPreloadMaxAge?: number\n  defaultLoaderMaxAge?: number\n  useErrorBoundary?: boolean\n  defaultElement?: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  caseSensitive?: boolean\n  __experimental__snapshot?: __Experimental__RouterSnapshot<TGenerics>\n}\n\nexport type __Experimental__RouterSnapshot<TGenerics> = {\n  // matches: Partial<RouteMatch<TGenerics>>[]\n  location: Location<TGenerics>\n  matches: SnapshotRouteMatch<TGenerics>[]\n}\n\nexport type SnapshotRouteMatch<TGenerics> = {\n  id: string\n  ownData: UseGeneric<TGenerics, 'LoaderData'>\n}\n\nexport type BuildNextOptions<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = {\n  to?: string | number | null\n  search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n  hash?: true | Updater<string>\n  from?: Partial<Location<TGenerics>>\n  key?: string\n  __searchFilters?: SearchFilter<TGenerics>[]\n}\n\nexport type NavigateOptions<TGenerics> = BuildNextOptions<TGenerics> & {\n  replace?: boolean\n  fromCurrent?: boolean\n}\n\nexport type PromptProps = {\n  message: string\n  when?: boolean | any\n  children?: React.ReactNode\n}\n\nexport type LinkProps<TGenerics extends PartialGenerics = DefaultGenerics> =\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'href' | 'children'> & {\n    // The absolute or relative destination pathname\n    to?: string | number | null\n    // The new search object or a function to update it\n    search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n    // The new has string or a function to update it\n    hash?: Updater<string>\n    // Whether to replace the current history stack instead of pushing a new one\n    replace?: boolean\n    // A function that is passed the [Location API](#location-api) and returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n    getActiveProps?: () => Record<string, any>\n    // A function that is passed the [Location API](#location-api) and returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n    getInactiveProps?: () => Record<string, any>\n    // Defaults to `{ exact: false, includeHash: false }`\n    activeOptions?: ActiveOptions\n    // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n    preload?: number\n    // If true, will render the link without the href attribute\n    disabled?: boolean\n    // A custom ref prop because of this: https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref/58473012\n    _ref?: React.Ref<HTMLAnchorElement>\n    // If a function is pass as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\ntype ActiveOptions = {\n  exact?: boolean\n  includeHash?: boolean\n}\n\nexport type LinkPropsType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  LinkProps<TGenerics>\n\nexport type LoaderDispatchEvent<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> =\n  | {\n      type: 'maxAge'\n      maxAge: number\n    }\n  | {\n      type: 'loading'\n    }\n  | {\n      type: 'resolve'\n      data: UseGeneric<TGenerics, 'LoaderData'>\n    }\n  | {\n      type: 'reject'\n      error: unknown\n    }\n\nexport type LoadRouteFn<TGenerics> = (\n  next: Location<TGenerics>,\n) => MatchLoader<TGenerics>\n\nexport type TransitionState<TGenerics> = {\n  location: Location<TGenerics>\n  matches: RouteMatch<TGenerics>[]\n}\n\nexport type FilterRoutesFn = <\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  routes: Route<TGenerics>[],\n) => Route<TGenerics>[]\n\nexport type RouterPropsType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = RouterProps<TGenerics>\n\nexport type RouterType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: RouterProps<TGenerics>,\n) => JSX.Element\n\ntype Listener = () => void\n\n// Source\n\nconst LocationContext = React.createContext<{ location: ReactLocation<any> }>(\n  null!,\n)\nconst MatchesContext = React.createContext<RouteMatch<any>[]>(null!)\nconst routerContext = React.createContext<{ router: RouterInstance<any> }>(\n  null!,\n)\n\n// Detect if we're in the DOM\nconst isDOM = Boolean(\n  typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement,\n)\n\nconst useLayoutEffect = isDOM ? React.useLayoutEffect : React.useEffect\n\n// This is the default history object if none is defined\nconst createDefaultHistory = () =>\n  isDOM ? createBrowserHistory() : createMemoryHistory()\n\nclass Subscribable {\n  listeners: Listener[]\n\n  constructor() {\n    this.listeners = []\n  }\n\n  subscribe(listener: Listener): () => void {\n    this.listeners.push(listener as Listener)\n\n    return () => {\n      this.listeners = this.listeners.filter((x) => x !== listener)\n    }\n  }\n\n  notify(): void {\n    this.listeners.forEach((listener) => listener())\n  }\n}\n\nexport class ReactLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  history: BrowserHistory | MemoryHistory\n  stringifySearch: SearchSerializer\n  parseSearch: SearchParser\n\n  current: Location<TGenerics>\n  destroy: () => void\n  navigateTimeout?: Timeout\n  nextAction?: 'push' | 'replace'\n\n  //\n\n  isTransitioning: boolean = false\n\n  constructor(options?: ReactLocationOptions) {\n    super()\n    this.history = options?.history || createDefaultHistory()\n    this.stringifySearch = options?.stringifySearch ?? defaultStringifySearch\n    this.parseSearch = options?.parseSearch ?? defaultParseSearch\n\n    this.current = this.parseLocation(this.history.location)\n\n    this.destroy = this.history.listen((event) => {\n      this.current = this.parseLocation(event.location, this.current)\n      this.notify()\n    })\n  }\n\n  buildNext(\n    basepath: string = '/',\n    dest: BuildNextOptions<TGenerics> = {},\n  ): Location<TGenerics> {\n    const from = {\n      ...this.current,\n      ...dest.from,\n    }\n\n    const pathname = resolvePath(basepath, from.pathname, `${dest.to ?? '.'}`)\n\n    const filteredSearch = dest.__searchFilters?.length\n      ? dest.__searchFilters.reduce((prev, next) => next(prev), from.search)\n      : from.search\n\n    const updatedSearch =\n      dest.search === true\n        ? filteredSearch // Preserve from true\n        : dest.search\n        ? functionalUpdate(dest.search, filteredSearch) ?? {} // Updater\n        : dest.__searchFilters?.length\n        ? filteredSearch // Preserve from filters\n        : {}\n\n    const search = replaceEqualDeep(from.search, updatedSearch)\n\n    const searchStr = this.stringifySearch(search)\n    let hash =\n      dest.hash === true ? from.hash : functionalUpdate(dest.hash, from.hash)\n    hash = hash ? `#${hash}` : ''\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      hash,\n      href: `${pathname}${searchStr}${hash}`,\n      key: dest.key,\n    }\n  }\n\n  navigate(next: Location<TGenerics>, replace?: boolean): void {\n    this.current = next\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl =\n      this.parseLocation(this.history.location).href === this.current.href\n\n    if (isSameUrl && !this.current.key) {\n      nextAction = 'replace'\n    }\n\n    if (nextAction === 'replace') {\n      return this.history.replace({\n        pathname: this.current.pathname,\n        hash: this.current.hash,\n        search: this.current.searchStr,\n      })\n    }\n\n    return this.history.push({\n      pathname: this.current.pathname,\n      hash: this.current.hash,\n      search: this.current.searchStr,\n    })\n  }\n\n  parseLocation(\n    location: History['location'],\n    previousLocation?: Location<TGenerics>,\n  ): Location<TGenerics> {\n    const parsedSearch = this.parseSearch(location.search)\n\n    return {\n      pathname: location.pathname,\n      searchStr: location.search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: location.hash.split('#').reverse()[0] ?? '',\n      href: `${location.pathname}${location.search}${location.hash}`,\n      key: location.key,\n    }\n  }\n}\n\nexport type MatchesProviderProps<TGenerics> = {\n  value: RouteMatch<TGenerics>[]\n  children: React.ReactNode\n}\n\nexport function MatchesProvider<TGenerics>(\n  props: MatchesProviderProps<TGenerics>,\n) {\n  return <MatchesContext.Provider {...props} />\n}\n\nexport function Router<TGenerics extends PartialGenerics = DefaultGenerics>({\n  children,\n  location,\n  __experimental__snapshot,\n  ...rest\n}: RouterProps<TGenerics>) {\n  const routerRef = React.useRef<RouterInstance<TGenerics>>(null!)\n  if (!routerRef.current) {\n    routerRef.current = new RouterInstance<TGenerics>({\n      location,\n      __experimental__snapshot,\n      routes: rest.routes,\n    })\n  }\n  const router = routerRef.current\n\n  const [nonce, rerender] = React.useReducer(() => ({}), {})\n\n  router.update(rest)\n\n  useLayoutEffect(() => {\n    return router.subscribe(() => {\n      rerender()\n    })\n  }, [])\n\n  useLayoutEffect(() => {\n    return router.updateLocation(location.current).unsubscribe\n  }, [location.current.key])\n\n  return (\n    <LocationContext.Provider value={{ location }}>\n      <routerContext.Provider value={{ router }}>\n        <InitialSideEffects />\n        <MatchesProvider value={[router.rootMatch!, ...router.state.matches]}>\n          {children ?? <Outlet />}\n        </MatchesProvider>\n      </routerContext.Provider>\n    </LocationContext.Provider>\n  )\n}\n\nfunction InitialSideEffects() {\n  const location = useLocation()\n  const buildNext = useBuildNext()\n  const navigate = useNavigate()\n\n  useLayoutEffect(() => {\n    const next = buildNext({\n      to: '.',\n      search: true,\n      hash: true,\n    })\n\n    if (next.href !== location.current.href) {\n      navigate({\n        to: '.',\n        search: true,\n        hash: true,\n        fromCurrent: true,\n        replace: true,\n      })\n    }\n  }, [])\n\n  return null\n}\n\ntype RouterInstanceState<TGenerics> = {\n  state: TransitionState<TGenerics>\n  pending?: TransitionState<TGenerics>\n}\n\nexport class RouterInstance<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  basepath?: string\n  rootMatch?: RouteMatch<TGenerics>\n  state: TransitionState<TGenerics>\n  pending?: TransitionState<TGenerics>\n  routes!: Route<TGenerics>[]\n  filterRoutes?: FilterRoutesFn\n  defaultLinkPreloadMaxAge?: number\n  defaultLoaderMaxAge?: number\n  useErrorBoundary?: boolean\n  defaultElement: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement: SyncOrAsyncElement<TGenerics>\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  caseSensitive?: boolean\n\n  routesById: Record<string, Route<TGenerics>> = {}\n\n  constructor({\n    location,\n    __experimental__snapshot,\n    ...rest\n  }: {\n    location: ReactLocation<TGenerics>\n    __experimental__snapshot?: __Experimental__RouterSnapshot<TGenerics>\n  } & RouterOptions<TGenerics>) {\n    super()\n\n    this.update(rest)\n\n    let matches: RouteMatch<TGenerics>[] = []\n\n    if (__experimental__snapshot) {\n      const matchLoader = new MatchLoader(this, location.current)\n      matchLoader.matches.forEach((match, index) => {\n        if (match.id !== __experimental__snapshot.matches[index]?.id) {\n          throw new Error(\n            `Router hydration mismatch: ${match.id} !== ${__experimental__snapshot.matches[index]?.id}`,\n          )\n        }\n        match.ownData = __experimental__snapshot.matches[index]?.ownData ?? {}\n      })\n      cascadeMatchData(matchLoader.matches)\n\n      matches = matchLoader.matches\n    }\n\n    this.state = {\n      location: __experimental__snapshot?.location ?? location.current,\n      matches: matches,\n    }\n\n    location.subscribe(() => this.notify())\n  }\n\n  update = ({ basepath, routes, ...opts }: RouterOptions<TGenerics>) => {\n    Object.assign(this, opts)\n\n    this.basepath = cleanPath(`/${basepath ?? ''}`)\n\n    this.routesById = {}\n\n    const recurseRoutes = (\n      routes: Route<TGenerics>[],\n      parent?: Route<TGenerics>,\n    ): Route<TGenerics>[] => {\n      return routes.map((route) => {\n        const path = route.path ?? '*'\n\n        const id = joinPaths([\n          parent?.id === 'root' ? '' : parent?.id,\n          `${path?.replace(/(.)\\/$/, '$1')}${route.id ? `-${route.id}` : ''}`,\n        ])\n\n        route = {\n          ...route,\n          pendingMs: route.pendingMs ?? opts?.defaultPendingMs,\n          pendingMinMs: route.pendingMinMs ?? opts?.defaultPendingMinMs,\n          id,\n        }\n\n        if (this.routesById[id]) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `Duplicate routes found with id: ${id}`,\n              this.routesById,\n              route,\n            )\n          }\n          throw new Error()\n        }\n\n        this.routesById[id] = route\n\n        route.children = route.children?.length\n          ? recurseRoutes(route.children, route)\n          : undefined\n\n        return route\n      })\n    }\n\n    this.routes = recurseRoutes(routes)\n\n    this.rootMatch = {\n      id: 'root',\n      params: {} as any,\n      search: {} as any,\n      pathname: this.basepath,\n      route: null!,\n      ownData: {},\n      data: {},\n      isLoading: false,\n      status: 'resolved',\n    }\n  }\n\n  setState = (\n    updater: (\n      old: RouterInstanceState<TGenerics>,\n    ) => RouterInstanceState<TGenerics>,\n  ) => {\n    const newState = updater({ state: this.state, pending: this.pending })\n    this.state = newState.state\n    this.pending = newState.pending\n    this.cleanMatchCache()\n    this.notify()\n  }\n\n  matchCache: Record<string, RouteMatch<TGenerics>> = {}\n\n  cleanMatchCache = () => {\n    const activeMatchIds = [\n      ...(this?.state.matches ?? []),\n      ...(this?.pending?.matches ?? []),\n    ].map((d) => d.id)\n\n    Object.values(this.matchCache).forEach((match) => {\n      if (!match.updatedAt) {\n        return\n      }\n\n      if (activeMatchIds.includes(match.id)) {\n        return\n      }\n\n      const age = Date.now() - (match.updatedAt ?? 0)\n\n      if (!match.maxAge || age > match.maxAge) {\n        if (match.route.unloader) {\n          match.route.unloader(match)\n        }\n\n        delete this.matchCache[match.id]\n      }\n    })\n  }\n\n  updateLocation = (next: Location<TGenerics>) => {\n    let unsubscribe: () => void\n\n    const promise = new Promise<void>((resolve) => {\n      const matchLoader = new MatchLoader(this, next)\n\n      this.setState((old) => {\n        return {\n          ...old,\n          pending: {\n            location: matchLoader.location,\n            matches: matchLoader.matches,\n          },\n        }\n      })\n\n      unsubscribe = matchLoader.subscribe(() => {\n        const currentMatches = this.state.matches\n\n        currentMatches\n          .filter((d) => {\n            return !matchLoader.matches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.onExit?.(d)\n          })\n\n        currentMatches\n          .filter((d) => {\n            return matchLoader.matches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.route.onTransition?.(d)\n          })\n\n        matchLoader.matches\n          .filter((d) => {\n            return !currentMatches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.onExit = d.route.onMatch?.(d)\n          })\n\n        this.setState((old) => {\n          return {\n            ...old,\n            state: {\n              location: matchLoader.location,\n              matches: matchLoader.matches,\n            },\n            pending: undefined,\n          }\n        })\n\n        resolve()\n      })\n\n      matchLoader.loadData()\n      matchLoader.startPending()\n    })\n\n    return {\n      promise,\n      unsubscribe: unsubscribe!,\n    }\n  }\n\n  __experimental__createSnapshot =\n    (): __Experimental__RouterSnapshot<TGenerics> => {\n      return {\n        location: this.state.location,\n        matches: this.state.matches.map(({ ownData, id }) => {\n          return {\n            id,\n            ownData,\n          }\n        }),\n      }\n    }\n}\n\nexport type UseLocationType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => ReactLocation<TGenerics>\n\nexport function useLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): ReactLocation<TGenerics> {\n  const context = React.useContext(LocationContext) as {\n    location: ReactLocation<TGenerics>\n  }\n  warning(!!context, 'useLocation must be used within a <ReactLocation />')\n\n  return context.location\n}\n\nexport class RouteMatch<TGenerics extends PartialGenerics = DefaultGenerics> {\n  id!: string\n  route!: Route<TGenerics>\n  pathname!: string\n  params!: UseGeneric<TGenerics, 'Params'>\n  search!: UseGeneric<TGenerics, 'Search'>\n  updatedAt?: number\n  element?: React.ReactNode\n  errorElement?: React.ReactNode\n  pendingElement?: React.ReactNode\n  error?: unknown\n  loaderPromise?: Promise<UseGeneric<TGenerics, 'LoaderData'>>\n  maxAge?: number\n  matchLoader?: MatchLoader<TGenerics>\n  pendingTimeout?: Timeout\n  pendingMinPromise?: Promise<void>\n  onExit?: void | ((match: RouteMatch<TGenerics>) => void)\n\n  constructor(unloadedMatch: UnloadedMatch<TGenerics>) {\n    Object.assign(this, unloadedMatch)\n  }\n\n  status: 'loading' | 'pending' | 'resolved' | 'rejected' = 'loading'\n  ownData: UseGeneric<TGenerics, 'LoaderData'> = {}\n  data: UseGeneric<TGenerics, 'LoaderData'> = {}\n  isLoading: boolean = false\n\n  private notify? = (isSoft?: boolean) => {\n    this.matchLoader?.preNotify(isSoft ? this : undefined)\n  }\n\n  assignMatchLoader? = (matchLoader: MatchLoader<TGenerics>) => {\n    this.matchLoader = matchLoader\n  }\n\n  startPending? = () => {\n    if (this.pendingTimeout) {\n      clearTimeout(this.pendingTimeout)\n    }\n\n    if (this.route.pendingMs !== undefined) {\n      this.pendingTimeout = setTimeout(() => {\n        if (this.status === 'loading') {\n          this.status = 'pending'\n        }\n        this.notify?.()\n        if (typeof this.route.pendingMinMs !== 'undefined') {\n          this.pendingMinPromise = new Promise((r) =>\n            setTimeout(r, this.route.pendingMinMs),\n          )\n        }\n      }, this.route.pendingMs)\n    }\n  }\n\n  load? = (opts: {\n    maxAge?: number\n    parentMatch?: RouteMatch<TGenerics>\n    router: RouterInstance<TGenerics>\n  }) => {\n    this.maxAge =\n      opts.maxAge ?? this.route.loaderMaxAge ?? opts.router.defaultLoaderMaxAge\n\n    if (this.loaderPromise) {\n      return\n    }\n\n    const importer = this.route.import\n\n    // First, run any importers\n    this.loaderPromise = (\n      !importer\n        ? Promise.resolve()\n        : (() => {\n            this.isLoading = true\n            return importer({ params: this.params, search: this.search }).then(\n              (imported) => {\n                this.route = {\n                  ...this.route,\n                  ...imported,\n                }\n              },\n            )\n          })()\n    )\n      // then run all element and data loaders in parallel\n      .then(() => {\n        const elementPromises: Promise<void>[] = []\n\n        // For each element type, potentially load it asynchronously\n        const elementTypes = [\n          'element',\n          'errorElement',\n          'pendingElement',\n        ] as const\n\n        elementTypes.forEach((type) => {\n          const routeElement = this.route[type]\n\n          if (this[type]) {\n            return\n          }\n\n          if (typeof routeElement === 'function') {\n            this.isLoading = true\n            elementPromises.push(\n              (routeElement as AsyncElement)(this).then((res) => {\n                this[type] = res\n              }),\n            )\n          } else {\n            this[type] = this.route[type]\n          }\n        })\n\n        const loader = this.route.loader\n\n        const dataPromise = !loader\n          ? Promise.resolve()\n          : new Promise(async (resolveLoader) => {\n              this.isLoading = true\n\n              const loaderReady = (status: 'resolved' | 'rejected') => {\n                this.updatedAt = Date.now()\n                resolveLoader(this.ownData)\n                this.status = status\n              }\n\n              const resolve = (data: any) => {\n                this.ownData = data\n                this.error = undefined\n                loaderReady('resolved')\n              }\n\n              const reject = (err: any) => {\n                console.error(err)\n                this.error = err\n                loaderReady('rejected')\n              }\n\n              try {\n                resolve(\n                  await loader(this, {\n                    parentMatch: opts.parentMatch,\n                    dispatch: async (event) => {\n                      if (event.type === 'resolve') {\n                        resolve(event.data)\n                      } else if (event.type === 'reject') {\n                        reject(event.error)\n                      } else if (event.type === 'loading') {\n                        this.isLoading = true\n                      } else if (event.type === 'maxAge') {\n                        this.maxAge = event.maxAge\n                      }\n\n                      this.updatedAt = Date.now()\n                      this.notify?.(true)\n                    },\n                  }),\n                )\n              } catch (err) {\n                reject(err)\n              }\n            })\n\n        return Promise.all([...elementPromises, dataPromise])\n          .then(() => {\n            this.status = 'resolved'\n            this.isLoading = false\n            this.startPending = undefined\n          })\n          .then(() => this.pendingMinPromise)\n          .then(() => {\n            if (this.pendingTimeout) {\n              clearTimeout(this.pendingTimeout)\n            }\n            this.notify?.(true)\n          })\n      })\n      .then(() => {\n        return this.ownData\n      })\n  }\n}\n\nclass MatchLoader<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  router: RouterInstance<TGenerics>\n  location: Location<TGenerics>\n  matches: RouteMatch<TGenerics>[]\n  prepPromise?: Promise<void>\n  matchPromise?: Promise<UnloadedMatch<TGenerics>[]>\n  firstRenderPromises?: Promise<any>[]\n  preNotifiedMatches: RouteMatch<TGenerics>[] = []\n\n  constructor(\n    router: RouterInstance<TGenerics>,\n    nextLocation: Location<TGenerics>,\n  ) {\n    super()\n    this.router = router\n    this.location = nextLocation\n    this.matches = []\n\n    const unloadedMatches = matchRoutes(this.router, this.location)\n\n    this.matches = unloadedMatches?.map(\n      (unloadedMatch): RouteMatch<TGenerics> => {\n        if (!this.router.matchCache[unloadedMatch.id]) {\n          this.router.matchCache[unloadedMatch.id] = new RouteMatch(\n            unloadedMatch,\n          )\n        }\n\n        return this.router.matchCache[unloadedMatch.id]!\n      },\n    )\n  }\n\n  status: 'pending' | 'resolved' = 'pending'\n\n  preNotify = (routeMatch?: RouteMatch<TGenerics>) => {\n    if (routeMatch) {\n      if (!this.preNotifiedMatches.includes(routeMatch)) {\n        this.preNotifiedMatches.push(routeMatch)\n      }\n    }\n\n    if (!routeMatch || this.preNotifiedMatches.length === this.matches.length) {\n      this.status = 'resolved'\n      cascadeMatchData(this.matches)\n      this.notify()\n    }\n  }\n\n  loadData = async ({ maxAge }: { maxAge?: number } = {}) => {\n    this.router.cleanMatchCache()\n\n    if (!this.matches?.length) {\n      this.preNotify()\n      return\n    }\n\n    this.firstRenderPromises = []\n\n    this.matches.forEach((match, index) => {\n      const parentMatch = this.matches?.[index - 1]\n      match.assignMatchLoader?.(this)\n      match.load?.({ maxAge, parentMatch, router: this.router })\n      this.firstRenderPromises?.push(match.loaderPromise!)\n    })\n\n    return await Promise.all(this.firstRenderPromises).then(() => {\n      this.preNotify()\n      return this.matches\n    })\n  }\n\n  load = async ({ maxAge }: { maxAge?: number } = {}) => {\n    return await this.loadData({ maxAge })\n  }\n\n  startPending = async () => {\n    this.matches.forEach((match) => match.startPending?.())\n  }\n}\n\nfunction cascadeMatchData<TGenerics>(matches?: RouteMatch<TGenerics>[]) {\n  matches?.forEach((match, index) => {\n    const parentMatch = matches?.[index - 1]\n\n    match.data = {\n      ...(parentMatch?.data ?? ({} as any)),\n      ...match.ownData,\n    }\n  })\n}\n\nexport type UseRouterType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouterInstance<TGenerics>\n\nexport function useRouter<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouterInstance<TGenerics> {\n  const value = React.useContext(routerContext)\n  if (!value) {\n    warning(true, 'You are trying to use useRouter() outside of ReactLocation!')\n    throw new Error()\n  }\n\n  return value.router as RouterInstance<TGenerics>\n}\n\nexport interface MatchRoutesOptions<TGenerics> {\n  filterRoutes?: FilterRoutesFn\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultElement?: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement?: SyncOrAsyncElement<TGenerics>\n}\n\nexport type MatchRoutesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  router: RouterInstance<TGenerics>[],\n  currentLocation: Location<TGenerics>,\n) => Promise<UnloadedMatch<TGenerics>[]>\n\nexport function matchRoutes<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  router: RouterInstance<TGenerics>,\n  currentLocation: Location<TGenerics>,\n): UnloadedMatch<TGenerics>[] {\n  if (!router.routes.length) {\n    return []\n  }\n\n  const matches: UnloadedMatch<TGenerics>[] = []\n\n  const recurse = async (\n    routes: Route<TGenerics>[],\n    parentMatch: UnloadedMatch<TGenerics>,\n  ): Promise<void> => {\n    let { pathname, params } = parentMatch\n    const filteredRoutes = router?.filterRoutes\n      ? router?.filterRoutes(routes)\n      : routes\n\n    const route = filteredRoutes.find((route) => {\n      const fullRoutePathName = joinPaths([pathname, route.path])\n\n      const fuzzy = !!(route.path !== '/' || route.children?.length)\n\n      const matchParams = matchRoute(currentLocation, {\n        to: fullRoutePathName,\n        search: route.search,\n        fuzzy,\n        caseSensitive: route.caseSensitive ?? router.caseSensitive,\n      })\n\n      if (matchParams) {\n        params = {\n          ...params,\n          ...matchParams,\n        }\n      }\n\n      return !!matchParams\n    })\n\n    if (!route) {\n      return\n    }\n\n    const interpolatedPath = interpolatePath(route.path, params)\n    pathname = joinPaths([pathname, interpolatedPath])\n\n    const interpolatedId = interpolatePath(route.id, params, true)\n\n    const match: UnloadedMatch<TGenerics> = {\n      id: interpolatedId,\n      route,\n      params,\n      pathname,\n      search: currentLocation.search,\n    }\n\n    matches.push(match)\n\n    if (route.children?.length) {\n      recurse(route.children, match)\n    }\n  }\n\n  recurse(router.routes, router.rootMatch!)\n\n  return matches\n}\n\nfunction interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.value === '*' && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport type UseLoadRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (routes?: Route<TGenerics>[]) => void\n\nexport function useLoadRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const router = useRouter<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  return useLatestCallback(\n    async (\n      navigate: NavigateOptions<TGenerics> = location.current,\n      opts?: { maxAge?: number },\n    ) => {\n      const next = buildNext({\n        ...navigate,\n        from: navigate.from ?? { pathname: match.pathname },\n      })\n\n      const matchLoader = new MatchLoader(router, next)\n\n      return await matchLoader.load(opts)\n    },\n  )\n}\n\nexport type UseMatchesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => RouteMatch<TGenerics>[]\n\nexport function useParentMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  const router = useRouter<TGenerics>()\n  const match = useMatch()\n\n  const matches = router.state.matches\n\n  return matches.slice(0, matches.findIndex((d) => d.id === match.id) - 1)\n}\n\nexport function useMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  return React.useContext(MatchesContext)\n}\n\nexport type UseMatchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouteMatch<TGenerics>\n\nexport function useMatch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics> {\n  return useMatches<TGenerics>()?.[0]!\n}\n\nexport type UseNavigateType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (options: NavigateOptions<TGenerics>) => void\n\nexport function useNavigate<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  function navigate({\n    search,\n    hash,\n    replace,\n    from,\n    to,\n    fromCurrent,\n  }: NavigateOptions<TGenerics> & {\n    replace?: boolean\n  }) {\n    fromCurrent = fromCurrent ?? typeof to === 'undefined'\n\n    const next = buildNext({\n      to,\n      search,\n      hash,\n      from: fromCurrent\n        ? location.current\n        : from ?? { pathname: match.pathname },\n    })\n\n    location.navigate(next, replace)\n  }\n\n  return useLatestCallback(navigate)\n}\n\nexport type NavigateType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  (options: NavigateOptions<TGenerics>) => null\n\nexport function Navigate<TGenerics extends PartialGenerics = DefaultGenerics>(\n  options: NavigateOptions<TGenerics>,\n) {\n  let navigate = useNavigate<TGenerics>()\n\n  useLayoutEffect(() => {\n    navigate(options)\n  }, [navigate])\n\n  return null\n}\n\nfunction useBuildNext<TGenerics>() {\n  const location = useLocation<TGenerics>()\n  const router = useRouter<TGenerics>()\n\n  const buildNext = (opts: BuildNextOptions<TGenerics>) => {\n    const next = location.buildNext(router.basepath, opts)\n\n    const matches = matchRoutes<TGenerics>(router, next)\n\n    const __searchFilters = matches\n      .map((match) => match.route.searchFilters ?? [])\n      .flat()\n      .filter(Boolean)\n\n    return location.buildNext(router.basepath, { ...opts, __searchFilters })\n  }\n\n  return useLatestCallback(buildNext)\n}\n\nexport type LinkType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: LinkProps<TGenerics>,\n) => JSX.Element\n\nexport const Link = function Link<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  to = '.',\n  search,\n  hash,\n  children,\n  target,\n  style = {},\n  replace,\n  onClick,\n  onMouseEnter,\n  className = '',\n  getActiveProps = () => ({ className: 'active' }),\n  getInactiveProps = () => ({}),\n  activeOptions,\n  preload,\n  disabled,\n  _ref,\n  ...rest\n}: LinkProps<TGenerics>) {\n  const loadRoute = useLoadRoute<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const location = useLocation<TGenerics>()\n  const router = useRouter<TGenerics>()\n  const navigate = useNavigate<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  preload = preload ?? router.defaultLinkPreloadMaxAge\n\n  // If this `to` is a valid external URL, log a warning\n  try {\n    const url = new URL(`${to}`)\n    warning(\n      false,\n      `<Link /> should not be used for external URLs like: ${url.href}`,\n    )\n  } catch (e) {}\n\n  const next = buildNext({\n    to,\n    search,\n    hash,\n    from: { pathname: match.pathname },\n  })\n\n  // The click handler\n  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    if (disabled) return\n    if (onClick) onClick(e)\n\n    if (\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n      // All is well? Navigate!\n      navigate({\n        to,\n        search,\n        hash,\n        replace,\n        from: { pathname: match.pathname },\n      })\n    }\n  }\n\n  // The click handler\n  const handleMouseEnter = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    if (onMouseEnter) onMouseEnter(e)\n\n    if (preload && preload > 0) {\n      loadRoute(\n        {\n          to,\n          search,\n          hash,\n        },\n        { maxAge: preload },\n      )\n    }\n  }\n\n  // Compare path/hash for matches\n  const pathIsEqual = location.current.pathname === next.pathname\n  const currentPathSplit = location.current.pathname.split('/')\n  const nextPathSplit = next.pathname.split('/')\n  const pathIsFuzzyEqual = nextPathSplit.every(\n    (d, i) => d === currentPathSplit[i],\n  )\n  const hashIsEqual = location.current.hash === next.hash\n\n  // Combine the matches based on user options\n  const pathTest = activeOptions?.exact ? pathIsEqual : pathIsFuzzyEqual\n  const hashTest = activeOptions?.includeHash ? hashIsEqual : true\n\n  // The final \"active\" test\n  const isActive = pathTest && hashTest\n\n  // Get the active props\n  const {\n    style: activeStyle = {},\n    className: activeClassName = '',\n    ...activeRest\n  } = isActive ? getActiveProps() : {}\n\n  // Get the inactive props\n  const {\n    style: inactiveStyle = {},\n    className: inactiveClassName = '',\n    ...inactiveRest\n  } = isActive ? {} : getInactiveProps()\n\n  return (\n    <a\n      {...{\n        ref: _ref,\n        href: disabled ? undefined : next.href,\n        onClick: handleClick,\n        onMouseEnter: handleMouseEnter,\n        target,\n        style: {\n          ...style,\n          ...activeStyle,\n          ...inactiveStyle,\n        },\n        className:\n          [className, activeClassName, inactiveClassName]\n            .filter(Boolean)\n            .join(' ') || undefined,\n        ...(disabled\n          ? {\n              role: 'link',\n              'aria-disabled': true,\n            }\n          : undefined),\n        ...rest,\n        ...activeRest,\n        ...inactiveRest,\n        children:\n          typeof children === 'function' ? children({ isActive }) : children,\n      }}\n    />\n  )\n}\n\nexport function Outlet<TGenerics extends PartialGenerics = DefaultGenerics>() {\n  const router = useRouter<TGenerics>()\n  const [_, ...matches] = useMatches<TGenerics>()\n\n  const match = matches[0]\n\n  if (!match) {\n    return null\n  }\n\n  const errorElement = match.errorElement ?? router.defaultErrorElement\n\n  const element = (() => {\n    if (match.status === 'rejected') {\n      if (errorElement) {\n        return errorElement\n      }\n\n      if (!router.useErrorBoundary) {\n        if (process.env.NODE_ENV !== 'production') {\n          const preStyle: React.HTMLAttributes<HTMLPreElement>['style'] = {\n            whiteSpace: 'normal',\n            display: 'inline-block',\n            background: 'rgba(0,0,0,.1)',\n            padding: '.1rem .2rem',\n            margin: '.1rem',\n            lineHeight: '1',\n            borderRadius: '.25rem',\n          }\n\n          return (\n            <div style={{ lineHeight: '1.7' }}>\n              <strong>\n                The following error occured in the loader for you route at:{' '}\n                <pre style={preStyle}>{match.pathname}</pre>\n              </strong>\n              .\n              <br />\n              <pre\n                style={{\n                  ...preStyle,\n                  display: 'block',\n                  padding: '.5rem',\n                  borderRadius: '.5rem',\n                }}\n              >\n                {(match.error as any).toString()}\n              </pre>\n              <br />\n              Your users won't see this message in production, but they will see{' '}\n              <strong>\"An unknown error occured!\"</strong>, which is at least\n              better than breaking your entire app. 😊 For a better UX, please\n              specify an <pre style={preStyle}>errorElement</pre> for all of\n              your routes that contain asynchronous behavior, or at least\n              provide your own\n              <pre style={preStyle}>ErrorBoundary</pre> wrapper around your\n              renders to both the elements rendered by{' '}\n              <pre style={preStyle}>\n                {'useRoutes(routes, { useErrorBoundary: true })'}\n              </pre>{' '}\n              and <pre style={preStyle}>{'<Router useErrorBoundary />'}</pre>.{' '}\n              <br />\n              <br />\n            </div>\n          )\n        }\n        return 'An unknown error occured!'\n      }\n\n      throw match.error\n    }\n\n    const pendingElement = match.pendingElement ?? router.defaultPendingElement\n\n    if (match.status === 'loading') {\n      return null\n    }\n\n    if (match.status === 'pending') {\n      if (match.route.pendingMs || pendingElement) {\n        return pendingElement ?? null\n      }\n    }\n\n    const matchElement = match.element ?? router.defaultElement\n\n    return matchElement ?? <Outlet />\n  })()\n\n  return <MatchesProvider value={matches}>{element}</MatchesProvider>\n}\n\nexport function useResolvePath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const router = useRouter<TGenerics>()\n  const match = useMatch<TGenerics>()\n\n  return useLatestCallback((path: string) =>\n    resolvePath(router.basepath!, match.pathname!, cleanPath(path)),\n  )\n}\n\nexport type UseSearchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => Partial<Maybe<TGenerics['Search'], Search<any>>>\n\nexport function useSearch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  return location.current.search\n}\n\nexport type MatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) => UseGeneric<TGenerics, 'Params'> | undefined\n\nexport function matchRoute<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const pathParams = matchByPath(currentLocation, matchLocation)\n  const searchMatched = matchBySearch(currentLocation, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  if (matchLocation.search && !searchMatched) {\n    return\n  }\n\n  return (pathParams ?? {}) as UseGeneric<TGenerics, 'Params'>\n}\n\nexport type UseMatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => (\n  matchLocation: MatchLocation<TGenerics>,\n) => Maybe<TGenerics['Params'], Params<any>> | undefined\n\nexport type UseMatchRouteOptions<TGenerics> = MatchLocation<TGenerics> & {\n  pending?: boolean\n}\n\nexport function useMatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): (\n  matchLocation: UseMatchRouteOptions<TGenerics>,\n  opts?: { caseSensitive?: boolean },\n) => Maybe<TGenerics['Params'], Params<any>> | undefined {\n  const router = useRouter<TGenerics>()\n  const resolvePath = useResolvePath<TGenerics>()\n\n  return useLatestCallback(\n    ({\n      pending,\n      ...matchLocation\n    }: MatchLocation<TGenerics> & { pending?: boolean }) => {\n      matchLocation = {\n        ...matchLocation,\n        to: matchLocation.to ? resolvePath(`${matchLocation.to}`) : undefined,\n      }\n\n      if (pending) {\n        if (!router.pending?.location) {\n          return undefined\n        }\n        return matchRoute(router.pending.location, matchLocation)\n      }\n\n      return matchRoute(router.state.location, matchLocation)\n    },\n  )\n}\n\nexport function MatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  children,\n  ...rest\n}: UseMatchRouteOptions<TGenerics> & {\n  children:\n    | React.ReactNode\n    | ((isNextLocation?: Params<TGenerics>) => React.ReactNode)\n}) {\n  const matchRoute = useMatchRoute<TGenerics>()\n  const match = matchRoute(rest)\n\n  if (typeof children === 'function') {\n    return children(match as any)\n  }\n\n  return match ? children : null\n}\n\nexport function usePrompt(message: string, when: boolean | any): void {\n  const location = useLocation()\n\n  React.useEffect(() => {\n    if (!when) return\n\n    let unblock = location.history.block((transition) => {\n      if (window.confirm(message)) {\n        unblock()\n        transition.retry()\n      } else {\n        location.current.pathname = window.location.pathname\n      }\n    })\n\n    return unblock\n  }, [when, location, message])\n}\n\nexport function Prompt({ message, when, children }: PromptProps) {\n  usePrompt(message, when ?? true)\n  return (children ?? null) as React.ReactNode\n}\n\nfunction warning(cond: boolean, message: string) {\n  if (!cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater?: Updater<TResult>,\n  previous?: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nfunction joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return `${path}`.replace(/\\/{2,}/g, '/')\n}\n\nexport function matchByPath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const baseSegments = parsePathname(currentLocation.pathname)\n  const routeSegments = parsePathname(`${matchLocation.to ?? '*'}`)\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          params[routeSegment.value.substring(1)] = baseSegment.value\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as UseGeneric<TGenerics, 'Params'>) : undefined\n}\n\nfunction matchBySearch<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) {\n  return !!(\n    matchLocation.search && matchLocation.search(currentLocation.search)\n  )\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part.startsWith('*')) {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === ':') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nfunction isCtrlEvent(e: React.MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nfunction useLatestCallback<TCallback extends (...args: any[]) => any>(\n  cb: TCallback,\n) {\n  const stableFnRef =\n    React.useRef<(...args: Parameters<TCallback>) => ReturnType<TCallback>>()\n  const cbRef = React.useRef<TCallback>(cb)\n\n  cbRef.current = cb\n\n  if (!stableFnRef.current) {\n    stableFnRef.current = (...args) => cbRef.current(...args)\n  }\n\n  return stableFnRef.current\n}\n\nfunction useGetIsMounted() {\n  const ref = React.useRef(false)\n\n  React.useEffect(() => {\n    ref.current = true\n\n    return () => {\n      ref.current = false\n    }\n  })\n\n  return () => ref.current\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nfunction replaceEqualDeep(prev: any, next: any) {\n  if (prev === next) {\n    return prev\n  }\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const aSize = array ? prev.length : Object.keys(prev).length\n    const bItems = array ? next : Object.keys(next)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): Record<string, any> => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n"],"names":["toValue","mix","str","decodeURIComponent","LocationContext","React","createContext","MatchesContext","routerContext","isDOM","Boolean","window","document","createElement","useLayoutEffect","useEffect","Subscribable","constructor","listeners","subscribe","listener","push","this","filter","x","notify","forEach","MatchesProvider","props","Provider","InitialSideEffects","location","useLocation","buildNext","useBuildNext","navigate","useNavigate","to","search","hash","href","current","fromCurrent","replace","RouterInstance","__experimental__snapshot","rest","routesById","update","_ref4","basepath","routes","opts","Object","assign","cleanPath","recurseRoutes","parent","map","route","path","id","joinPaths","pendingMs","defaultPendingMs","pendingMinMs","defaultPendingMinMs","Error","children","length","undefined","rootMatch","params","pathname","ownData","data","isLoading","status","setState","updater","newState","state","pending","cleanMatchCache","matchCache","activeMatchIds","matches","_this$pending","d","values","match","updatedAt","includes","age","Date","now","maxAge","unloader","updateLocation","next","unsubscribe","promise","Promise","resolve","matchLoader","MatchLoader","old","currentMatches","find","dd","onExit","onTransition","onMatch","loadData","startPending","__experimental__createSnapshot","_ref5","index","_experimental__snaps","_experimental__snaps2","_experimental__snaps4","cascadeMatchData","context","useContext","warning","RouteMatch","unloadedMatch","isSoft","preNotify","assignMatchLoader","pendingTimeout","clearTimeout","setTimeout","pendingMinPromise","r","load","loaderMaxAge","router","defaultLoaderMaxAge","loaderPromise","importer","import","then","imported","elementPromises","type","routeElement","res","loader","dataPromise","async","loaderReady","resolveLoader","error","reject","err","console","parentMatch","dispatch","event","all","nextLocation","preNotifiedMatches","routeMatch","_this","_this$matches","firstRenderPromises","_this$matches2","unloadedMatches","matchRoutes","useRouter","value","currentLocation","recurse","filterRoutes","fullRoutePathName","fuzzy","_route$children2","matchParams","matchRoute","caseSensitive","interpolatedPath","interpolatePath","_route$children3","leaveWildcard","parsePathname","segment","substring","useLoadRoute","useMatch","useLatestCallback","from","useMatches","_useMatches","__searchFilters","searchFilters","flat","Outlet","_","errorElement","defaultErrorElement","element","useErrorBoundary","pendingElement","defaultPendingElement","matchElement","defaultElement","useResolvePath","resolvePath","matchLocation","pathParams","matchByPath","searchMatched","matchBySearch","useMatchRoute","_ref11","_router$pending","usePrompt","message","when","unblock","history","block","transition","confirm","retry","cond","warn","functionalUpdate","previous","paths","join","baseSegments","routeSegments","i","Math","max","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","slice","toLowerCase","segments","split","part","startsWith","charAt","base","RegExp","toSegments","toSegment","pop","cb","stableFnRef","useRef","cbRef","replaceEqualDeep","prev","array","Array","isArray","isPlainObject","aSize","keys","bItems","bSize","copy","equalItems","key","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","tmp","k","out","arr","shift","concat","decode","val","obj","pfx","encodeURIComponent","encode","target","style","onClick","onMouseEnter","className","getActiveProps","getInactiveProps","activeOptions","preload","disabled","_ref","loadRoute","defaultLinkPreloadMaxAge","URL","e","pathIsEqual","currentPathSplit","pathIsFuzzyEqual","every","hashIsEqual","pathTest","exact","hashTest","includeHash","isActive","activeStyle","activeClassName","activeRest","inactiveStyle","inactiveClassName","inactiveRest","ref","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","defaultPrevented","button","preventDefault","role","options","isTransitioning","createBrowserHistory","createMemoryHistory","stringifySearch","parseSearch","parseLocation","destroy","listen","dest","filteredSearch","reduce","updatedSearch","navigateTimeout","nextAction","previousLocation","parsedSearch","reverse","routerRef","nonce","rerender","useReducer","findIndex"],"mappings":"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"}