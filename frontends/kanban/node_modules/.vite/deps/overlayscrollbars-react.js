import {
  require_react
} from "./chunk-KQJKTEOQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-4ACCWERV.js";

// node_modules/overlayscrollbars/js/OverlayScrollbars.js
var require_OverlayScrollbars = __commonJS({
  "node_modules/overlayscrollbars/js/OverlayScrollbars.js"(exports, module) {
    (function(global, factory) {
      if (typeof define === "function" && define.amd)
        define(function() {
          return factory(global, global.document, void 0);
        });
      else if (typeof module === "object" && typeof module.exports === "object")
        module.exports = factory(global, global.document, void 0);
      else
        factory(global, global.document, void 0);
    })(
      typeof window !== "undefined" ? window : exports,
      function(window2, document, undefined2) {
        "use strict";
        var PLUGINNAME = "OverlayScrollbars";
        var TYPES = {
          o: "object",
          f: "function",
          a: "array",
          s: "string",
          b: "boolean",
          n: "number",
          u: "undefined",
          z: "null"
        };
        var LEXICON = {
          c: "class",
          s: "style",
          i: "id",
          l: "length",
          p: "prototype",
          ti: "tabindex",
          oH: "offsetHeight",
          cH: "clientHeight",
          sH: "scrollHeight",
          oW: "offsetWidth",
          cW: "clientWidth",
          sW: "scrollWidth",
          hOP: "hasOwnProperty",
          bCR: "getBoundingClientRect"
        };
        var VENDORS = function() {
          var jsCache = {};
          var cssCache = {};
          var cssPrefixes = ["-webkit-", "-moz-", "-o-", "-ms-"];
          var jsPrefixes = ["WebKit", "Moz", "O", "MS"];
          function firstLetterToUpper(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
          }
          return {
            _cssPrefixes: cssPrefixes,
            _jsPrefixes: jsPrefixes,
            _cssProperty: function(name) {
              var result = cssCache[name];
              if (cssCache[LEXICON.hOP](name))
                return result;
              var uppercasedName = firstLetterToUpper(name);
              var elmStyle = document.createElement("div")[LEXICON.s];
              var resultPossibilities;
              var i = 0;
              var v;
              var currVendorWithoutDashes;
              for (; i < cssPrefixes.length; i++) {
                currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, "");
                resultPossibilities = [
                  name,
                  cssPrefixes[i] + name,
                  currVendorWithoutDashes + uppercasedName,
                  firstLetterToUpper(currVendorWithoutDashes) + uppercasedName
                ];
                for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                  if (elmStyle[resultPossibilities[v]] !== undefined2) {
                    result = resultPossibilities[v];
                    break;
                  }
                }
              }
              cssCache[name] = result;
              return result;
            },
            _cssPropertyValue: function(property, values, suffix) {
              var name = property + " " + values;
              var result = cssCache[name];
              if (cssCache[LEXICON.hOP](name))
                return result;
              var dummyStyle = document.createElement("div")[LEXICON.s];
              var possbleValues = values.split(" ");
              var preparedSuffix = suffix || "";
              var i = 0;
              var v = -1;
              var prop;
              for (; i < possbleValues[LEXICON.l]; i++) {
                for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
                  prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
                  dummyStyle.cssText = property + ":" + prop + preparedSuffix;
                  if (dummyStyle[LEXICON.l]) {
                    result = prop;
                    break;
                  }
                }
              }
              cssCache[name] = result;
              return result;
            },
            _jsAPI: function(name, isInterface, fallback) {
              var i = 0;
              var result = jsCache[name];
              if (!jsCache[LEXICON.hOP](name)) {
                result = window2[name];
                for (; i < jsPrefixes[LEXICON.l]; i++)
                  result = result || window2[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                jsCache[name] = result;
              }
              return result || fallback;
            }
          };
        }();
        var COMPATIBILITY = function() {
          function windowSize(x) {
            return x ? window2.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window2.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
          }
          function bind(func, thisObj) {
            if (typeof func != TYPES.f) {
              throw "Can't bind function!";
            }
            var proto = LEXICON.p;
            var aArgs = Array[proto].slice.call(arguments, 2);
            var fNOP = function() {
            };
            var fBound = function() {
              return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments)));
            };
            if (func[proto])
              fNOP[proto] = func[proto];
            fBound[proto] = new fNOP();
            return fBound;
          }
          return {
            wW: bind(windowSize, 0, true),
            wH: bind(windowSize, 0),
            mO: bind(VENDORS._jsAPI, 0, "MutationObserver", true),
            rO: bind(VENDORS._jsAPI, 0, "ResizeObserver", true),
            rAF: bind(VENDORS._jsAPI, 0, "requestAnimationFrame", false, function(func) {
              return window2.setTimeout(func, 1e3 / 60);
            }),
            cAF: bind(VENDORS._jsAPI, 0, "cancelAnimationFrame", false, function(id) {
              return window2.clearTimeout(id);
            }),
            now: function() {
              return Date.now && Date.now() || new Date().getTime();
            },
            stpP: function(event) {
              if (event.stopPropagation)
                event.stopPropagation();
              else
                event.cancelBubble = true;
            },
            prvD: function(event) {
              if (event.preventDefault && event.cancelable)
                event.preventDefault();
              else
                event.returnValue = false;
            },
            page: function(event) {
              event = event.originalEvent || event;
              var strPage = "page";
              var strClient = "client";
              var strX = "X";
              var strY = "Y";
              var target = event.target || event.srcElement || document;
              var eventDoc = target.ownerDocument || document;
              var doc = eventDoc.documentElement;
              var body = eventDoc.body;
              if (event.touches !== undefined2) {
                var touch = event.touches[0];
                return {
                  x: touch[strPage + strX],
                  y: touch[strPage + strY]
                };
              }
              if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {
                return {
                  x: event[strClient + strX] + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0),
                  y: event[strClient + strY] + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
                };
              }
              return {
                x: event[strPage + strX],
                y: event[strPage + strY]
              };
            },
            mBtn: function(event) {
              var button = event.button;
              if (!event.which && button !== undefined2)
                return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
              else
                return event.which;
            },
            inA: function(item, arr) {
              for (var i = 0; i < arr[LEXICON.l]; i++)
                try {
                  if (arr[i] === item)
                    return i;
                } catch (e) {
                }
              return -1;
            },
            isA: function(arr) {
              var def = Array.isArray;
              return def ? def(arr) : this.type(arr) == TYPES.a;
            },
            type: function(obj) {
              if (obj === undefined2)
                return obj + "";
              if (obj === null)
                return obj + "";
              return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
            },
            bind
          };
        }();
        var MATH = Math;
        var JQUERY = window2.jQuery;
        var EASING = function() {
          var _easingsMath = {
            p: MATH.PI,
            c: MATH.cos,
            s: MATH.sin,
            w: MATH.pow,
            t: MATH.sqrt,
            n: MATH.asin,
            a: MATH.abs,
            o: 1.70158
          };
          return {
            swing: function(x, t, b, c, d) {
              return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
            },
            linear: function(x, t, b, c, d) {
              return x;
            },
            easeInQuad: function(x, t, b, c, d) {
              return c * (t /= d) * t + b;
            },
            easeOutQuad: function(x, t, b, c, d) {
              return -c * (t /= d) * (t - 2) + b;
            },
            easeInOutQuad: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b;
            },
            easeInCubic: function(x, t, b, c, d) {
              return c * (t /= d) * t * t + b;
            },
            easeOutCubic: function(x, t, b, c, d) {
              return c * ((t = t / d - 1) * t * t + 1) + b;
            },
            easeInOutCubic: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
            },
            easeInQuart: function(x, t, b, c, d) {
              return c * (t /= d) * t * t * t + b;
            },
            easeOutQuart: function(x, t, b, c, d) {
              return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            },
            easeInOutQuart: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
            },
            easeInQuint: function(x, t, b, c, d) {
              return c * (t /= d) * t * t * t * t + b;
            },
            easeOutQuint: function(x, t, b, c, d) {
              return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
            },
            easeInOutQuint: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
            },
            easeInSine: function(x, t, b, c, d) {
              return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
            },
            easeOutSine: function(x, t, b, c, d) {
              return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
            },
            easeInOutSine: function(x, t, b, c, d) {
              return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
            },
            easeInExpo: function(x, t, b, c, d) {
              return t == 0 ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
            },
            easeOutExpo: function(x, t, b, c, d) {
              return t == d ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
            },
            easeInOutExpo: function(x, t, b, c, d) {
              if (t == 0)
                return b;
              if (t == d)
                return b + c;
              if ((t /= d / 2) < 1)
                return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;
              return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
            },
            easeInCirc: function(x, t, b, c, d) {
              return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
            },
            easeOutCirc: function(x, t, b, c, d) {
              return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
            },
            easeInOutCirc: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
            },
            easeInElastic: function(x, t, b, c, d) {
              var s = _easingsMath.o;
              var p = 0;
              var a = c;
              if (t == 0)
                return b;
              if ((t /= d) == 1)
                return b + c;
              if (!p)
                p = d * 0.3;
              if (a < _easingsMath.a(c)) {
                a = c;
                s = p / 4;
              } else
                s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
              return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
            },
            easeOutElastic: function(x, t, b, c, d) {
              var s = _easingsMath.o;
              var p = 0;
              var a = c;
              if (t == 0)
                return b;
              if ((t /= d) == 1)
                return b + c;
              if (!p)
                p = d * 0.3;
              if (a < _easingsMath.a(c)) {
                a = c;
                s = p / 4;
              } else
                s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
              return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;
            },
            easeInOutElastic: function(x, t, b, c, d) {
              var s = _easingsMath.o;
              var p = 0;
              var a = c;
              if (t == 0)
                return b;
              if ((t /= d / 2) == 2)
                return b + c;
              if (!p)
                p = d * (0.3 * 1.5);
              if (a < _easingsMath.a(c)) {
                a = c;
                s = p / 4;
              } else
                s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
              if (t < 1)
                return -0.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
              return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * 0.5 + c + b;
            },
            easeInBack: function(x, t, b, c, d, s) {
              s = s || _easingsMath.o;
              return c * (t /= d) * t * ((s + 1) * t - s) + b;
            },
            easeOutBack: function(x, t, b, c, d, s) {
              s = s || _easingsMath.o;
              return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
            },
            easeInOutBack: function(x, t, b, c, d, s) {
              s = s || _easingsMath.o;
              return (t /= d / 2) < 1 ? c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
            },
            easeInBounce: function(x, t, b, c, d) {
              return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
            },
            easeOutBounce: function(x, t, b, c, d) {
              var o = 7.5625;
              if ((t /= d) < 1 / 2.75) {
                return c * (o * t * t) + b;
              } else if (t < 2 / 2.75) {
                return c * (o * (t -= 1.5 / 2.75) * t + 0.75) + b;
              } else if (t < 2.5 / 2.75) {
                return c * (o * (t -= 2.25 / 2.75) * t + 0.9375) + b;
              } else {
                return c * (o * (t -= 2.625 / 2.75) * t + 0.984375) + b;
              }
            },
            easeInOutBounce: function(x, t, b, c, d) {
              return t < d / 2 ? this.easeInBounce(x, t * 2, 0, c, d) * 0.5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            }
          };
        }();
        var FRAMEWORK = function() {
          var _rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
          var _strSpace = " ";
          var _strEmpty = "";
          var _strScrollLeft = "scrollLeft";
          var _strScrollTop = "scrollTop";
          var _animations = [];
          var _type = COMPATIBILITY.type;
          var _cssNumber = {
            animationIterationCount: true,
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
          };
          function extend() {
            var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length2 = arguments[LEXICON.l], deep = false;
            if (_type(target) == TYPES.b) {
              deep = target;
              target = arguments[1] || {};
              i = 2;
            }
            if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {
              target = {};
            }
            if (length2 === i) {
              target = FakejQuery;
              --i;
            }
            for (; i < length2; i++) {
              if ((options = arguments[i]) != null) {
                for (name in options) {
                  src = target[name];
                  copy = options[name];
                  if (target === copy) {
                    continue;
                  }
                  if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
                    if (copyIsArray) {
                      copyIsArray = false;
                      clone = src && COMPATIBILITY.isA(src) ? src : [];
                    } else {
                      clone = src && isPlainObject(src) ? src : {};
                    }
                    target[name] = extend(deep, clone, copy);
                  } else if (copy !== undefined2) {
                    target[name] = copy;
                  }
                }
              }
            }
            return target;
          }
          ;
          function inArray(item, arr, fromIndex) {
            for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)
              if (arr[i] === item)
                return i;
            return -1;
          }
          function isFunction(obj) {
            return _type(obj) == TYPES.f;
          }
          ;
          function isEmptyObject(obj) {
            for (var name in obj)
              return false;
            return true;
          }
          ;
          function isPlainObject(obj) {
            if (!obj || _type(obj) != TYPES.o)
              return false;
            var key;
            var proto = LEXICON.p;
            var hasOwnProperty = Object[proto].hasOwnProperty;
            var hasOwnConstructor = hasOwnProperty.call(obj, "constructor");
            var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], "isPrototypeOf");
            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
              return false;
            }
            for (key in obj) {
            }
            return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
          }
          ;
          function each(obj, callback) {
            var i = 0;
            if (isArrayLike(obj)) {
              for (; i < obj[LEXICON.l]; i++) {
                if (callback.call(obj[i], i, obj[i]) === false)
                  break;
              }
            } else {
              for (i in obj) {
                if (callback.call(obj[i], i, obj[i]) === false)
                  break;
              }
            }
            return obj;
          }
          ;
          function isArrayLike(obj) {
            var length2 = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];
            var t = _type(obj);
            return isFunction(t) ? false : t == TYPES.a || length2 === 0 || _type(length2) == TYPES.n && length2 > 0 && length2 - 1 in obj;
          }
          function stripAndCollapse(value) {
            var tokens = value.match(_rnothtmlwhite) || [];
            return tokens.join(_strSpace);
          }
          function matches(elem, selector) {
            var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];
            var i = nodeList[LEXICON.l];
            while (i--)
              if (nodeList[i] == elem)
                return true;
            return false;
          }
          function insertAdjacentElement(el, strategy, child) {
            if (COMPATIBILITY.isA(child)) {
              for (var i = 0; i < child[LEXICON.l]; i++)
                insertAdjacentElement(el, strategy, child[i]);
            } else if (_type(child) == TYPES.s)
              el.insertAdjacentHTML(strategy, child);
            else
              el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
          }
          function setCSSVal(el, prop, val) {
            try {
              if (el[LEXICON.s][prop] !== undefined2)
                el[LEXICON.s][prop] = parseCSSVal(prop, val);
            } catch (e) {
            }
          }
          function parseCSSVal(prop, val) {
            if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)
              val += "px";
            return val;
          }
          function startNextAnimationInQ(animObj, removeFromQ) {
            var index;
            var nextAnim;
            if (removeFromQ !== false)
              animObj.q.splice(0, 1);
            if (animObj.q[LEXICON.l] > 0) {
              nextAnim = animObj.q[0];
              animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
            } else {
              index = inArray(animObj, _animations);
              if (index > -1)
                _animations.splice(index, 1);
            }
          }
          function setAnimationValue(el, prop, value) {
            if (prop === _strScrollLeft || prop === _strScrollTop)
              el[prop] = value;
            else
              setCSSVal(el, prop, value);
          }
          function animate(el, props, options, easing, complete, guaranteedNext) {
            var hasOptions = isPlainObject(options);
            var from = {};
            var to = {};
            var i = 0;
            var key;
            var animObj;
            var start;
            var progress;
            var step;
            var specialEasing;
            var duration;
            if (hasOptions) {
              easing = options.easing;
              start = options.start;
              progress = options.progress;
              step = options.step;
              specialEasing = options.specialEasing;
              complete = options.complete;
              duration = options.duration;
            } else
              duration = options;
            specialEasing = specialEasing || {};
            duration = duration || 400;
            easing = easing || "swing";
            guaranteedNext = guaranteedNext || false;
            for (; i < _animations[LEXICON.l]; i++) {
              if (_animations[i].el === el) {
                animObj = _animations[i];
                break;
              }
            }
            if (!animObj) {
              animObj = {
                el,
                q: []
              };
              _animations.push(animObj);
            }
            for (key in props) {
              if (key === _strScrollLeft || key === _strScrollTop)
                from[key] = el[key];
              else
                from[key] = FakejQuery(el).css(key);
            }
            for (key in from) {
              if (from[key] !== props[key] && props[key] !== undefined2)
                to[key] = props[key];
            }
            if (!isEmptyObject(to)) {
              var timeNow;
              var end;
              var percent;
              var fromVal;
              var toVal;
              var easedVal;
              var timeStart;
              var frame;
              var elapsed;
              var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
              var qObj = {
                props: to,
                duration: hasOptions ? options : duration,
                easing,
                complete
              };
              if (qPos === -1) {
                qPos = animObj.q[LEXICON.l];
                animObj.q.push(qObj);
              }
              if (qPos === 0) {
                if (duration > 0) {
                  timeStart = COMPATIBILITY.now();
                  frame = function() {
                    timeNow = COMPATIBILITY.now();
                    elapsed = timeNow - timeStart;
                    end = qObj.stop || elapsed >= duration;
                    percent = 1 - (MATH.max(0, timeStart + duration - timeNow) / duration || 0);
                    for (key in to) {
                      fromVal = parseFloat(from[key]);
                      toVal = parseFloat(to[key]);
                      easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;
                      setAnimationValue(el, key, easedVal);
                      if (isFunction(step)) {
                        step(easedVal, {
                          elem: el,
                          prop: key,
                          start: fromVal,
                          now: easedVal,
                          end: toVal,
                          pos: percent,
                          options: {
                            easing,
                            speacialEasing: specialEasing,
                            duration,
                            complete,
                            step
                          },
                          startTime: timeStart
                        });
                      }
                    }
                    if (isFunction(progress))
                      progress({}, percent, MATH.max(0, duration - elapsed));
                    if (end) {
                      startNextAnimationInQ(animObj);
                      if (isFunction(complete))
                        complete();
                    } else
                      qObj.frame = COMPATIBILITY.rAF()(frame);
                  };
                  qObj.frame = COMPATIBILITY.rAF()(frame);
                } else {
                  for (key in to)
                    setAnimationValue(el, key, to[key]);
                  startNextAnimationInQ(animObj);
                }
              }
            } else if (guaranteedNext)
              startNextAnimationInQ(animObj);
          }
          function stop(el, clearQ, jumpToEnd) {
            var animObj;
            var qObj;
            var key;
            var i = 0;
            for (; i < _animations[LEXICON.l]; i++) {
              animObj = _animations[i];
              if (animObj.el === el) {
                if (animObj.q[LEXICON.l] > 0) {
                  qObj = animObj.q[0];
                  qObj.stop = true;
                  COMPATIBILITY.cAF()(qObj.frame);
                  animObj.q.splice(0, 1);
                  if (jumpToEnd)
                    for (key in qObj.props)
                      setAnimationValue(el, key, qObj.props[key]);
                  if (clearQ)
                    animObj.q = [];
                  else
                    startNextAnimationInQ(animObj, false);
                }
                break;
              }
            }
          }
          function elementIsVisible(el) {
            return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
          }
          function FakejQuery(selector) {
            if (arguments[LEXICON.l] === 0)
              return this;
            var base = new FakejQuery();
            var elements = selector;
            var i = 0;
            var elms;
            var el;
            if (_type(selector) == TYPES.s) {
              elements = [];
              if (selector.charAt(0) === "<") {
                el = document.createElement("div");
                el.innerHTML = selector;
                elms = el.children;
              } else {
                elms = document.querySelectorAll(selector);
              }
              for (; i < elms[LEXICON.l]; i++)
                elements.push(elms[i]);
            }
            if (elements) {
              if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window2 || elements === elements.self))
                elements = [elements];
              for (i = 0; i < elements[LEXICON.l]; i++)
                base[i] = elements[i];
              base[LEXICON.l] = elements[LEXICON.l];
            }
            return base;
          }
          ;
          FakejQuery[LEXICON.p] = {
            on: function(eventName, handler) {
              eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
              var eventNameLength = eventName[LEXICON.l];
              var i = 0;
              var el;
              return this.each(function() {
                el = this;
                try {
                  if (el.addEventListener) {
                    for (; i < eventNameLength; i++)
                      el.addEventListener(eventName[i], handler);
                  } else if (el.detachEvent) {
                    for (; i < eventNameLength; i++)
                      el.attachEvent("on" + eventName[i], handler);
                  }
                } catch (e) {
                }
              });
            },
            off: function(eventName, handler) {
              eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
              var eventNameLength = eventName[LEXICON.l];
              var i = 0;
              var el;
              return this.each(function() {
                el = this;
                try {
                  if (el.removeEventListener) {
                    for (; i < eventNameLength; i++)
                      el.removeEventListener(eventName[i], handler);
                  } else if (el.detachEvent) {
                    for (; i < eventNameLength; i++)
                      el.detachEvent("on" + eventName[i], handler);
                  }
                } catch (e) {
                }
              });
            },
            one: function(eventName, handler) {
              eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
              return this.each(function() {
                var el = FakejQuery(this);
                FakejQuery.each(eventName, function(i, oneEventName) {
                  var oneHandler = function(e) {
                    handler.call(this, e);
                    el.off(oneEventName, oneHandler);
                  };
                  el.on(oneEventName, oneHandler);
                });
              });
            },
            trigger: function(eventName) {
              var el;
              var event;
              return this.each(function() {
                el = this;
                if (document.createEvent) {
                  event = document.createEvent("HTMLEvents");
                  event.initEvent(eventName, true, false);
                  el.dispatchEvent(event);
                } else {
                  el.fireEvent("on" + eventName);
                }
              });
            },
            append: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "beforeend", child);
              });
            },
            prepend: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "afterbegin", child);
              });
            },
            before: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "beforebegin", child);
              });
            },
            after: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "afterend", child);
              });
            },
            remove: function() {
              return this.each(function() {
                var el = this;
                var parentNode = el.parentNode;
                if (parentNode != null)
                  parentNode.removeChild(el);
              });
            },
            unwrap: function() {
              var parents = [];
              var i;
              var el;
              var parent;
              this.each(function() {
                parent = this.parentNode;
                if (inArray(parent, parents) === -1)
                  parents.push(parent);
              });
              for (i = 0; i < parents[LEXICON.l]; i++) {
                el = parents[i];
                parent = el.parentNode;
                while (el.firstChild)
                  parent.insertBefore(el.firstChild, el);
                parent.removeChild(el);
              }
              return this;
            },
            wrapAll: function(wrapperHTML) {
              var i;
              var nodes = this;
              var wrapper = FakejQuery(wrapperHTML)[0];
              var deepest = wrapper;
              var parent = nodes[0].parentNode;
              var previousSibling = nodes[0].previousSibling;
              while (deepest.childNodes[LEXICON.l] > 0)
                deepest = deepest.childNodes[0];
              for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)
                deepest.appendChild(nodes[i]);
              var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
              parent.insertBefore(wrapper, nextSibling);
              return this;
            },
            wrapInner: function(wrapperHTML) {
              return this.each(function() {
                var el = FakejQuery(this);
                var contents = el.contents();
                if (contents[LEXICON.l])
                  contents.wrapAll(wrapperHTML);
                else
                  el.append(wrapperHTML);
              });
            },
            wrap: function(wrapperHTML) {
              return this.each(function() {
                FakejQuery(this).wrapAll(wrapperHTML);
              });
            },
            css: function(styles, val) {
              var el;
              var key;
              var cptStyle;
              var getCptStyle = window2.getComputedStyle;
              if (_type(styles) == TYPES.s) {
                if (val === undefined2) {
                  el = this[0];
                  cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];
                  return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;
                } else {
                  return this.each(function() {
                    setCSSVal(this, styles, val);
                  });
                }
              } else {
                return this.each(function() {
                  for (key in styles)
                    setCSSVal(this, key, styles[key]);
                });
              }
            },
            hasClass: function(className) {
              var elem, i = 0;
              var classNamePrepared = _strSpace + className + _strSpace;
              var classList;
              while (elem = this[i++]) {
                classList = elem.classList;
                if (classList && classList.contains(className))
                  return true;
                else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
                  return true;
              }
              return false;
            },
            addClass: function(className) {
              var classes;
              var elem;
              var cur;
              var curValue;
              var clazz;
              var finalValue;
              var supportClassList;
              var elmClassList;
              var i = 0;
              var v = 0;
              if (className) {
                classes = className.match(_rnothtmlwhite) || [];
                while (elem = this[i++]) {
                  elmClassList = elem.classList;
                  if (supportClassList === undefined2)
                    supportClassList = elmClassList !== undefined2;
                  if (supportClassList) {
                    while (clazz = classes[v++])
                      elmClassList.add(clazz);
                  } else {
                    curValue = elem.className + _strEmpty;
                    cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;
                    if (cur) {
                      while (clazz = classes[v++])
                        if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)
                          cur += clazz + _strSpace;
                      finalValue = stripAndCollapse(cur);
                      if (curValue !== finalValue)
                        elem.className = finalValue;
                    }
                  }
                }
              }
              return this;
            },
            removeClass: function(className) {
              var classes;
              var elem;
              var cur;
              var curValue;
              var clazz;
              var finalValue;
              var supportClassList;
              var elmClassList;
              var i = 0;
              var v = 0;
              if (className) {
                classes = className.match(_rnothtmlwhite) || [];
                while (elem = this[i++]) {
                  elmClassList = elem.classList;
                  if (supportClassList === undefined2)
                    supportClassList = elmClassList !== undefined2;
                  if (supportClassList) {
                    while (clazz = classes[v++])
                      elmClassList.remove(clazz);
                  } else {
                    curValue = elem.className + _strEmpty;
                    cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;
                    if (cur) {
                      while (clazz = classes[v++])
                        while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)
                          cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);
                      finalValue = stripAndCollapse(cur);
                      if (curValue !== finalValue)
                        elem.className = finalValue;
                    }
                  }
                }
              }
              return this;
            },
            hide: function() {
              return this.each(function() {
                this[LEXICON.s].display = "none";
              });
            },
            show: function() {
              return this.each(function() {
                this[LEXICON.s].display = "block";
              });
            },
            attr: function(attrName, value) {
              var i = 0;
              var el;
              while (el = this[i++]) {
                if (value === undefined2)
                  return el.getAttribute(attrName);
                el.setAttribute(attrName, value);
              }
              return this;
            },
            removeAttr: function(attrName) {
              return this.each(function() {
                this.removeAttribute(attrName);
              });
            },
            offset: function() {
              var el = this[0];
              var rect = el[LEXICON.bCR]();
              var scrollLeft = window2.pageXOffset || document.documentElement[_strScrollLeft];
              var scrollTop = window2.pageYOffset || document.documentElement[_strScrollTop];
              return {
                top: rect.top + scrollTop,
                left: rect.left + scrollLeft
              };
            },
            position: function() {
              var el = this[0];
              return {
                top: el.offsetTop,
                left: el.offsetLeft
              };
            },
            scrollLeft: function(value) {
              var i = 0;
              var el;
              while (el = this[i++]) {
                if (value === undefined2)
                  return el[_strScrollLeft];
                el[_strScrollLeft] = value;
              }
              return this;
            },
            scrollTop: function(value) {
              var i = 0;
              var el;
              while (el = this[i++]) {
                if (value === undefined2)
                  return el[_strScrollTop];
                el[_strScrollTop] = value;
              }
              return this;
            },
            val: function(value) {
              var el = this[0];
              if (!value)
                return el.value;
              el.value = value;
              return this;
            },
            first: function() {
              return this.eq(0);
            },
            last: function() {
              return this.eq(-1);
            },
            eq: function(index) {
              return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);
            },
            find: function(selector) {
              var children = [];
              var i;
              this.each(function() {
                var el = this;
                var ch = el.querySelectorAll(selector);
                for (i = 0; i < ch[LEXICON.l]; i++)
                  children.push(ch[i]);
              });
              return FakejQuery(children);
            },
            children: function(selector) {
              var children = [];
              var el;
              var ch;
              var i;
              this.each(function() {
                ch = this.children;
                for (i = 0; i < ch[LEXICON.l]; i++) {
                  el = ch[i];
                  if (selector) {
                    if (el.matches && el.matches(selector) || matches(el, selector))
                      children.push(el);
                  } else
                    children.push(el);
                }
              });
              return FakejQuery(children);
            },
            parent: function(selector) {
              var parents = [];
              var parent;
              this.each(function() {
                parent = this.parentNode;
                if (selector ? FakejQuery(parent).is(selector) : true)
                  parents.push(parent);
              });
              return FakejQuery(parents);
            },
            is: function(selector) {
              var el;
              var i;
              for (i = 0; i < this[LEXICON.l]; i++) {
                el = this[i];
                if (selector === ":visible")
                  return elementIsVisible(el);
                if (selector === ":hidden")
                  return !elementIsVisible(el);
                if (el.matches && el.matches(selector) || matches(el, selector))
                  return true;
              }
              return false;
            },
            contents: function() {
              var contents = [];
              var childs;
              var i;
              this.each(function() {
                childs = this.childNodes;
                for (i = 0; i < childs[LEXICON.l]; i++)
                  contents.push(childs[i]);
              });
              return FakejQuery(contents);
            },
            each: function(callback) {
              return each(this, callback);
            },
            animate: function(props, duration, easing, complete) {
              return this.each(function() {
                animate(this, props, duration, easing, complete);
              });
            },
            stop: function(clearQ, jump) {
              return this.each(function() {
                stop(this, clearQ, jump);
              });
            }
          };
          extend(FakejQuery, {
            extend,
            inArray,
            isEmptyObject,
            isPlainObject,
            each
          });
          return FakejQuery;
        }();
        var INSTANCES = function() {
          var _targets = [];
          var _instancePropertyString = "__overlayScrollbars__";
          return function(target, instance) {
            var argLen = arguments[LEXICON.l];
            if (argLen < 1) {
              return _targets;
            } else {
              if (instance) {
                target[_instancePropertyString] = instance;
                _targets.push(target);
              } else {
                var index = COMPATIBILITY.inA(target, _targets);
                if (index > -1) {
                  if (argLen > 1) {
                    delete target[_instancePropertyString];
                    _targets.splice(index, 1);
                  } else {
                    return _targets[index][_instancePropertyString];
                  }
                }
              }
            }
          };
        }();
        var PLUGIN = function() {
          var _plugin;
          var _pluginsGlobals;
          var _pluginsAutoUpdateLoop;
          var _pluginsExtensions = [];
          var _pluginsOptions = function() {
            var type = COMPATIBILITY.type;
            var possibleTemplateTypes = [
              TYPES.b,
              TYPES.n,
              TYPES.s,
              TYPES.a,
              TYPES.o,
              TYPES.f,
              TYPES.z
            ];
            var restrictedStringsSplit = " ";
            var restrictedStringsPossibilitiesSplit = ":";
            var classNameAllowedValues = [TYPES.z, TYPES.s];
            var numberAllowedValues = TYPES.n;
            var booleanNullAllowedValues = [TYPES.z, TYPES.b];
            var booleanTrueTemplate = [true, TYPES.b];
            var booleanFalseTemplate = [false, TYPES.b];
            var callbackTemplate = [null, [TYPES.z, TYPES.f]];
            var updateOnLoadTemplate = [["img"], [TYPES.s, TYPES.a, TYPES.z]];
            var inheritedAttrsTemplate = [["style", "class"], [TYPES.s, TYPES.a, TYPES.z]];
            var resizeAllowedValues = "n:none b:both h:horizontal v:vertical";
            var overflowBehaviorAllowedValues = "v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden";
            var scrollbarsVisibilityAllowedValues = "v:visible h:hidden a:auto";
            var scrollbarsAutoHideAllowedValues = "n:never s:scroll l:leave m:move";
            var optionsDefaultsAndTemplate = {
              className: ["os-theme-dark", classNameAllowedValues],
              resize: ["none", resizeAllowedValues],
              sizeAutoCapable: booleanTrueTemplate,
              clipAlways: booleanTrueTemplate,
              normalizeRTL: booleanTrueTemplate,
              paddingAbsolute: booleanFalseTemplate,
              autoUpdate: [null, booleanNullAllowedValues],
              autoUpdateInterval: [33, numberAllowedValues],
              updateOnLoad: updateOnLoadTemplate,
              nativeScrollbarsOverlaid: {
                showNativeScrollbars: booleanFalseTemplate,
                initialize: booleanTrueTemplate
              },
              overflowBehavior: {
                x: ["scroll", overflowBehaviorAllowedValues],
                y: ["scroll", overflowBehaviorAllowedValues]
              },
              scrollbars: {
                visibility: ["auto", scrollbarsVisibilityAllowedValues],
                autoHide: ["never", scrollbarsAutoHideAllowedValues],
                autoHideDelay: [800, numberAllowedValues],
                dragScrolling: booleanTrueTemplate,
                clickScrolling: booleanFalseTemplate,
                touchSupport: booleanTrueTemplate,
                snapHandle: booleanFalseTemplate
              },
              textarea: {
                dynWidth: booleanFalseTemplate,
                dynHeight: booleanFalseTemplate,
                inheritedAttrs: inheritedAttrsTemplate
              },
              callbacks: {
                onInitialized: callbackTemplate,
                onInitializationWithdrawn: callbackTemplate,
                onDestroyed: callbackTemplate,
                onScrollStart: callbackTemplate,
                onScroll: callbackTemplate,
                onScrollStop: callbackTemplate,
                onOverflowChanged: callbackTemplate,
                onOverflowAmountChanged: callbackTemplate,
                onDirectionChanged: callbackTemplate,
                onContentSizeChanged: callbackTemplate,
                onHostSizeChanged: callbackTemplate,
                onUpdated: callbackTemplate
              }
            };
            var convert = function(template) {
              var recursive = function(obj) {
                var key;
                var val;
                var valType;
                for (key in obj) {
                  if (!obj[LEXICON.hOP](key))
                    continue;
                  val = obj[key];
                  valType = type(val);
                  if (valType == TYPES.a)
                    obj[key] = val[template ? 1 : 0];
                  else if (valType == TYPES.o)
                    obj[key] = recursive(val);
                }
                return obj;
              };
              return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
            };
            return {
              _defaults: convert(),
              _template: convert(true),
              _validate: function(obj, template, writeErrors, diffObj) {
                var validatedOptions = {};
                var validatedOptionsPrepared = {};
                var objectCopy = FRAMEWORK.extend(true, {}, obj);
                var inArray = FRAMEWORK.inArray;
                var isEmptyObj = FRAMEWORK.isEmptyObject;
                var checkObjectProps = function(data, template2, diffData, validatedOptions2, validatedOptionsPrepared2, prevPropName) {
                  for (var prop in template2) {
                    if (template2[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                      var isValid = false;
                      var isDiff = false;
                      var templateValue = template2[prop];
                      var templateValueType = type(templateValue);
                      var templateIsComplex = templateValueType == TYPES.o;
                      var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                      var dataDiffValue = diffData[prop];
                      var dataValue = data[prop];
                      var dataValueType = type(dataValue);
                      var propPrefix = prevPropName ? prevPropName + "." : "";
                      var error = 'The option "' + propPrefix + prop + `" wasn't set, because`;
                      var errorPossibleTypes = [];
                      var errorRestrictedStrings = [];
                      var restrictedStringValuesSplit;
                      var restrictedStringValuesPossibilitiesSplit;
                      var isRestrictedValue;
                      var mainPossibility;
                      var currType;
                      var i;
                      var v;
                      var j;
                      dataDiffValue = dataDiffValue === undefined2 ? {} : dataDiffValue;
                      if (templateIsComplex && dataValueType == TYPES.o) {
                        validatedOptions2[prop] = {};
                        validatedOptionsPrepared2[prop] = {};
                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions2[prop], validatedOptionsPrepared2[prop], propPrefix + prop);
                        FRAMEWORK.each([data, validatedOptions2, validatedOptionsPrepared2], function(index, value) {
                          if (isEmptyObj(value[prop])) {
                            delete value[prop];
                          }
                        });
                      } else if (!templateIsComplex) {
                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                          currType = templateTypes[i];
                          templateValueType = type(currType);
                          isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                          if (isRestrictedValue) {
                            errorPossibleTypes.push(TYPES.s);
                            restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                            errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                            for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                              restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                              mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                              for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                  isValid = true;
                                  break;
                                }
                              }
                              if (isValid)
                                break;
                            }
                          } else {
                            errorPossibleTypes.push(currType);
                            if (dataValueType === currType) {
                              isValid = true;
                              break;
                            }
                          }
                        }
                        if (isValid) {
                          isDiff = dataValue !== dataDiffValue;
                          if (isDiff)
                            validatedOptions2[prop] = dataValue;
                          if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                            validatedOptionsPrepared2[prop] = isRestrictedValue ? mainPossibility : dataValue;
                        } else if (writeErrors) {
                          console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + ' ] with the value of "' + dataValue + '".\r\nAccepted types are: [ ' + errorPossibleTypes.join(", ").toUpperCase() + " ]." + (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(", ").split(restrictedStringsPossibilitiesSplit).join(", ") + " ]." : ""));
                        }
                        delete data[prop];
                      }
                    }
                  }
                };
                checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);
                if (!isEmptyObj(objectCopy) && writeErrors)
                  console.warn("The following options are discarded due to invalidity:\r\n" + window2.JSON.stringify(objectCopy, null, 2));
                return {
                  _default: validatedOptions,
                  _prepared: validatedOptionsPrepared
                };
              }
            };
          }();
          function initOverlayScrollbarsStatics() {
            if (!_pluginsGlobals)
              _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
            if (!_pluginsAutoUpdateLoop)
              _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
          }
          function OverlayScrollbarsGlobals(defaultOptions) {
            var _base = this;
            var strOverflow = "overflow";
            var strHidden = "hidden";
            var strScroll = "scroll";
            var bodyElement = FRAMEWORK("body");
            var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
            var scrollbarDummyElement0 = scrollbarDummyElement[0];
            var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children("div").eq(0));
            bodyElement.append(scrollbarDummyElement);
            scrollbarDummyElement.hide().show();
            var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
            var nativeScrollbarIsOverlaid = {
              x: nativeScrollbarSize.x === 0,
              y: nativeScrollbarSize.y === 0
            };
            var msie = function() {
              var ua = window2.navigator.userAgent;
              var strIndexOf = "indexOf";
              var strSubString = "substring";
              var msie2 = ua[strIndexOf]("MSIE ");
              var trident = ua[strIndexOf]("Trident/");
              var edge = ua[strIndexOf]("Edge/");
              var rv = ua[strIndexOf]("rv:");
              var result;
              var parseIntFunc = parseInt;
              if (msie2 > 0)
                result = parseIntFunc(ua[strSubString](msie2 + 5, ua[strIndexOf](".", msie2)), 10);
              else if (trident > 0)
                result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf](".", rv)), 10);
              else if (edge > 0)
                result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf](".", edge)), 10);
              return result;
            }();
            FRAMEWORK.extend(_base, {
              defaultOptions,
              msie,
              autoUpdateLoop: false,
              autoUpdateRecommended: !COMPATIBILITY.mO(),
              nativeScrollbarSize,
              nativeScrollbarIsOverlaid,
              nativeScrollbarStyling: function() {
                var result = false;
                scrollbarDummyElement.addClass("os-viewport-native-scrollbars-invisible");
                try {
                  result = scrollbarDummyElement.css("scrollbar-width") === "none" && (msie > 9 || !msie) || window2.getComputedStyle(scrollbarDummyElement0, "::-webkit-scrollbar").getPropertyValue("display") === "none";
                } catch (ex) {
                }
                return result;
              }(),
              overlayScrollbarDummySize: { x: 30, y: 30 },
              cssCalc: VENDORS._cssPropertyValue("width", "calc", "(1px)") || null,
              restrictedMeasuring: function() {
                scrollbarDummyElement.css(strOverflow, strHidden);
                var scrollSize = {
                  w: scrollbarDummyElement0[LEXICON.sW],
                  h: scrollbarDummyElement0[LEXICON.sH]
                };
                scrollbarDummyElement.css(strOverflow, "visible");
                var scrollSize2 = {
                  w: scrollbarDummyElement0[LEXICON.sW],
                  h: scrollbarDummyElement0[LEXICON.sH]
                };
                return scrollSize.w - scrollSize2.w !== 0 || scrollSize.h - scrollSize2.h !== 0;
              }(),
              rtlScrollBehavior: function() {
                scrollbarDummyElement.css({ "overflow-y": strHidden, "overflow-x": strScroll, "direction": "rtl" }).scrollLeft(0);
                var dummyContainerOffset = scrollbarDummyElement.offset();
                var dummyContainerChildOffset = dummyContainerChild.offset();
                scrollbarDummyElement.scrollLeft(-999);
                var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
                return {
                  i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                  n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
                };
              }(),
              supportTransform: !!VENDORS._cssProperty("transform"),
              supportTransition: !!VENDORS._cssProperty("transition"),
              supportPassiveEvents: function() {
                var supportsPassive = false;
                try {
                  window2.addEventListener("test", null, Object.defineProperty({}, "passive", {
                    get: function() {
                      supportsPassive = true;
                    }
                  }));
                } catch (e) {
                }
                return supportsPassive;
              }(),
              supportResizeObserver: !!COMPATIBILITY.rO(),
              supportMutationObserver: !!COMPATIBILITY.mO()
            });
            scrollbarDummyElement.removeAttr(LEXICON.s).remove();
            (function() {
              if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                return;
              var abs = MATH.abs;
              var windowWidth = COMPATIBILITY.wW();
              var windowHeight = COMPATIBILITY.wH();
              var windowDpr = getWindowDPR();
              var onResize = function() {
                if (INSTANCES().length > 0) {
                  var newW = COMPATIBILITY.wW();
                  var newH = COMPATIBILITY.wH();
                  var deltaW = newW - windowWidth;
                  var deltaH = newH - windowHeight;
                  if (deltaW === 0 && deltaH === 0)
                    return;
                  var deltaWRatio = MATH.round(newW / (windowWidth / 100));
                  var deltaHRatio = MATH.round(newH / (windowHeight / 100));
                  var absDeltaW = abs(deltaW);
                  var absDeltaH = abs(deltaH);
                  var absDeltaWRatio = abs(deltaWRatio);
                  var absDeltaHRatio = abs(deltaHRatio);
                  var newDPR = getWindowDPR();
                  var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                  var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                  var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                  var isZoom = deltaIsBigger && difference && dprChanged;
                  var oldScrollbarSize = _base.nativeScrollbarSize;
                  var newScrollbarSize;
                  if (isZoom) {
                    bodyElement.append(scrollbarDummyElement);
                    newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                    scrollbarDummyElement.remove();
                    if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                      FRAMEWORK.each(INSTANCES(), function() {
                        if (INSTANCES(this))
                          INSTANCES(this).update("zoom");
                      });
                    }
                  }
                  windowWidth = newW;
                  windowHeight = newH;
                  windowDpr = newDPR;
                }
              };
              function differenceIsBiggerThanOne(valOne, valTwo) {
                var absValOne = abs(valOne);
                var absValTwo = abs(valTwo);
                return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
              }
              function getWindowDPR() {
                var dDPI = window2.screen.deviceXDPI || 0;
                var sDPI = window2.screen.logicalXDPI || 1;
                return window2.devicePixelRatio || dDPI / sDPI;
              }
              FRAMEWORK(window2).on("resize", onResize);
            })();
            function calcNativeScrollbarSize(measureElement) {
              return {
                x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
              };
            }
          }
          function OverlayScrollbarsAutoUpdateLoop(globals) {
            var _base = this;
            var _inArray = FRAMEWORK.inArray;
            var _getNow = COMPATIBILITY.now;
            var _strAutoUpdate = "autoUpdate";
            var _strAutoUpdateInterval = _strAutoUpdate + "Interval";
            var _strLength = LEXICON.l;
            var _loopingInstances = [];
            var _loopingInstancesIntervalCache = [];
            var _loopIsActive = false;
            var _loopIntervalDefault = 33;
            var _loopInterval = _loopIntervalDefault;
            var _loopTimeOld = _getNow();
            var _loopID;
            var loop = function() {
              if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                _loopID = COMPATIBILITY.rAF()(function() {
                  loop();
                });
                var timeNew = _getNow();
                var timeDelta = timeNew - _loopTimeOld;
                var lowestInterval;
                var instance;
                var instanceOptions;
                var instanceAutoUpdateAllowed;
                var instanceAutoUpdateInterval;
                var now;
                if (timeDelta > _loopInterval) {
                  _loopTimeOld = timeNew - timeDelta % _loopInterval;
                  lowestInterval = _loopIntervalDefault;
                  for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                    instance = _loopingInstances[i];
                    if (instance !== undefined2) {
                      instanceOptions = instance.options();
                      instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                      instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                      now = _getNow();
                      if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && now - _loopingInstancesIntervalCache[i] > instanceAutoUpdateInterval) {
                        instance.update("auto");
                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                      }
                      lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                    }
                  }
                  _loopInterval = lowestInterval;
                }
              } else {
                _loopInterval = _loopIntervalDefault;
              }
            };
            _base.add = function(instance) {
              if (_inArray(instance, _loopingInstances) === -1) {
                _loopingInstances.push(instance);
                _loopingInstancesIntervalCache.push(_getNow());
                if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                  _loopIsActive = true;
                  globals.autoUpdateLoop = _loopIsActive;
                  loop();
                }
              }
            };
            _base.remove = function(instance) {
              var index = _inArray(instance, _loopingInstances);
              if (index > -1) {
                _loopingInstancesIntervalCache.splice(index, 1);
                _loopingInstances.splice(index, 1);
                if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                  _loopIsActive = false;
                  globals.autoUpdateLoop = _loopIsActive;
                  if (_loopID !== undefined2) {
                    COMPATIBILITY.cAF()(_loopID);
                    _loopID = -1;
                  }
                }
              }
            };
          }
          function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
            var type = COMPATIBILITY.type;
            var inArray = FRAMEWORK.inArray;
            var each = FRAMEWORK.each;
            var _base = new _plugin();
            var _frameworkProto = FRAMEWORK[LEXICON.p];
            if (!isHTMLElement(pluginTargetElement))
              return;
            if (INSTANCES(pluginTargetElement)) {
              var inst = INSTANCES(pluginTargetElement);
              inst.options(options);
              return inst;
            }
            var _nativeScrollbarIsOverlaid;
            var _overlayScrollbarDummySize;
            var _rtlScrollBehavior;
            var _autoUpdateRecommended;
            var _msieVersion;
            var _nativeScrollbarStyling;
            var _cssCalc;
            var _nativeScrollbarSize;
            var _supportTransition;
            var _supportTransform;
            var _supportPassiveEvents;
            var _supportResizeObserver;
            var _supportMutationObserver;
            var _restrictedMeasuring;
            var _initialized;
            var _destroyed;
            var _isTextarea;
            var _isBody;
            var _documentMixed;
            var _domExists;
            var _isBorderBox;
            var _sizeAutoObserverAdded;
            var _paddingX;
            var _paddingY;
            var _borderX;
            var _borderY;
            var _marginX;
            var _marginY;
            var _isRTL;
            var _sleeping;
            var _contentBorderSize = {};
            var _scrollHorizontalInfo = {};
            var _scrollVerticalInfo = {};
            var _viewportSize = {};
            var _nativeScrollbarMinSize = {};
            var _strMinusHidden = "-hidden";
            var _strMarginMinus = "margin-";
            var _strPaddingMinus = "padding-";
            var _strBorderMinus = "border-";
            var _strTop = "top";
            var _strRight = "right";
            var _strBottom = "bottom";
            var _strLeft = "left";
            var _strMinMinus = "min-";
            var _strMaxMinus = "max-";
            var _strWidth = "width";
            var _strHeight = "height";
            var _strFloat = "float";
            var _strEmpty = "";
            var _strAuto = "auto";
            var _strSync = "sync";
            var _strScroll = "scroll";
            var _strHundredPercent = "100%";
            var _strX = "x";
            var _strY = "y";
            var _strDot = ".";
            var _strSpace = " ";
            var _strScrollbar = "scrollbar";
            var _strMinusHorizontal = "-horizontal";
            var _strMinusVertical = "-vertical";
            var _strScrollLeft = _strScroll + "Left";
            var _strScrollTop = _strScroll + "Top";
            var _strMouseTouchDownEvent = "mousedown touchstart";
            var _strMouseTouchUpEvent = "mouseup touchend touchcancel";
            var _strMouseTouchMoveEvent = "mousemove touchmove";
            var _strMouseEnter = "mouseenter";
            var _strMouseLeave = "mouseleave";
            var _strKeyDownEvent = "keydown";
            var _strKeyUpEvent = "keyup";
            var _strSelectStartEvent = "selectstart";
            var _strTransitionEndEvent = "transitionend webkitTransitionEnd oTransitionEnd";
            var _strResizeObserverProperty = "__overlayScrollbarsRO__";
            var _cassNamesPrefix = "os-";
            var _classNameHTMLElement = _cassNamesPrefix + "html";
            var _classNameHostElement = _cassNamesPrefix + "host";
            var _classNameHostElementForeign = _classNameHostElement + "-foreign";
            var _classNameHostTextareaElement = _classNameHostElement + "-textarea";
            var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
            var _classNameHostScrollbarVerticalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusVertical + _strMinusHidden;
            var _classNameHostTransition = _classNameHostElement + "-transition";
            var _classNameHostRTL = _classNameHostElement + "-rtl";
            var _classNameHostResizeDisabled = _classNameHostElement + "-resize-disabled";
            var _classNameHostScrolling = _classNameHostElement + "-scrolling";
            var _classNameHostOverflow = _classNameHostElement + "-overflow";
            var _classNameHostOverflow = _classNameHostElement + "-overflow";
            var _classNameHostOverflowX = _classNameHostOverflow + "-x";
            var _classNameHostOverflowY = _classNameHostOverflow + "-y";
            var _classNameTextareaElement = _cassNamesPrefix + "textarea";
            var _classNameTextareaCoverElement = _classNameTextareaElement + "-cover";
            var _classNamePaddingElement = _cassNamesPrefix + "padding";
            var _classNameViewportElement = _cassNamesPrefix + "viewport";
            var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + "-native-scrollbars-invisible";
            var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + "-native-scrollbars-overlaid";
            var _classNameContentElement = _cassNamesPrefix + "content";
            var _classNameContentArrangeElement = _cassNamesPrefix + "content-arrange";
            var _classNameContentGlueElement = _cassNamesPrefix + "content-glue";
            var _classNameSizeAutoObserverElement = _cassNamesPrefix + "size-auto-observer";
            var _classNameResizeObserverElement = _cassNamesPrefix + "resize-observer";
            var _classNameResizeObserverItemElement = _cassNamesPrefix + "resize-observer-item";
            var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + "-final";
            var _classNameTextInherit = _cassNamesPrefix + "text-inherit";
            var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
            var _classNameScrollbarTrack = _classNameScrollbar + "-track";
            var _classNameScrollbarTrackOff = _classNameScrollbarTrack + "-off";
            var _classNameScrollbarHandle = _classNameScrollbar + "-handle";
            var _classNameScrollbarHandleOff = _classNameScrollbarHandle + "-off";
            var _classNameScrollbarUnusable = _classNameScrollbar + "-unusable";
            var _classNameScrollbarAutoHidden = _classNameScrollbar + "-" + _strAuto + _strMinusHidden;
            var _classNameScrollbarCorner = _classNameScrollbar + "-corner";
            var _classNameScrollbarCornerResize = _classNameScrollbarCorner + "-resize";
            var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + "-both";
            var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
            var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
            var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
            var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
            var _classNameDragging = _cassNamesPrefix + "dragging";
            var _classNameThemeNone = _cassNamesPrefix + "theme-none";
            var _classNamesDynamicDestroy = [
              _classNameViewportNativeScrollbarsInvisible,
              _classNameViewportNativeScrollbarsOverlaid,
              _classNameScrollbarTrackOff,
              _classNameScrollbarHandleOff,
              _classNameScrollbarUnusable,
              _classNameScrollbarAutoHidden,
              _classNameScrollbarCornerResize,
              _classNameScrollbarCornerResizeB,
              _classNameScrollbarCornerResizeH,
              _classNameScrollbarCornerResizeV,
              _classNameDragging
            ].join(_strSpace);
            var _callbacksInitQeueue = [];
            var _viewportAttrsFromTarget = [LEXICON.ti];
            var _defaultOptions;
            var _currentOptions;
            var _currentPreparedOptions;
            var _extensions = {};
            var _extensionsPrivateMethods = "added removed on contract";
            var _lastUpdateTime;
            var _swallowedUpdateHints = {};
            var _swallowedUpdateTimeout;
            var _swallowUpdateLag = 42;
            var _updateOnLoadEventName = "load";
            var _updateOnLoadElms = [];
            var _windowElement;
            var _documentElement;
            var _htmlElement;
            var _bodyElement;
            var _targetElement;
            var _hostElement;
            var _sizeAutoObserverElement;
            var _sizeObserverElement;
            var _paddingElement;
            var _viewportElement;
            var _contentElement;
            var _contentArrangeElement;
            var _contentGlueElement;
            var _textareaCoverElement;
            var _scrollbarCornerElement;
            var _scrollbarHorizontalElement;
            var _scrollbarHorizontalTrackElement;
            var _scrollbarHorizontalHandleElement;
            var _scrollbarVerticalElement;
            var _scrollbarVerticalTrackElement;
            var _scrollbarVerticalHandleElement;
            var _windowElementNative;
            var _documentElementNative;
            var _targetElementNative;
            var _hostElementNative;
            var _sizeAutoObserverElementNative;
            var _sizeObserverElementNative;
            var _paddingElementNative;
            var _viewportElementNative;
            var _contentElementNative;
            var _hostSizeCache;
            var _contentScrollSizeCache;
            var _arrangeContentSizeCache;
            var _hasOverflowCache;
            var _hideOverflowCache;
            var _widthAutoCache;
            var _heightAutoCache;
            var _cssBoxSizingCache;
            var _cssPaddingCache;
            var _cssBorderCache;
            var _cssMarginCache;
            var _cssDirectionCache;
            var _cssDirectionDetectedCache;
            var _paddingAbsoluteCache;
            var _clipAlwaysCache;
            var _contentGlueSizeCache;
            var _overflowBehaviorCache;
            var _overflowAmountCache;
            var _ignoreOverlayScrollbarHidingCache;
            var _autoUpdateCache;
            var _sizeAutoCapableCache;
            var _contentElementScrollSizeChangeDetectedCache;
            var _hostElementSizeChangeDetectedCache;
            var _scrollbarsVisibilityCache;
            var _scrollbarsAutoHideCache;
            var _scrollbarsClickScrollingCache;
            var _scrollbarsDragScrollingCache;
            var _resizeCache;
            var _normalizeRTLCache;
            var _classNameCache;
            var _oldClassName;
            var _textareaAutoWrappingCache;
            var _textareaInfoCache;
            var _textareaSizeCache;
            var _textareaDynHeightCache;
            var _textareaDynWidthCache;
            var _bodyMinSizeCache;
            var _updateAutoCache = {};
            var _mutationObserverHost;
            var _mutationObserverContent;
            var _mutationObserverHostCallback;
            var _mutationObserverContentCallback;
            var _mutationObserversConnected;
            var _mutationObserverAttrsTextarea = ["wrap", "cols", "rows"];
            var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, "open"].concat(_viewportAttrsFromTarget);
            var _destroyEvents = [];
            var _textareaHasFocus;
            var _scrollbarsAutoHideTimeoutId;
            var _scrollbarsAutoHideMoveTimeoutId;
            var _scrollbarsAutoHideDelay;
            var _scrollbarsAutoHideNever;
            var _scrollbarsAutoHideScroll;
            var _scrollbarsAutoHideMove;
            var _scrollbarsAutoHideLeave;
            var _scrollbarsHandleHovered;
            var _scrollbarsHandlesDefineScrollPos;
            var _resizeNone;
            var _resizeBoth;
            var _resizeHorizontal;
            var _resizeVertical;
            function setupResponsiveEventListener(element, eventNames, listener, remove2, passiveOrOptions) {
              var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
              var method = remove2 ? "removeEventListener" : "addEventListener";
              var onOff = remove2 ? "off" : "on";
              var events = collected ? false : eventNames.split(_strSpace);
              var i = 0;
              var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
              var passive = _supportPassiveEvents && (passiveOrOptionsIsObj ? passiveOrOptions._passive : passiveOrOptions) || false;
              var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
              var nativeParam = _supportPassiveEvents ? {
                passive,
                capture
              } : capture;
              if (collected) {
                for (; i < eventNames[LEXICON.l]; i++)
                  setupResponsiveEventListener(element, eventNames[i], listener[i], remove2, passiveOrOptions);
              } else {
                for (; i < events[LEXICON.l]; i++) {
                  if (_supportPassiveEvents) {
                    element[0][method](events[i], listener, nativeParam);
                  } else {
                    element[onOff](events[i], listener);
                  }
                }
              }
            }
            function addDestroyEventListener(element, eventNames, listener, passive) {
              setupResponsiveEventListener(element, eventNames, listener, false, passive);
              _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
            }
            function setupResizeObserver(targetElement, onElementResizedCallback) {
              if (targetElement) {
                var resizeObserver = COMPATIBILITY.rO();
                var strAnimationStartEvent = "animationstart mozAnimationStart webkitAnimationStart MSAnimationStart";
                var strChildNodes = "childNodes";
                var constScroll = 3333333;
                var callback = function() {
                  targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
                  onElementResizedCallback();
                };
                if (onElementResizedCallback) {
                  if (_supportResizeObserver) {
                    var element = targetElement.addClass("observed").append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                    var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                    observer.observe(element);
                  } else {
                    if (_msieVersion > 9 || !_autoUpdateRecommended) {
                      targetElement.prepend(
                        generateDiv(
                          _classNameResizeObserverElement,
                          generateDiv(
                            { c: _classNameResizeObserverItemElement, dir: "ltr" },
                            generateDiv(
                              _classNameResizeObserverItemElement,
                              generateDiv(_classNameResizeObserverItemFinalElement)
                            ) + generateDiv(
                              _classNameResizeObserverItemElement,
                              generateDiv({ c: _classNameResizeObserverItemFinalElement, style: "width: 200%; height: 200%" })
                            )
                          )
                        )
                      );
                      var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                      var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                      var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                      var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                      var widthCache = observerElement[LEXICON.oW];
                      var heightCache = observerElement[LEXICON.oH];
                      var isDirty;
                      var rAFId;
                      var currWidth;
                      var currHeight;
                      var factor = 2;
                      var nativeScrollbarSize = globals.nativeScrollbarSize;
                      var reset = function() {
                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                      };
                      var onResized = function() {
                        rAFId = 0;
                        if (!isDirty)
                          return;
                        widthCache = currWidth;
                        heightCache = currHeight;
                        callback();
                      };
                      var onScroll = function(event) {
                        currWidth = observerElement[LEXICON.oW];
                        currHeight = observerElement[LEXICON.oH];
                        isDirty = currWidth != widthCache || currHeight != heightCache;
                        if (event && isDirty && !rAFId) {
                          COMPATIBILITY.cAF()(rAFId);
                          rAFId = COMPATIBILITY.rAF()(onResized);
                        } else if (!event)
                          onResized();
                        reset();
                        if (event) {
                          COMPATIBILITY.prvD(event);
                          COMPATIBILITY.stpP(event);
                        }
                        return false;
                      };
                      var expandChildCSS = {};
                      var observerElementCSS = {};
                      setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                        -((nativeScrollbarSize.y + 1) * factor),
                        nativeScrollbarSize.x * -factor,
                        nativeScrollbarSize.y * -factor,
                        -((nativeScrollbarSize.x + 1) * factor)
                      ]);
                      FRAMEWORK(observerElement).css(observerElementCSS);
                      expandElement.on(_strScroll, onScroll);
                      shrinkElement.on(_strScroll, onScroll);
                      targetElement.on(strAnimationStartEvent, function() {
                        onScroll(false);
                      });
                      expandChildCSS[_strWidth] = constScroll;
                      expandChildCSS[_strHeight] = constScroll;
                      expandElementChild.css(expandChildCSS);
                      reset();
                    } else {
                      var attachEvent = _documentElementNative.attachEvent;
                      var isIE = _msieVersion !== undefined2;
                      if (attachEvent) {
                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent("onresize", callback);
                      } else {
                        var obj = _documentElementNative.createElement(TYPES.o);
                        obj.setAttribute(LEXICON.ti, "-1");
                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                        obj.onload = function() {
                          var wnd = this.contentDocument.defaultView;
                          wnd.addEventListener("resize", callback);
                          wnd.document.documentElement.style.display = "none";
                        };
                        obj.type = "text/html";
                        if (isIE)
                          targetElement.prepend(obj);
                        obj.data = "about:blank";
                        if (!isIE)
                          targetElement.prepend(obj);
                        targetElement.on(strAnimationStartEvent, callback);
                      }
                    }
                  }
                  if (targetElement[0] === _sizeObserverElementNative) {
                    var directionChanged = function() {
                      var dir = _hostElement.css("direction");
                      var css = {};
                      var scrollLeftValue = 0;
                      var result = false;
                      if (dir !== _cssDirectionDetectedCache) {
                        if (dir === "ltr") {
                          css[_strLeft] = 0;
                          css[_strRight] = _strAuto;
                          scrollLeftValue = constScroll;
                        } else {
                          css[_strLeft] = _strAuto;
                          css[_strRight] = 0;
                          scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                        }
                        _sizeObserverElement.children().eq(0).css(css);
                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                        _cssDirectionDetectedCache = dir;
                        result = true;
                      }
                      return result;
                    };
                    directionChanged();
                    addDestroyEventListener(targetElement, _strScroll, function(event) {
                      if (directionChanged())
                        update();
                      COMPATIBILITY.prvD(event);
                      COMPATIBILITY.stpP(event);
                      return false;
                    });
                  }
                } else {
                  if (_supportResizeObserver) {
                    var element = targetElement.contents()[0];
                    var resizeObserverObj = element[_strResizeObserverProperty];
                    if (resizeObserverObj) {
                      resizeObserverObj.disconnect();
                      delete element[_strResizeObserverProperty];
                    }
                  } else {
                    remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                  }
                }
              }
            }
            function createMutationObservers() {
              if (_supportMutationObserver) {
                var mutationObserverContentLag = 11;
                var mutationObserver = COMPATIBILITY.mO();
                var contentLastUpdate = COMPATIBILITY.now();
                var mutationTarget;
                var mutationAttrName;
                var mutationIsClass;
                var oldMutationVal;
                var newClassVal;
                var hostClassNameRegex;
                var contentTimeout;
                var now;
                var sizeAuto;
                var action;
                _mutationObserverHostCallback = function(mutations) {
                  var doUpdate = false;
                  var doUpdateForce = false;
                  var mutation;
                  var mutatedAttrs = [];
                  if (_initialized && !_sleeping) {
                    each(mutations, function() {
                      mutation = this;
                      mutationTarget = mutation.target;
                      mutationAttrName = mutation.attributeName;
                      mutationIsClass = mutationAttrName === LEXICON.c;
                      oldMutationVal = mutation.oldValue;
                      newClassVal = mutationTarget.className;
                      if (_domExists && mutationIsClass && !doUpdateForce) {
                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                          hostClassNameRegex = createHostClassNameRegExp(true);
                          _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function(name) {
                            return name.match(hostClassNameRegex);
                          })).join(_strSpace);
                          doUpdate = doUpdateForce = true;
                        }
                      }
                      if (!doUpdate) {
                        doUpdate = mutationIsClass ? hostClassNamesChanged(oldMutationVal, newClassVal) : mutationAttrName === LEXICON.s ? oldMutationVal !== mutationTarget[LEXICON.s].cssText : true;
                      }
                      mutatedAttrs.push(mutationAttrName);
                    });
                    updateViewportAttrsFromTarget(mutatedAttrs);
                    if (doUpdate)
                      _base.update(doUpdateForce || _strAuto);
                  }
                  return doUpdate;
                };
                _mutationObserverContentCallback = function(mutations) {
                  var doUpdate = false;
                  var mutation;
                  if (_initialized && !_sleeping) {
                    each(mutations, function() {
                      mutation = this;
                      doUpdate = isUnknownMutation(mutation);
                      return !doUpdate;
                    });
                    if (doUpdate) {
                      now = COMPATIBILITY.now();
                      sizeAuto = _heightAutoCache || _widthAutoCache;
                      action = function() {
                        if (!_destroyed) {
                          contentLastUpdate = now;
                          if (_isTextarea)
                            textareaUpdate();
                          if (sizeAuto)
                            update();
                          else
                            _base.update(_strAuto);
                        }
                      };
                      clearTimeout(contentTimeout);
                      if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                        action();
                      else
                        contentTimeout = setTimeout(action, mutationObserverContentLag);
                    }
                  }
                  return doUpdate;
                };
                _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
              }
            }
            function connectMutationObservers() {
              if (_supportMutationObserver && !_mutationObserversConnected) {
                _mutationObserverHost.observe(_hostElementNative, {
                  attributes: true,
                  attributeOldValue: true,
                  attributeFilter: _mutationObserverAttrsHost
                });
                _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                  attributes: true,
                  attributeOldValue: true,
                  subtree: !_isTextarea,
                  childList: !_isTextarea,
                  characterData: !_isTextarea,
                  attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                });
                _mutationObserversConnected = true;
              }
            }
            function disconnectMutationObservers() {
              if (_supportMutationObserver && _mutationObserversConnected) {
                _mutationObserverHost.disconnect();
                _mutationObserverContent.disconnect();
                _mutationObserversConnected = false;
              }
            }
            function hostOnResized() {
              if (!_sleeping) {
                var changed;
                var hostSize = {
                  w: _sizeObserverElementNative[LEXICON.sW],
                  h: _sizeObserverElementNative[LEXICON.sH]
                };
                changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                _hostElementSizeChangeDetectedCache = hostSize;
                if (changed)
                  update({ _hostSizeChanged: true });
              }
            }
            function hostOnMouseEnter() {
              if (_scrollbarsAutoHideLeave)
                refreshScrollbarsAutoHide(true);
            }
            function hostOnMouseLeave() {
              if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
                refreshScrollbarsAutoHide(false);
            }
            function hostOnMouseMove() {
              if (_scrollbarsAutoHideMove) {
                refreshScrollbarsAutoHide(true);
                clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                _scrollbarsAutoHideMoveTimeoutId = setTimeout(function() {
                  if (_scrollbarsAutoHideMove && !_destroyed)
                    refreshScrollbarsAutoHide(false);
                }, 100);
              }
            }
            function documentOnSelectStart(event) {
              COMPATIBILITY.prvD(event);
              return false;
            }
            function updateOnLoadCallback(event) {
              if (!_destroyed) {
                var target = event.target;
                var elm = FRAMEWORK(event.target);
                var index = FRAMEWORK.inArray(target, _updateOnLoadElms);
                if (index > -1) {
                  _updateOnLoadElms.splice(index, 1);
                }
                eachUpdateOnLoad(function(i, updateOnLoadSelector) {
                  if (elm.is(updateOnLoadSelector)) {
                    update({ _contentSizeChanged: true });
                  }
                });
              }
            }
            function setupHostMouseTouchEvents(destroy) {
              if (!destroy)
                setupHostMouseTouchEvents(true);
              setupResponsiveEventListener(
                _hostElement,
                _strMouseTouchMoveEvent.split(_strSpace)[0],
                hostOnMouseMove,
                !_scrollbarsAutoHideMove || destroy,
                true
              );
              setupResponsiveEventListener(
                _hostElement,
                [_strMouseEnter, _strMouseLeave],
                [hostOnMouseEnter, hostOnMouseLeave],
                !_scrollbarsAutoHideLeave || destroy,
                true
              );
              if (!_initialized && !destroy)
                _hostElement.one("mouseover", hostOnMouseEnter);
            }
            function bodyMinSizeChanged() {
              var bodyMinSize = {};
              if (_isBody && _contentArrangeElement) {
                bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                bodyMinSize.f = true;
              }
              _bodyMinSizeCache = bodyMinSize;
              return !!bodyMinSize.c;
            }
            function hostClassNamesChanged(oldClassNames, newClassNames) {
              var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
              var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
              var diff = getArrayDifferences(oldClasses, currClasses);
              var idx = inArray(_classNameThemeNone, diff);
              var i;
              var regex;
              if (idx > -1)
                diff.splice(idx, 1);
              if (diff[LEXICON.l] > 0) {
                regex = createHostClassNameRegExp(true, true);
                for (i = 0; i < diff.length; i++) {
                  if (!diff[i].match(regex)) {
                    return true;
                  }
                }
              }
              return false;
            }
            function isUnknownMutation(mutation) {
              var attributeName = mutation.attributeName;
              var mutationTarget = mutation.target;
              var mutationType = mutation.type;
              var strClosest = "closest";
              if (mutationTarget === _contentElementNative)
                return attributeName === null;
              if (mutationType === "attributes" && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                  return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);
                if (typeof mutationTarget[strClosest] != TYPES.f)
                  return true;
                if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                  return false;
              }
              return true;
            }
            function updateAutoContentSizeChanged() {
              if (_sleeping)
                return false;
              var contentMeasureElement = getContentMeasureElement();
              var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
              var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
              var css = {};
              var float;
              var bodyMinSizeC;
              var changed;
              var contentElementScrollSize;
              if (setCSS) {
                float = _contentElement.css(_strFloat);
                css[_strFloat] = _isRTL ? _strRight : _strLeft;
                css[_strWidth] = _strAuto;
                _contentElement.css(css);
              }
              contentElementScrollSize = {
                w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                h: contentMeasureElement[LEXICON.sH] + textareaValueLength
              };
              if (setCSS) {
                css[_strFloat] = float;
                css[_strWidth] = _strHundredPercent;
                _contentElement.css(css);
              }
              bodyMinSizeC = bodyMinSizeChanged();
              changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);
              _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;
              return changed || bodyMinSizeC;
            }
            function meaningfulAttrsChanged() {
              if (_sleeping || _mutationObserversConnected)
                return;
              var elem;
              var curr;
              var cache;
              var changedAttrs = [];
              var checks = [
                {
                  _elem: _hostElement,
                  _attrs: _mutationObserverAttrsHost.concat(":visible")
                },
                {
                  _elem: _isTextarea ? _targetElement : undefined2,
                  _attrs: _mutationObserverAttrsTextarea
                }
              ];
              each(checks, function(index, check) {
                elem = check._elem;
                if (elem) {
                  each(check._attrs, function(index2, attr) {
                    curr = attr.charAt(0) === ":" ? elem.is(attr) : elem.attr(attr);
                    cache = _updateAutoCache[attr];
                    if (checkCache(curr, cache)) {
                      changedAttrs.push(attr);
                    }
                    _updateAutoCache[attr] = curr;
                  });
                }
              });
              updateViewportAttrsFromTarget(changedAttrs);
              return changedAttrs[LEXICON.l] > 0;
            }
            function isSizeAffectingCSSProperty(propertyName) {
              if (!_initialized)
                return true;
              var flexGrow = "flex-grow";
              var flexShrink = "flex-shrink";
              var flexBasis = "flex-basis";
              var affectingPropsX = [
                _strWidth,
                _strMinMinus + _strWidth,
                _strMaxMinus + _strWidth,
                _strMarginMinus + _strLeft,
                _strMarginMinus + _strRight,
                _strLeft,
                _strRight,
                "font-weight",
                "word-spacing",
                flexGrow,
                flexShrink,
                flexBasis
              ];
              var affectingPropsXContentBox = [
                _strPaddingMinus + _strLeft,
                _strPaddingMinus + _strRight,
                _strBorderMinus + _strLeft + _strWidth,
                _strBorderMinus + _strRight + _strWidth
              ];
              var affectingPropsY = [
                _strHeight,
                _strMinMinus + _strHeight,
                _strMaxMinus + _strHeight,
                _strMarginMinus + _strTop,
                _strMarginMinus + _strBottom,
                _strTop,
                _strBottom,
                "line-height",
                flexGrow,
                flexShrink,
                flexBasis
              ];
              var affectingPropsYContentBox = [
                _strPaddingMinus + _strTop,
                _strPaddingMinus + _strBottom,
                _strBorderMinus + _strTop + _strWidth,
                _strBorderMinus + _strBottom + _strWidth
              ];
              var _strS = "s";
              var _strVS = "v-s";
              var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
              var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
              var sizeIsAffected = false;
              var checkPropertyName = function(arr, name) {
                for (var i = 0; i < arr[LEXICON.l]; i++) {
                  if (arr[i] === name)
                    return true;
                }
                return false;
              };
              if (checkY) {
                sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                if (!sizeIsAffected && !_isBorderBox)
                  sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
              }
              if (checkX && !sizeIsAffected) {
                sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                if (!sizeIsAffected && !_isBorderBox)
                  sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
              }
              return sizeIsAffected;
            }
            function updateViewportAttrsFromTarget(attrs) {
              attrs = attrs || _viewportAttrsFromTarget;
              each(attrs, function(index, attr) {
                if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                  var targetAttr = _targetElement.attr(attr);
                  if (type(targetAttr) == TYPES.s) {
                    _viewportElement.attr(attr, targetAttr);
                  } else {
                    _viewportElement.removeAttr(attr);
                  }
                }
              });
            }
            function textareaUpdate() {
              if (!_sleeping) {
                var wrapAttrOff = !_textareaAutoWrappingCache;
                var minWidth = _viewportSize.w;
                var minHeight = _viewportSize.h;
                var css = {};
                var doMeasure = _widthAutoCache || wrapAttrOff;
                var origWidth;
                var width;
                var origHeight;
                var height;
                css[_strMinMinus + _strWidth] = _strEmpty;
                css[_strMinMinus + _strHeight] = _strEmpty;
                css[_strWidth] = _strAuto;
                _targetElement.css(css);
                origWidth = _targetElementNative[LEXICON.oW];
                width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                css[_strWidth] = _widthAutoCache ? _strAuto : _strHundredPercent;
                css[_strMinMinus + _strWidth] = _strHundredPercent;
                css[_strHeight] = _strAuto;
                _targetElement.css(css);
                origHeight = _targetElementNative[LEXICON.oH];
                height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);
                css[_strWidth] = width;
                css[_strHeight] = height;
                _textareaCoverElement.css(css);
                css[_strMinMinus + _strWidth] = minWidth;
                css[_strMinMinus + _strHeight] = minHeight;
                _targetElement.css(css);
                return {
                  _originalWidth: origWidth,
                  _originalHeight: origHeight,
                  _dynamicWidth: width,
                  _dynamicHeight: height
                };
              }
            }
            function update(updateHints) {
              clearTimeout(_swallowedUpdateTimeout);
              updateHints = updateHints || {};
              _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
              _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
              _swallowedUpdateHints._force |= updateHints._force;
              var now = COMPATIBILITY.now();
              var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
              var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
              var force = !!_swallowedUpdateHints._force;
              var changedOptions = updateHints._changedOptions;
              var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && now - _lastUpdateTime < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
              var displayIsHidden;
              if (swallow)
                _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);
              if (_destroyed || swallow || _sleeping && !changedOptions || _initialized && !force && (displayIsHidden = _hostElement.is(":hidden")) || _hostElement.css("display") === "inline")
                return;
              _lastUpdateTime = now;
              _swallowedUpdateHints = {};
              if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                _nativeScrollbarSize.x = 0;
                _nativeScrollbarSize.y = 0;
              } else {
                _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
              }
              _nativeScrollbarMinSize = {
                x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
              };
              changedOptions = changedOptions || {};
              var checkCacheAutoForce = function() {
                return checkCache.apply(this, [].slice.call(arguments).concat([force]));
              };
              var currScroll = {
                x: _viewportElement[_strScrollLeft](),
                y: _viewportElement[_strScrollTop]()
              };
              var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
              var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;
              var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
              var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);
              var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
              var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);
              var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
              var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);
              var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
              var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);
              var className = _currentPreparedOptions.className;
              var classNameChanged = checkCacheAutoForce(className, _classNameCache);
              var resize = _currentPreparedOptions.resize;
              var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody;
              var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
              var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);
              var clipAlways = _currentPreparedOptions.clipAlways;
              var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);
              var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody;
              var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);
              var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
              var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);
              var autoUpdate = _currentPreparedOptions.autoUpdate;
              var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);
              var overflowBehavior = _currentPreparedOptions.overflowBehavior;
              var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);
              var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
              var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);
              var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
              var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);
              _scrollbarsAutoHideNever = scrollbarsAutoHide === "n";
              _scrollbarsAutoHideScroll = scrollbarsAutoHide === "s";
              _scrollbarsAutoHideMove = scrollbarsAutoHide === "m";
              _scrollbarsAutoHideLeave = scrollbarsAutoHide === "l";
              _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;
              _oldClassName = _classNameCache;
              _resizeNone = resize === "n";
              _resizeBoth = resize === "b";
              _resizeHorizontal = resize === "h";
              _resizeVertical = resize === "v";
              _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;
              ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);
              _scrollbarsVisibilityCache = scrollbarsVisibility;
              _scrollbarsAutoHideCache = scrollbarsAutoHide;
              _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
              _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
              _classNameCache = className;
              _resizeCache = resize;
              _paddingAbsoluteCache = paddingAbsolute;
              _clipAlwaysCache = clipAlways;
              _sizeAutoCapableCache = sizeAutoCapable;
              _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
              _autoUpdateCache = autoUpdate;
              _overflowBehaviorCache = extendDeep({}, overflowBehavior);
              _textareaDynWidthCache = textareaDynWidth;
              _textareaDynHeightCache = textareaDynHeight;
              _hasOverflowCache = _hasOverflowCache || { x: false, y: false };
              if (classNameChanged) {
                removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                addClass(_hostElement, className !== undefined2 && className !== null && className.length > 0 ? className : _classNameThemeNone);
              }
              if (autoUpdateChanged) {
                if (autoUpdate === true || autoUpdate === null && _autoUpdateRecommended) {
                  disconnectMutationObservers();
                  autoUpdateLoop.add(_base);
                } else {
                  autoUpdateLoop.remove(_base);
                  connectMutationObservers();
                }
              }
              if (sizeAutoCapableChanged) {
                if (sizeAutoCapable) {
                  if (_contentGlueElement) {
                    _contentGlueElement.show();
                  } else {
                    _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                    _paddingElement.before(_contentGlueElement);
                  }
                  if (_sizeAutoObserverAdded) {
                    _sizeAutoObserverElement.show();
                  } else {
                    _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                    _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];
                    _contentGlueElement.before(_sizeAutoObserverElement);
                    var oldSize = { w: -1, h: -1 };
                    setupResizeObserver(_sizeAutoObserverElement, function() {
                      var newSize = {
                        w: _sizeAutoObserverElementNative[LEXICON.oW],
                        h: _sizeAutoObserverElementNative[LEXICON.oH]
                      };
                      if (checkCache(newSize, oldSize)) {
                        if (_initialized && (_heightAutoCache && newSize.h > 0) || _widthAutoCache && newSize.w > 0) {
                          update();
                        } else if (_initialized && (!_heightAutoCache && newSize.h === 0) || !_widthAutoCache && newSize.w === 0) {
                          update();
                        }
                      }
                      oldSize = newSize;
                    });
                    _sizeAutoObserverAdded = true;
                    if (_cssCalc !== null)
                      _sizeAutoObserverElement.css(_strHeight, _cssCalc + "(100% + 1px)");
                  }
                } else {
                  if (_sizeAutoObserverAdded)
                    _sizeAutoObserverElement.hide();
                  if (_contentGlueElement)
                    _contentGlueElement.hide();
                }
              }
              if (force) {
                _sizeObserverElement.find("*").trigger(_strScroll);
                if (_sizeAutoObserverAdded)
                  _sizeAutoObserverElement.find("*").trigger(_strScroll);
              }
              displayIsHidden = displayIsHidden === undefined2 ? _hostElement.is(":hidden") : displayIsHidden;
              var textareaAutoWrapping = _isTextarea ? _targetElement.attr("wrap") !== "off" : false;
              var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);
              var cssDirection = _hostElement.css("direction");
              var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);
              var boxSizing = _hostElement.css("box-sizing");
              var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);
              var padding = getTopRightBottomLeftHost(_strPaddingMinus);
              var sizeAutoObserverElementBCRect;
              try {
                sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
              } catch (ex) {
                return;
              }
              _isRTL = cssDirection === "rtl";
              _isBorderBox = boxSizing === "border-box";
              var isRTLLeft = _isRTL ? _strLeft : _strRight;
              var isRTLRight = _isRTL ? _strRight : _strLeft;
              var widthAutoResizeDetection = false;
              var widthAutoObserverDetection = _sizeAutoObserverAdded && _hostElement.css(_strFloat) !== "none" ? MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0 && (!paddingAbsolute ? _hostElementNative[LEXICON.cW] - _paddingX > 0 : true) : false;
              if (sizeAutoCapable && !widthAutoObserverDetection) {
                var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
                var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                _contentGlueElement.css(_strWidth, _strAuto);
                var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                if (!widthAutoResizeDetection) {
                  _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
                  tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                  _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                  widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                }
              }
              var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
              var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
              var wasWidthAuto = !widthAuto && _widthAutoCache;
              var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0 : false;
              var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
              var wasHeightAuto = !heightAuto && _heightAutoCache;
              var updateBorderX = widthAuto && _isBorderBox || !_isBorderBox;
              var updateBorderY = heightAuto && _isBorderBox || !_isBorderBox;
              var border = getTopRightBottomLeftHost(_strBorderMinus, "-" + _strWidth, !updateBorderX, !updateBorderY);
              var margin = getTopRightBottomLeftHost(_strMarginMinus);
              var contentElementCSS = {};
              var contentGlueElementCSS = {};
              var getHostSize = function() {
                return {
                  w: _hostElementNative[LEXICON.cW],
                  h: _hostElementNative[LEXICON.cH]
                };
              };
              var getViewportSize = function() {
                return {
                  w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                  h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                };
              };
              var paddingAbsoluteX = _paddingX = padding.l + padding.r;
              var paddingAbsoluteY = _paddingY = padding.t + padding.b;
              paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
              paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
              padding.c = checkCacheAutoForce(padding, _cssPaddingCache);
              _borderX = border.l + border.r;
              _borderY = border.t + border.b;
              border.c = checkCacheAutoForce(border, _cssBorderCache);
              _marginX = margin.l + margin.r;
              _marginY = margin.t + margin.b;
              margin.c = checkCacheAutoForce(margin, _cssMarginCache);
              _textareaAutoWrappingCache = textareaAutoWrapping;
              _cssDirectionCache = cssDirection;
              _cssBoxSizingCache = boxSizing;
              _widthAutoCache = widthAuto;
              _heightAutoCache = heightAuto;
              _cssPaddingCache = padding;
              _cssBorderCache = border;
              _cssMarginCache = margin;
              if (cssDirectionChanged && _sizeAutoObserverAdded)
                _sizeAutoObserverElement.css(_strFloat, isRTLRight);
              if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                var paddingElementCSS = {};
                var textareaCSS = {};
                var paddingValues = [padding.t, padding.r, padding.b, padding.l];
                setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
                if (paddingAbsolute) {
                  setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
                  setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
                } else {
                  setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                  setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
                }
                _paddingElement.css(paddingElementCSS);
                _targetElement.css(textareaCSS);
              }
              _viewportSize = getViewportSize();
              var textareaSize = _isTextarea ? textareaUpdate() : false;
              var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
              var textareaDynOrigSize = _isTextarea && textareaSize ? {
                w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
              } : {};
              _textareaSizeCache = textareaSize;
              if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
                contentElementCSS[_strHeight] = _strAuto;
              } else if (heightAutoChanged || paddingAbsoluteChanged) {
                contentElementCSS[_strHeight] = _strHundredPercent;
              }
              if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
                contentElementCSS[_strWidth] = _strAuto;
                contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent;
              } else if (widthAutoChanged || paddingAbsoluteChanged) {
                contentElementCSS[_strWidth] = _strHundredPercent;
                contentElementCSS[_strFloat] = _strEmpty;
                contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty;
              }
              if (widthAuto) {
                contentGlueElementCSS[_strWidth] = _strAuto;
                contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, "max-content intrinsic") || _strAuto;
                contentElementCSS[_strFloat] = isRTLRight;
              } else {
                contentGlueElementCSS[_strWidth] = _strEmpty;
              }
              if (heightAuto) {
                contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
              } else {
                contentGlueElementCSS[_strHeight] = _strEmpty;
              }
              if (sizeAutoCapable)
                _contentGlueElement.css(contentGlueElementCSS);
              _contentElement.css(contentElementCSS);
              contentElementCSS = {};
              contentGlueElementCSS = {};
              if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                var strOverflow = "overflow";
                var strOverflowX = strOverflow + "-x";
                var strOverflowY = strOverflow + "-y";
                var strHidden = "hidden";
                var strVisible = "visible";
                if (!_nativeScrollbarStyling) {
                  var viewportElementResetCSS = {};
                  var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y : 0;
                  var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x : 0;
                  setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
                  _viewportElement.css(viewportElementResetCSS);
                }
                var contentMeasureElement = getContentMeasureElement();
                var contentSize = {
                  w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                  h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                };
                var scrollSize = {
                  w: contentMeasureElement[LEXICON.sW],
                  h: contentMeasureElement[LEXICON.sH]
                };
                if (!_nativeScrollbarStyling) {
                  viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                  viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
                  _viewportElement.css(viewportElementResetCSS);
                }
                _viewportSize = getViewportSize();
                var hostSize = getHostSize();
                var hostAbsoluteRectSize = {
                  w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
                  h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
                };
                var contentGlueSize = {
                  w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
                  h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
                };
                contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                _contentGlueSizeCache = contentGlueSize;
                if (sizeAutoCapable) {
                  if (contentGlueSize.c || (heightAuto || widthAuto)) {
                    contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                    contentGlueElementCSS[_strHeight] = contentGlueSize.h;
                    if (!_isTextarea) {
                      contentSize = {
                        w: contentMeasureElement[LEXICON.cW],
                        h: contentMeasureElement[LEXICON.cH]
                      };
                    }
                  }
                  var textareaCoverCSS = {};
                  var setContentGlueElementCSSfunction = function(horizontal) {
                    var scrollbarVars = getScrollbarVars(horizontal);
                    var wh = scrollbarVars._w_h;
                    var strWH = scrollbarVars._width_height;
                    var autoSize = horizontal ? widthAuto : heightAuto;
                    var borderSize = horizontal ? _borderX : _borderY;
                    var paddingSize = horizontal ? _paddingX : _paddingY;
                    var marginSize = horizontal ? _marginX : _marginY;
                    var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);
                    if (!autoSize || !autoSize && border.c)
                      contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;
                    if (autoSize && contentSize[wh] < viewportSize && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                      if (_isTextarea)
                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                      contentGlueElementCSS[strWH] -= 1;
                    }
                    if (contentSize[wh] > 0)
                      contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                  };
                  setContentGlueElementCSSfunction(true);
                  setContentGlueElementCSSfunction(false);
                  if (_isTextarea)
                    _textareaCoverElement.css(textareaCoverCSS);
                  _contentGlueElement.css(contentGlueElementCSS);
                }
                if (widthAuto)
                  contentElementCSS[_strWidth] = _strHundredPercent;
                if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
                  contentElementCSS[_strFloat] = "none";
                _contentElement.css(contentElementCSS);
                contentElementCSS = {};
                var contentScrollSize = {
                  w: contentMeasureElement[LEXICON.sW],
                  h: contentMeasureElement[LEXICON.sH]
                };
                contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                _contentScrollSizeCache = contentScrollSize;
                _viewportSize = getViewportSize();
                hostSize = getHostSize();
                hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                _hostSizeCache = hostSize;
                var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                var previousOverflowAmount = _overflowAmountCache;
                var overflowBehaviorIsVS = {};
                var overflowBehaviorIsVH = {};
                var overflowBehaviorIsS = {};
                var overflowAmount = {};
                var hasOverflow = {};
                var hideOverflow = {};
                var canScroll = {};
                var viewportRect = _paddingElementNative[LEXICON.bCR]();
                var setOverflowVariables = function(horizontal) {
                  var scrollbarVars = getScrollbarVars(horizontal);
                  var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                  var xyI = scrollbarVarsInverted._x_y;
                  var xy = scrollbarVars._x_y;
                  var wh = scrollbarVars._w_h;
                  var widthHeight = scrollbarVars._width_height;
                  var scrollMax = _strScroll + scrollbarVars._Left_Top + "Max";
                  var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                  var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                  overflowBehaviorIsVS[xy] = overflowBehavior[xy] === "v-s";
                  overflowBehaviorIsVH[xy] = overflowBehavior[xy] === "v-h";
                  overflowBehaviorIsS[xy] = overflowBehavior[xy] === "s";
                  overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                  overflowAmount[xy] *= hideOverflowForceTextarea || checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1 ? 0 : 1;
                  hasOverflow[xy] = overflowAmount[xy] > 0;
                  hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI] : hasOverflow[xy];
                  hideOverflow[xy + "s"] = hideOverflow[xy] ? overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy] : false;
                  canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + "s"];
                };
                setOverflowVariables(true);
                setOverflowVariables(false);
                overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                _overflowAmountCache = overflowAmount;
                hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                _hasOverflowCache = hasOverflow;
                hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                _hideOverflowCache = hideOverflow;
                if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                  var borderDesign = "px solid transparent";
                  var contentArrangeElementCSS = {};
                  var arrangeContent = {};
                  var arrangeChanged = force;
                  var setContentElementCSS;
                  if (hasOverflow.x || hasOverflow.y) {
                    arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                    arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                    arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                    _arrangeContentSizeCache = arrangeContent;
                  }
                  if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                    contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                    setContentElementCSS = function(horizontal) {
                      var scrollbarVars = getScrollbarVars(horizontal);
                      var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                      var xy = scrollbarVars._x_y;
                      var strDirection = horizontal ? _strBottom : isRTLLeft;
                      var invertedAutoSize = horizontal ? heightAuto : widthAuto;
                      if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + "s"]) {
                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy] : _strEmpty;
                        contentElementCSS[_strBorderMinus + strDirection] = (horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding ? _overlayScrollbarDummySize[xy] + borderDesign : _strEmpty;
                      } else {
                        arrangeContent[scrollbarVarsInverted._w_h] = contentElementCSS[_strMarginMinus + strDirection] = contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                        arrangeChanged = true;
                      }
                    };
                    if (_nativeScrollbarStyling) {
                      addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding);
                    } else {
                      setContentElementCSS(true);
                      setContentElementCSS(false);
                    }
                  }
                  if (ignoreOverlayScrollbarHiding) {
                    arrangeContent.w = arrangeContent.h = _strEmpty;
                    arrangeChanged = true;
                  }
                  if (arrangeChanged && !_nativeScrollbarStyling) {
                    contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                    contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;
                    if (!_contentArrangeElement) {
                      _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                      _viewportElement.prepend(_contentArrangeElement);
                    }
                    _contentArrangeElement.css(contentArrangeElementCSS);
                  }
                  _contentElement.css(contentElementCSS);
                }
                var viewportElementCSS = {};
                var paddingElementCSS = {};
                var setViewportCSS;
                if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
                  viewportElementCSS[isRTLRight] = _strEmpty;
                  setViewportCSS = function(horizontal) {
                    var scrollbarVars = getScrollbarVars(horizontal);
                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                    var xy = scrollbarVars._x_y;
                    var XY = scrollbarVars._X_Y;
                    var strDirection = horizontal ? _strBottom : isRTLLeft;
                    var reset = function() {
                      viewportElementCSS[strDirection] = _strEmpty;
                      _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                    };
                    if (hasOverflow[xy] && hideOverflow[xy + "s"]) {
                      viewportElementCSS[strOverflow + XY] = _strScroll;
                      if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                        reset();
                      } else {
                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                      }
                    } else {
                      viewportElementCSS[strOverflow + XY] = _strEmpty;
                      reset();
                    }
                  };
                  setViewportCSS(true);
                  setViewportCSS(false);
                  if (!_nativeScrollbarStyling && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y) && (hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x || hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y)) {
                    viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                    viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;
                    viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                    viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                  } else {
                    viewportElementCSS[_strPaddingMinus + _strTop] = viewportElementCSS[_strMarginMinus + _strTop] = viewportElementCSS[_strPaddingMinus + isRTLRight] = viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                  }
                  viewportElementCSS[_strPaddingMinus + isRTLLeft] = viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;
                  if (hasOverflow.x && hideOverflow.x || hasOverflow.y && hideOverflow.y || hideOverflowForceTextarea) {
                    if (_isTextarea && hideOverflowForceTextarea) {
                      paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = strHidden;
                    }
                  } else {
                    if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                      if (_isTextarea) {
                        paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = _strEmpty;
                      }
                      viewportElementCSS[strOverflowX] = viewportElementCSS[strOverflowY] = strVisible;
                    }
                  }
                  _paddingElement.css(paddingElementCSS);
                  _viewportElement.css(viewportElementCSS);
                  viewportElementCSS = {};
                  if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                    var elementStyle = _contentElementNative[LEXICON.s];
                    var dump;
                    elementStyle.webkitTransform = "scale(1)";
                    elementStyle.display = "run-in";
                    dump = _contentElementNative[LEXICON.oH];
                    elementStyle.display = _strEmpty;
                    elementStyle.webkitTransform = _strEmpty;
                  }
                }
                contentElementCSS = {};
                if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                  if (_isRTL && widthAuto) {
                    var floatTmp = _contentElement.css(_strFloat);
                    var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                    _contentElement.css(_strFloat, floatTmp);
                    var posLeftWithFloat = MATH.round(_contentElement.position().left);
                    if (posLeftWithoutFloat !== posLeftWithFloat)
                      contentElementCSS[_strLeft] = posLeftWithoutFloat;
                  } else {
                    contentElementCSS[_strLeft] = _strEmpty;
                  }
                }
                _contentElement.css(contentElementCSS);
                if (_isTextarea && contentSizeChanged) {
                  var textareaInfo = getTextareaInfo();
                  if (textareaInfo) {
                    var textareaRowsChanged = _textareaInfoCache === undefined2 ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                    var cursorRow = textareaInfo._cursorRow;
                    var cursorCol = textareaInfo._cursorColumn;
                    var widestRow = textareaInfo._widestRow;
                    var lastRow = textareaInfo._rows;
                    var lastCol = textareaInfo._columns;
                    var cursorPos = textareaInfo._cursorPosition;
                    var cursorMax = textareaInfo._cursorMax;
                    var cursorIsLastPosition = cursorPos >= cursorMax && _textareaHasFocus;
                    var textareaScrollAmount = {
                      x: !textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow) ? _overflowAmountCache.x : -1,
                      y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? currScroll.y === previousOverflowAmount.y : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                    };
                    currScroll.x = textareaScrollAmount.x > -1 ? _isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x : currScroll.x;
                    currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                  }
                  _textareaInfoCache = textareaInfo;
                }
                if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
                  currScroll.x += _contentBorderSize.w || 0;
                if (widthAuto)
                  _hostElement[_strScrollLeft](0);
                if (heightAuto)
                  _hostElement[_strScrollTop](0);
                _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);
                var scrollbarsVisibilityVisible = scrollbarsVisibility === "v";
                var scrollbarsVisibilityHidden = scrollbarsVisibility === "h";
                var scrollbarsVisibilityAuto = scrollbarsVisibility === "a";
                var refreshScrollbarsVisibility = function(showX, showY) {
                  showY = showY === undefined2 ? showX : showY;
                  refreshScrollbarAppearance(true, showX, canScroll.x);
                  refreshScrollbarAppearance(false, showY, canScroll.y);
                };
                addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
                addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
                addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);
                if (cssDirectionChanged && !_isBody) {
                  addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
                }
                if (_isBody)
                  addClass(_hostElement, _classNameHostResizeDisabled);
                if (resizeChanged) {
                  addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
                }
                if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                  if (ignoreOverlayScrollbarHiding) {
                    if (ignoreOverlayScrollbarHidingChanged) {
                      removeClass(_hostElement, _classNameHostScrolling);
                      if (ignoreOverlayScrollbarHiding) {
                        refreshScrollbarsVisibility(false);
                      }
                    }
                  } else if (scrollbarsVisibilityAuto) {
                    refreshScrollbarsVisibility(canScroll.x, canScroll.y);
                  } else if (scrollbarsVisibilityVisible) {
                    refreshScrollbarsVisibility(true);
                  } else if (scrollbarsVisibilityHidden) {
                    refreshScrollbarsVisibility(false);
                  }
                }
                if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                  setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
                  refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
                }
                if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
                  refreshScrollbarHandleLength(true);
                  refreshScrollbarHandleOffset(true);
                  refreshScrollbarHandleLength(false);
                  refreshScrollbarHandleOffset(false);
                }
                if (scrollbarsClickScrollingChanged)
                  refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                if (scrollbarsDragScrollingChanged)
                  refreshScrollbarsInteractive(false, scrollbarsDragScrolling);
                dispatchCallback("onDirectionChanged", {
                  isRTL: _isRTL,
                  dir: cssDirection
                }, cssDirectionChanged);
                dispatchCallback("onHostSizeChanged", {
                  width: _hostSizeCache.w,
                  height: _hostSizeCache.h
                }, hostSizeChanged);
                dispatchCallback("onContentSizeChanged", {
                  width: _contentScrollSizeCache.w,
                  height: _contentScrollSizeCache.h
                }, contentSizeChanged);
                dispatchCallback("onOverflowChanged", {
                  x: hasOverflow.x,
                  y: hasOverflow.y,
                  xScrollable: hideOverflow.xs,
                  yScrollable: hideOverflow.ys,
                  clipped: hideOverflow.x || hideOverflow.y
                }, hasOverflow.c || hideOverflow.c);
                dispatchCallback("onOverflowAmountChanged", {
                  x: overflowAmount.x,
                  y: overflowAmount.y
                }, overflowAmount.c);
              }
              if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                if (!_bodyMinSizeCache.f)
                  bodyMinSizeChanged();
                if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
                  _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
                  _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                _bodyMinSizeCache.c = false;
              }
              if (_initialized && changedOptions.updateOnLoad) {
                updateElementsOnLoad();
              }
              dispatchCallback("onUpdated", { forced: force });
            }
            function updateElementsOnLoad() {
              if (!_isTextarea) {
                eachUpdateOnLoad(function(i, updateOnLoadSelector) {
                  _contentElement.find(updateOnLoadSelector).each(function(i2, el) {
                    if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                      _updateOnLoadElms.push(el);
                      FRAMEWORK(el).off(_updateOnLoadEventName, updateOnLoadCallback).on(_updateOnLoadEventName, updateOnLoadCallback);
                    }
                  });
                });
              }
            }
            function setOptions(newOptions) {
              var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions);
              _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
              _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);
              return validatedOpts._prepared;
            }
            function setupStructureDOM(destroy) {
              var strParent = "parent";
              var classNameResizeObserverHost = "os-resize-observer-host";
              var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
              var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
              var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
              var adoptAttrsMap = {};
              var applyAdoptedAttrs = function() {
                var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                each(adoptAttrsMap, function(key, value) {
                  if (type(value) == TYPES.s) {
                    if (key == LEXICON.c)
                      applyAdoptedAttrsElm.addClass(value);
                    else
                      applyAdoptedAttrsElm.attr(key, value);
                  }
                });
              };
              var hostElementClassNames = [
                _classNameHostElement,
                _classNameHostElementForeign,
                _classNameHostTextareaElement,
                _classNameHostResizeDisabled,
                _classNameHostRTL,
                _classNameHostScrollbarHorizontalHidden,
                _classNameHostScrollbarVerticalHidden,
                _classNameHostTransition,
                _classNameHostScrolling,
                _classNameHostOverflow,
                _classNameHostOverflowX,
                _classNameHostOverflowY,
                _classNameThemeNone,
                _classNameTextareaElement,
                _classNameTextInherit,
                _classNameCache
              ].join(_strSpace);
              var hostElementCSS = {};
              _hostElement = _hostElement || (_isTextarea ? _domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement)) : _targetElement);
              _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
              _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
              _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
              _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
              _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined2);
              if (_domExists)
                addClass(_hostElement, _classNameHostElementForeign);
              if (destroy)
                removeClass(_hostElement, hostElementClassNames);
              adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
              if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
                each(adoptAttrs, function(i, v) {
                  if (type(v) == TYPES.s) {
                    adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                  }
                });
              }
              if (!destroy) {
                if (_isTextarea) {
                  if (!_currentPreparedOptions.sizeAutoCapable) {
                    hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                    hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                  }
                  if (!_domExists)
                    _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);
                  _hostElement = _targetElement[strParent]().css(hostElementCSS);
                }
                if (!_domExists) {
                  addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);
                  _hostElement.wrapInner(_contentElement).wrapInner(_viewportElement).wrapInner(_paddingElement).prepend(_sizeObserverElement);
                  _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                  _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                  _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);
                  if (_isTextarea) {
                    _contentElement.prepend(_textareaCoverElement);
                    applyAdoptedAttrs();
                  }
                }
                if (_nativeScrollbarStyling)
                  addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
                  addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                if (_isBody)
                  addClass(_htmlElement, _classNameHTMLElement);
                _sizeObserverElementNative = _sizeObserverElement[0];
                _hostElementNative = _hostElement[0];
                _paddingElementNative = _paddingElement[0];
                _viewportElementNative = _viewportElement[0];
                _contentElementNative = _contentElement[0];
                updateViewportAttrsFromTarget();
              } else {
                if (_domExists && _initialized) {
                  _sizeObserverElement.children().remove();
                  each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function(i, elm) {
                    if (elm) {
                      removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                    }
                  });
                  addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                } else {
                  remove(_sizeObserverElement);
                  _contentElement.contents().unwrap().unwrap().unwrap();
                  if (_isTextarea) {
                    _targetElement.unwrap();
                    remove(_hostElement);
                    remove(_textareaCoverElement);
                    applyAdoptedAttrs();
                  }
                }
                if (_isTextarea)
                  _targetElement.removeAttr(LEXICON.s);
                if (_isBody)
                  removeClass(_htmlElement, _classNameHTMLElement);
              }
            }
            function setupStructureEvents() {
              var textareaKeyDownRestrictedKeyCodes = [
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                123,
                33,
                34,
                37,
                38,
                39,
                40,
                16,
                17,
                18,
                19,
                20,
                144
              ];
              var textareaKeyDownKeyCodesList = [];
              var textareaUpdateIntervalID;
              var scrollStopTimeoutId;
              var scrollStopDelay = 175;
              var strFocus = "focus";
              function updateTextarea(doClearInterval) {
                textareaUpdate();
                _base.update(_strAuto);
                if (doClearInterval && _autoUpdateRecommended)
                  clearInterval(textareaUpdateIntervalID);
              }
              function textareaOnScroll(event) {
                _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
                _targetElement[_strScrollTop](0);
                COMPATIBILITY.prvD(event);
                COMPATIBILITY.stpP(event);
                return false;
              }
              function textareaOnDrop(event) {
                setTimeout(function() {
                  if (!_destroyed)
                    updateTextarea();
                }, 50);
              }
              function textareaOnFocus() {
                _textareaHasFocus = true;
                addClass(_hostElement, strFocus);
              }
              function textareaOnFocusout() {
                _textareaHasFocus = false;
                textareaKeyDownKeyCodesList = [];
                removeClass(_hostElement, strFocus);
                updateTextarea(true);
              }
              function textareaOnKeyDown(event) {
                var keyCode = event.keyCode;
                if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                  if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                    updateTextarea();
                    textareaUpdateIntervalID = setInterval(updateTextarea, 1e3 / 60);
                  }
                  if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                    textareaKeyDownKeyCodesList.push(keyCode);
                }
              }
              function textareaOnKeyUp(event) {
                var keyCode = event.keyCode;
                var index = inArray(keyCode, textareaKeyDownKeyCodesList);
                if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                  if (index > -1)
                    textareaKeyDownKeyCodesList.splice(index, 1);
                  if (!textareaKeyDownKeyCodesList[LEXICON.l])
                    updateTextarea(true);
                }
              }
              function contentOnTransitionEnd(event) {
                if (_autoUpdateCache === true)
                  return;
                event = event.originalEvent || event;
                if (isSizeAffectingCSSProperty(event.propertyName))
                  _base.update(_strAuto);
              }
              function viewportOnScroll(event) {
                if (!_sleeping) {
                  if (scrollStopTimeoutId !== undefined2)
                    clearTimeout(scrollStopTimeoutId);
                  else {
                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                      refreshScrollbarsAutoHide(true);
                    if (!nativeOverlayScrollbarsAreActive())
                      addClass(_hostElement, _classNameHostScrolling);
                    dispatchCallback("onScrollStart", event);
                  }
                  if (!_scrollbarsHandlesDefineScrollPos) {
                    refreshScrollbarHandleOffset(true);
                    refreshScrollbarHandleOffset(false);
                  }
                  dispatchCallback("onScroll", event);
                  scrollStopTimeoutId = setTimeout(function() {
                    if (!_destroyed) {
                      clearTimeout(scrollStopTimeoutId);
                      scrollStopTimeoutId = undefined2;
                      if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                        refreshScrollbarsAutoHide(false);
                      if (!nativeOverlayScrollbarsAreActive())
                        removeClass(_hostElement, _classNameHostScrolling);
                      dispatchCallback("onScrollStop", event);
                    }
                  }, scrollStopDelay);
                }
              }
              if (_isTextarea) {
                if (_msieVersion > 9 || !_autoUpdateRecommended) {
                  addDestroyEventListener(_targetElement, "input", updateTextarea);
                } else {
                  addDestroyEventListener(
                    _targetElement,
                    [_strKeyDownEvent, _strKeyUpEvent],
                    [textareaOnKeyDown, textareaOnKeyUp]
                  );
                }
                addDestroyEventListener(
                  _targetElement,
                  [_strScroll, "drop", strFocus, strFocus + "out"],
                  [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]
                );
              } else {
                addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
              }
              addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
            }
            function setupScrollbarsDOM(destroy) {
              var selectOrGenerateScrollbarDOM = function(isHorizontal) {
                var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);
                if (!_domExists && !destroy) {
                  scrollbar.append(track);
                  track.append(handle);
                }
                return {
                  _scrollbar: scrollbar,
                  _track: track,
                  _handle: handle
                };
              };
              function resetScrollbarDOM(isHorizontal) {
                var scrollbarVars = getScrollbarVars(isHorizontal);
                var scrollbar = scrollbarVars._scrollbar;
                var track = scrollbarVars._track;
                var handle = scrollbarVars._handle;
                if (_domExists && _initialized) {
                  each([scrollbar, track, handle], function(i, elm) {
                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                  });
                } else {
                  remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                }
              }
              var horizontalElements;
              var verticalElements;
              if (!destroy) {
                horizontalElements = selectOrGenerateScrollbarDOM(true);
                verticalElements = selectOrGenerateScrollbarDOM();
                _scrollbarHorizontalElement = horizontalElements._scrollbar;
                _scrollbarHorizontalTrackElement = horizontalElements._track;
                _scrollbarHorizontalHandleElement = horizontalElements._handle;
                _scrollbarVerticalElement = verticalElements._scrollbar;
                _scrollbarVerticalTrackElement = verticalElements._track;
                _scrollbarVerticalHandleElement = verticalElements._handle;
                if (!_domExists) {
                  _paddingElement.after(_scrollbarVerticalElement);
                  _paddingElement.after(_scrollbarHorizontalElement);
                }
              } else {
                resetScrollbarDOM(true);
                resetScrollbarDOM();
              }
            }
            function setupScrollbarEvents(isHorizontal) {
              var scrollbarVars = getScrollbarVars(isHorizontal);
              var scrollbarVarsInfo = scrollbarVars._info;
              var insideIFrame = _windowElementNative.top !== _windowElementNative;
              var xy = scrollbarVars._x_y;
              var XY = scrollbarVars._X_Y;
              var scroll = _strScroll + scrollbarVars._Left_Top;
              var strActive = "active";
              var strSnapHandle = "snapHandle";
              var strClickEvent = "click";
              var scrollDurationFactor = 1;
              var increaseDecreaseScrollAmountKeyCodes = [16, 17];
              var trackTimeout;
              var mouseDownScroll;
              var mouseDownOffset;
              var mouseDownInvertedScale;
              function getPointerPosition(event) {
                return _msieVersion && insideIFrame ? event["screen" + XY] : COMPATIBILITY.page(event)[xy];
              }
              function getPreparedScrollbarsOption(name) {
                return _currentPreparedOptions.scrollbars[name];
              }
              function increaseTrackScrollAmount() {
                scrollDurationFactor = 0.5;
              }
              function decreaseTrackScrollAmount() {
                scrollDurationFactor = 1;
              }
              function stopClickEventPropagation(event) {
                COMPATIBILITY.stpP(event);
              }
              function documentKeyDown(event) {
                if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                  increaseTrackScrollAmount();
              }
              function documentKeyUp(event) {
                if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                  decreaseTrackScrollAmount();
              }
              function onMouseTouchDownContinue(event) {
                var originalEvent = event.originalEvent || event;
                var isTouchEvent = originalEvent.touches !== undefined2;
                return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || isTouchEvent && !getPreparedScrollbarsOption("touchSupport") ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
              }
              function documentDragMove(event) {
                if (onMouseTouchDownContinue(event)) {
                  var trackLength = scrollbarVarsInfo._trackLength;
                  var handleLength = scrollbarVarsInfo._handleLength;
                  var scrollRange = scrollbarVarsInfo._maxScroll;
                  var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                  var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                  var scrollDelta = scrollRange * scrollDeltaPercent;
                  scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                  if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                    scrollDelta *= -1;
                  _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));
                  if (_scrollbarsHandlesDefineScrollPos)
                    refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);
                  if (!_supportPassiveEvents)
                    COMPATIBILITY.prvD(event);
                } else
                  documentMouseTouchUp(event);
              }
              function documentMouseTouchUp(event) {
                event = event || event.originalEvent;
                setupResponsiveEventListener(
                  _documentElement,
                  [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                  [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                  true
                );
                COMPATIBILITY.rAF()(function() {
                  setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                });
                if (_scrollbarsHandlesDefineScrollPos)
                  refreshScrollbarHandleOffset(isHorizontal, true);
                _scrollbarsHandlesDefineScrollPos = false;
                removeClass(_bodyElement, _classNameDragging);
                removeClass(scrollbarVars._handle, strActive);
                removeClass(scrollbarVars._track, strActive);
                removeClass(scrollbarVars._scrollbar, strActive);
                mouseDownScroll = undefined2;
                mouseDownOffset = undefined2;
                mouseDownInvertedScale = 1;
                decreaseTrackScrollAmount();
                if (trackTimeout !== undefined2) {
                  _base.scrollStop();
                  clearTimeout(trackTimeout);
                  trackTimeout = undefined2;
                }
                if (event) {
                  var rect = _hostElementNative[LEXICON.bCR]();
                  var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;
                  if (!mouseInsideHost)
                    hostOnMouseLeave();
                  if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                    refreshScrollbarsAutoHide(false);
                }
              }
              function onHandleMouseTouchDown(event) {
                if (onMouseTouchDownContinue(event))
                  onHandleMouseTouchDownAction(event);
              }
              function onHandleMouseTouchDownAction(event) {
                mouseDownScroll = _viewportElement[scroll]();
                mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
                  mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;
                mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                mouseDownOffset = getPointerPosition(event);
                _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                addClass(_bodyElement, _classNameDragging);
                addClass(scrollbarVars._handle, strActive);
                addClass(scrollbarVars._scrollbar, strActive);
                setupResponsiveEventListener(
                  _documentElement,
                  [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                  [documentDragMove, documentMouseTouchUp, documentOnSelectStart]
                );
                COMPATIBILITY.rAF()(function() {
                  setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                });
                if (_msieVersion || !_documentMixed)
                  COMPATIBILITY.prvD(event);
                COMPATIBILITY.stpP(event);
              }
              function onTrackMouseTouchDown(event) {
                if (onMouseTouchDownContinue(event)) {
                  var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
                  var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
                  var scrollBaseDuration = 270 * handleToViewportRatio;
                  var scrollFirstIterationDelay = 400 * handleToViewportRatio;
                  var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
                  var ctrlKey = event.ctrlKey;
                  var instantScroll = event.shiftKey;
                  var instantScrollTransition = instantScroll && ctrlKey;
                  var isFirstIteration = true;
                  var easing = "linear";
                  var decreaseScroll;
                  var finishedCondition;
                  var scrollActionFinsished = function(transition) {
                    if (_scrollbarsHandlesDefineScrollPos)
                      refreshScrollbarHandleOffset(isHorizontal, transition);
                  };
                  var scrollActionInstantFinished = function() {
                    scrollActionFinsished();
                    onHandleMouseTouchDownAction(event);
                  };
                  var scrollAction = function() {
                    if (!_destroyed) {
                      var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                      var handleOffset = scrollbarVarsInfo._handleOffset;
                      var trackLength = scrollbarVarsInfo._trackLength;
                      var handleLength = scrollbarVarsInfo._handleLength;
                      var scrollRange = scrollbarVarsInfo._maxScroll;
                      var currScroll = scrollbarVarsInfo._currentScroll;
                      var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                      var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                      var instantScrollPosition = scrollRange * ((mouseOffset - handleLength / 2) / (trackLength - handleLength));
                      var rtlIsNormal = _isRTL && isHorizontal && (!_rtlScrollBehavior.i && !_rtlScrollBehavior.n || _normalizeRTLCache);
                      var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                      var scrollObj = {};
                      var animationObj = {
                        easing,
                        step: function(now) {
                          if (_scrollbarsHandlesDefineScrollPos) {
                            _viewportElement[scroll](now);
                            refreshScrollbarHandleOffset(isHorizontal, now);
                          }
                        }
                      };
                      instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                      instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                      if (instantScroll) {
                        _viewportElement[scroll](instantScrollPosition);
                        if (instantScrollTransition) {
                          instantScrollPosition = _viewportElement[scroll]();
                          _viewportElement[scroll](currScroll);
                          instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                          instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;
                          scrollObj[xy] = instantScrollPosition;
                          _base.scroll(scrollObj, extendDeep(animationObj, {
                            duration: 130,
                            complete: scrollActionInstantFinished
                          }));
                        } else
                          scrollActionInstantFinished();
                      } else {
                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                        finishedCondition = rtlIsNormal ? decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset : decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset;
                        if (finishedCondition) {
                          clearTimeout(trackTimeout);
                          _base.scrollStop();
                          trackTimeout = undefined2;
                          scrollActionFinsished(true);
                        } else {
                          trackTimeout = setTimeout(scrollAction, timeoutDelay);
                          scrollObj[xy] = (decreaseScroll ? "-=" : "+=") + scrollDistance;
                          _base.scroll(scrollObj, extendDeep(animationObj, {
                            duration: scrollDuration
                          }));
                        }
                        isFirstIteration = false;
                      }
                    }
                  };
                  if (ctrlKey)
                    increaseTrackScrollAmount();
                  mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                  mouseDownOffset = COMPATIBILITY.page(event)[xy];
                  _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                  addClass(_bodyElement, _classNameDragging);
                  addClass(scrollbarVars._track, strActive);
                  addClass(scrollbarVars._scrollbar, strActive);
                  setupResponsiveEventListener(
                    _documentElement,
                    [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                    [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]
                  );
                  scrollAction();
                  COMPATIBILITY.prvD(event);
                  COMPATIBILITY.stpP(event);
                }
              }
              function onTrackMouseTouchEnter(event) {
                _scrollbarsHandleHovered = true;
                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                  refreshScrollbarsAutoHide(true);
              }
              function onTrackMouseTouchLeave(event) {
                _scrollbarsHandleHovered = false;
                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                  refreshScrollbarsAutoHide(false);
              }
              function onScrollbarMouseTouchDown(event) {
                COMPATIBILITY.stpP(event);
              }
              addDestroyEventListener(
                scrollbarVars._handle,
                _strMouseTouchDownEvent,
                onHandleMouseTouchDown
              );
              addDestroyEventListener(
                scrollbarVars._track,
                [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],
                [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]
              );
              addDestroyEventListener(
                scrollbarVars._scrollbar,
                _strMouseTouchDownEvent,
                onScrollbarMouseTouchDown
              );
              if (_supportTransition) {
                addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function(event) {
                  if (event.target !== scrollbarVars._scrollbar[0])
                    return;
                  refreshScrollbarHandleLength(isHorizontal);
                  refreshScrollbarHandleOffset(isHorizontal);
                });
              }
            }
            function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
              var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
              var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;
              addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
              addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
            }
            function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
              clearTimeout(_scrollbarsAutoHideTimeoutId);
              if (shallBeVisible) {
                removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
              } else {
                var anyActive;
                var strActive = "active";
                var hide = function() {
                  if (!_scrollbarsHandleHovered && !_destroyed) {
                    anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                    if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                      addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                    if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                      addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                  }
                };
                if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
                  _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                else
                  hide();
              }
            }
            function refreshScrollbarHandleLength(isHorizontal) {
              var handleCSS = {};
              var scrollbarVars = getScrollbarVars(isHorizontal);
              var scrollbarVarsInfo = scrollbarVars._info;
              var digit = 1e6;
              var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
              handleCSS[scrollbarVars._width_height] = MATH.floor(handleRatio * 100 * digit) / digit + "%";
              if (!nativeOverlayScrollbarsAreActive())
                scrollbarVars._handle.css(handleCSS);
              scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]["offset" + scrollbarVars._Width_Height];
              scrollbarVarsInfo._handleLengthRatio = handleRatio;
            }
            function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
              var transition = type(scrollOrTransition) == TYPES.b;
              var transitionDuration = 250;
              var isRTLisHorizontal = _isRTL && isHorizontal;
              var scrollbarVars = getScrollbarVars(isHorizontal);
              var scrollbarVarsInfo = scrollbarVars._info;
              var strTranslateBrace = "translate(";
              var strTransform = VENDORS._cssProperty("transform");
              var strTransition = VENDORS._cssProperty("transition");
              var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
              var currentScroll = scrollOrTransition === undefined2 || transition ? nativeScroll : scrollOrTransition;
              var handleLength = scrollbarVarsInfo._handleLength;
              var trackLength = scrollbarVars._track[0]["offset" + scrollbarVars._Width_Height];
              var handleTrackDiff = trackLength - handleLength;
              var handleCSS = {};
              var transformOffset;
              var translateValue;
              var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative["client" + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1);
              var getScrollRatio = function(base) {
                return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
              };
              var getHandleOffset = function(scrollRatio2) {
                var offset = handleTrackDiff * scrollRatio2;
                offset = isNaN(offset) ? 0 : offset;
                offset = isRTLisHorizontal && !_rtlScrollBehavior.i ? trackLength - handleLength - offset : offset;
                offset = MATH.max(0, offset);
                return offset;
              };
              var scrollRatio = getScrollRatio(nativeScroll);
              var unsnappedScrollRatio = getScrollRatio(currentScroll);
              var handleOffset = getHandleOffset(unsnappedScrollRatio);
              var snappedHandleOffset = getHandleOffset(scrollRatio);
              scrollbarVarsInfo._maxScroll = maxScroll;
              scrollbarVarsInfo._currentScroll = nativeScroll;
              scrollbarVarsInfo._currentScrollRatio = scrollRatio;
              if (_supportTransform) {
                transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset;
                translateValue = isHorizontal ? strTranslateBrace + transformOffset + "px, 0)" : strTranslateBrace + "0, " + transformOffset + "px)";
                handleCSS[strTransform] = translateValue;
                if (_supportTransition)
                  handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ", " + (strTransform + _strSpace + transitionDuration + "ms") : _strEmpty;
              } else
                handleCSS[scrollbarVars._left_top] = handleOffset;
              if (!nativeOverlayScrollbarsAreActive()) {
                scrollbarVars._handle.css(handleCSS);
                if (_supportTransform && _supportTransition && transition) {
                  scrollbarVars._handle.one(_strTransitionEndEvent, function() {
                    if (!_destroyed)
                      scrollbarVars._handle.css(strTransition, _strEmpty);
                  });
                }
              }
              scrollbarVarsInfo._handleOffset = handleOffset;
              scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
              scrollbarVarsInfo._trackLength = trackLength;
            }
            function refreshScrollbarsInteractive(isTrack, value) {
              var action = value ? "removeClass" : "addClass";
              var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
              var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
              var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;
              element1[action](className);
              element2[action](className);
            }
            function getScrollbarVars(isHorizontal) {
              return {
                _width_height: isHorizontal ? _strWidth : _strHeight,
                _Width_Height: isHorizontal ? "Width" : "Height",
                _left_top: isHorizontal ? _strLeft : _strTop,
                _Left_Top: isHorizontal ? "Left" : "Top",
                _x_y: isHorizontal ? _strX : _strY,
                _X_Y: isHorizontal ? "X" : "Y",
                _w_h: isHorizontal ? "w" : "h",
                _l_t: isHorizontal ? "l" : "t",
                _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
              };
            }
            function setupScrollbarCornerDOM(destroy) {
              _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);
              if (!destroy) {
                if (!_domExists) {
                  _hostElement.append(_scrollbarCornerElement);
                }
              } else {
                if (_domExists && _initialized) {
                  removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                } else {
                  remove(_scrollbarCornerElement);
                }
              }
            }
            function setupScrollbarCornerEvents() {
              var insideIFrame = _windowElementNative.top !== _windowElementNative;
              var mouseDownPosition = {};
              var mouseDownSize = {};
              var mouseDownInvertedScale = {};
              var reconnectMutationObserver;
              function documentDragMove(event) {
                if (onMouseTouchDownContinue(event)) {
                  var pageOffset = getCoordinates(event);
                  var hostElementCSS = {};
                  if (_resizeHorizontal || _resizeBoth)
                    hostElementCSS[_strWidth] = mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x;
                  if (_resizeVertical || _resizeBoth)
                    hostElementCSS[_strHeight] = mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y;
                  _hostElement.css(hostElementCSS);
                  COMPATIBILITY.stpP(event);
                } else {
                  documentMouseTouchUp(event);
                }
              }
              function documentMouseTouchUp(event) {
                var eventIsTrusted = event !== undefined2;
                setupResponsiveEventListener(
                  _documentElement,
                  [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                  [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                  true
                );
                removeClass(_bodyElement, _classNameDragging);
                if (_scrollbarCornerElement.releaseCapture)
                  _scrollbarCornerElement.releaseCapture();
                if (eventIsTrusted) {
                  if (reconnectMutationObserver)
                    connectMutationObservers();
                  _base.update(_strAuto);
                }
                reconnectMutationObserver = false;
              }
              function onMouseTouchDownContinue(event) {
                var originalEvent = event.originalEvent || event;
                var isTouchEvent = originalEvent.touches !== undefined2;
                return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
              }
              function getCoordinates(event) {
                return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
              }
              addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function(event) {
                if (onMouseTouchDownContinue(event) && !_resizeNone) {
                  if (_mutationObserversConnected) {
                    reconnectMutationObserver = true;
                    disconnectMutationObservers();
                  }
                  mouseDownPosition = getCoordinates(event);
                  mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                  mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                  mouseDownInvertedScale = getHostElementInvertedScale();
                  setupResponsiveEventListener(
                    _documentElement,
                    [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                    [documentOnSelectStart, documentDragMove, documentMouseTouchUp]
                  );
                  addClass(_bodyElement, _classNameDragging);
                  if (_scrollbarCornerElement.setCapture)
                    _scrollbarCornerElement.setCapture();
                  COMPATIBILITY.prvD(event);
                  COMPATIBILITY.stpP(event);
                }
              });
            }
            function dispatchCallback(name, args, dependent) {
              if (dependent === false)
                return;
              if (_initialized) {
                var callback = _currentPreparedOptions.callbacks[name];
                var extensionOnName = name;
                var ext;
                if (extensionOnName.substr(0, 2) === "on")
                  extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);
                if (type(callback) == TYPES.f)
                  callback.call(_base, args);
                each(_extensions, function() {
                  ext = this;
                  if (type(ext.on) == TYPES.f)
                    ext.on(extensionOnName, args);
                });
              } else if (!_destroyed)
                _callbacksInitQeueue.push({ n: name, a: args });
            }
            function setTopRightBottomLeft(targetCSSObject, prefix, values) {
              prefix = prefix || _strEmpty;
              values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];
              targetCSSObject[prefix + _strTop] = values[0];
              targetCSSObject[prefix + _strRight] = values[1];
              targetCSSObject[prefix + _strBottom] = values[2];
              targetCSSObject[prefix + _strLeft] = values[3];
            }
            function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
              suffix = suffix || _strEmpty;
              prefix = prefix || _strEmpty;
              return {
                t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
                r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
                b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
                l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
              };
            }
            function getCSSTransitionString(element) {
              var transitionStr = VENDORS._cssProperty("transition");
              var assembledValue = element.css(transitionStr);
              if (assembledValue)
                return assembledValue;
              var regExpString = "\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*";
              var regExpMain = new RegExp(regExpString);
              var regExpValidate = new RegExp("^(" + regExpString + ")+$");
              var properties = "property duration timing-function delay".split(" ");
              var result = [];
              var strResult;
              var valueArray;
              var i = 0;
              var j;
              var splitCssStyleByComma = function(str) {
                strResult = [];
                if (!str.match(regExpValidate))
                  return str;
                while (str.match(regExpMain)) {
                  strResult.push(RegExp.$1);
                  str = str.replace(regExpMain, _strEmpty);
                }
                return strResult;
              };
              for (; i < properties[LEXICON.l]; i++) {
                valueArray = splitCssStyleByComma(element.css(transitionStr + "-" + properties[i]));
                for (j = 0; j < valueArray[LEXICON.l]; j++)
                  result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
              }
              return result.join(", ");
            }
            function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
              var i;
              var split;
              var appendix;
              var appendClasses = function(classes, condition) {
                appendix = "";
                if (condition && typeof classes == TYPES.s) {
                  split = classes.split(_strSpace);
                  for (i = 0; i < split[LEXICON.l]; i++)
                    appendix += "|" + split[i] + "$";
                }
                return appendix;
              };
              return new RegExp(
                "(^" + _classNameHostElement + "([-_].+|)$)" + appendClasses(_classNameCache, withCurrClassNameOption) + appendClasses(_oldClassName, withOldClassNameOption),
                "g"
              );
            }
            function getHostElementInvertedScale() {
              var rect = _paddingElementNative[LEXICON.bCR]();
              return {
                x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
              };
            }
            function isHTMLElement(o) {
              var strOwnerDocument = "ownerDocument";
              var strHTMLElement = "HTMLElement";
              var wnd = o && o[strOwnerDocument] ? o[strOwnerDocument].parentWindow || window2 : window2;
              return typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s;
            }
            function getArrayDifferences(a1, a2) {
              var a = [];
              var diff = [];
              var i;
              var k;
              for (i = 0; i < a1.length; i++)
                a[a1[i]] = true;
              for (i = 0; i < a2.length; i++) {
                if (a[a2[i]])
                  delete a[a2[i]];
                else
                  a[a2[i]] = true;
              }
              for (k in a)
                diff.push(k);
              return diff;
            }
            function parseToZeroOrNumber(value, toFloat) {
              var num = toFloat ? parseFloat(value) : parseInt(value, 10);
              return isNaN(num) ? 0 : num;
            }
            function getTextareaInfo() {
              var textareaCursorPosition = _targetElementNative.selectionStart;
              if (textareaCursorPosition === undefined2)
                return;
              var textareaValue = _targetElement.val();
              var textareaLength = textareaValue[LEXICON.l];
              var textareaRowSplit = textareaValue.split("\n");
              var textareaLastRow = textareaRowSplit[LEXICON.l];
              var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split("\n");
              var widestRow = 0;
              var textareaLastCol = 0;
              var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
              var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
              var rowCols;
              var i;
              for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                rowCols = textareaRowSplit[i][LEXICON.l];
                if (rowCols > textareaLastCol) {
                  widestRow = i + 1;
                  textareaLastCol = rowCols;
                }
              }
              return {
                _cursorRow: cursorRow,
                _cursorColumn: cursorCol,
                _rows: textareaLastRow,
                _columns: textareaLastCol,
                _widestRow: widestRow,
                _cursorPosition: textareaCursorPosition,
                _cursorMax: textareaLength
              };
            }
            function nativeOverlayScrollbarsAreActive() {
              return _ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);
            }
            function getContentMeasureElement() {
              return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
            }
            function generateDiv(classesOrAttrs, content) {
              return "<div " + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ? 'class="' + classesOrAttrs + '"' : function() {
                var key;
                var attrs = _strEmpty;
                if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                  for (key in classesOrAttrs)
                    attrs += (key === "c" ? "class" : key) + '="' + classesOrAttrs[key] + '" ';
                }
                return attrs;
              }() : _strEmpty) + ">" + (content || _strEmpty) + "</div>";
            }
            function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
              var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
              var selectParent = onlyChildren ? _hostElement : selectParentOrOnlyChildren || _hostElement;
              return _domExists && !selectParent[LEXICON.l] ? null : _domExists ? selectParent[onlyChildren ? "children" : "find"](_strDot + className.replace(/\s/g, _strDot)).eq(0) : FRAMEWORK(generateDiv(className));
            }
            function getObjectPropVal(obj, path) {
              var splits = path.split(_strDot);
              var i = 0;
              var val;
              for (; i < splits.length; i++) {
                if (!obj[LEXICON.hOP](splits[i]))
                  return;
                val = obj[splits[i]];
                if (i < splits.length && type(val) == TYPES.o)
                  obj = val;
              }
              return val;
            }
            function setObjectPropVal(obj, path, val) {
              var splits = path.split(_strDot);
              var splitsLength = splits.length;
              var i = 0;
              var extendObj = {};
              var extendObjRoot = extendObj;
              for (; i < splitsLength; i++)
                extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
              FRAMEWORK.extend(obj, extendObjRoot, true);
            }
            function eachUpdateOnLoad(action) {
              var updateOnLoad = _currentPreparedOptions.updateOnLoad;
              updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;
              if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
                each(updateOnLoad, action);
              }
            }
            function checkCache(current, cache, force) {
              if (force)
                return force;
              if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                for (var prop in current) {
                  if (prop !== "c") {
                    if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                      if (checkCache(current[prop], cache[prop]))
                        return true;
                    } else {
                      return true;
                    }
                  }
                }
              } else {
                return current !== cache;
              }
              return false;
            }
            function extendDeep() {
              return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
            }
            function addClass(el, classes) {
              return _frameworkProto.addClass.call(el, classes);
            }
            function removeClass(el, classes) {
              return _frameworkProto.removeClass.call(el, classes);
            }
            function addRemoveClass(el, classes, doAdd) {
              return doAdd ? addClass(el, classes) : removeClass(el, classes);
            }
            function remove(el) {
              return _frameworkProto.remove.call(el);
            }
            function findFirst(el, selector) {
              return _frameworkProto.find.call(el, selector).eq(0);
            }
            _base.sleep = function() {
              _sleeping = true;
            };
            _base.update = function(force) {
              if (_destroyed)
                return;
              var attrsChanged;
              var contentSizeC;
              var isString = type(force) == TYPES.s;
              var doUpdateAuto;
              var mutHost;
              var mutContent;
              if (isString) {
                if (force === _strAuto) {
                  attrsChanged = meaningfulAttrsChanged();
                  contentSizeC = updateAutoContentSizeChanged();
                  doUpdateAuto = attrsChanged || contentSizeC;
                  if (doUpdateAuto) {
                    update({
                      _contentSizeChanged: contentSizeC,
                      _changedOptions: _initialized ? undefined2 : _currentPreparedOptions
                    });
                  }
                } else if (force === _strSync) {
                  if (_mutationObserversConnected) {
                    mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                    mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                  } else {
                    mutHost = _base.update(_strAuto);
                  }
                } else if (force === "zoom") {
                  update({
                    _hostSizeChanged: true,
                    _contentSizeChanged: true
                  });
                }
              } else {
                force = _sleeping || force;
                _sleeping = false;
                if (!_base.update(_strSync) || force)
                  update({ _force: force });
              }
              updateElementsOnLoad();
              return doUpdateAuto || mutHost || mutContent;
            };
            _base.options = function(newOptions, value) {
              var option = {};
              var changedOps;
              if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                if (type(newOptions) == TYPES.s) {
                  if (arguments.length > 1) {
                    setObjectPropVal(option, newOptions, value);
                    changedOps = setOptions(option);
                  } else
                    return getObjectPropVal(_currentOptions, newOptions);
                } else
                  return _currentOptions;
              } else {
                changedOps = setOptions(newOptions);
              }
              if (!FRAMEWORK.isEmptyObject(changedOps)) {
                update({ _changedOptions: changedOps });
              }
            };
            _base.destroy = function() {
              if (_destroyed)
                return;
              autoUpdateLoop.remove(_base);
              disconnectMutationObservers();
              setupResizeObserver(_sizeObserverElement);
              setupResizeObserver(_sizeAutoObserverElement);
              for (var extName in _extensions)
                _base.removeExt(extName);
              while (_destroyEvents[LEXICON.l] > 0)
                _destroyEvents.pop()();
              setupHostMouseTouchEvents(true);
              if (_contentGlueElement)
                remove(_contentGlueElement);
              if (_contentArrangeElement)
                remove(_contentArrangeElement);
              if (_sizeAutoObserverAdded)
                remove(_sizeAutoObserverElement);
              setupScrollbarsDOM(true);
              setupScrollbarCornerDOM(true);
              setupStructureDOM(true);
              for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
              _updateOnLoadElms = undefined2;
              _destroyed = true;
              _sleeping = true;
              INSTANCES(pluginTargetElement, 0);
              dispatchCallback("onDestroyed");
            };
            _base.scroll = function(coordinates, duration, easing, complete) {
              if (arguments.length === 0 || coordinates === undefined2) {
                var infoX = _scrollHorizontalInfo;
                var infoY = _scrollVerticalInfo;
                var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                var scrollX = infoX._currentScroll;
                var scrollXRatio = infoX._currentScrollRatio;
                var maxScrollX = infoX._maxScroll;
                scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                scrollX *= normalizeNegate ? -1 : 1;
                maxScrollX *= normalizeNegate ? -1 : 1;
                return {
                  position: {
                    x: scrollX,
                    y: infoY._currentScroll
                  },
                  ratio: {
                    x: scrollXRatio,
                    y: infoY._currentScrollRatio
                  },
                  max: {
                    x: maxScrollX,
                    y: infoY._maxScroll
                  },
                  handleOffset: {
                    x: infoX._handleOffset,
                    y: infoY._handleOffset
                  },
                  handleLength: {
                    x: infoX._handleLength,
                    y: infoY._handleLength
                  },
                  handleLengthRatio: {
                    x: infoX._handleLengthRatio,
                    y: infoY._handleLengthRatio
                  },
                  trackLength: {
                    x: infoX._trackLength,
                    y: infoY._trackLength
                  },
                  snappedHandleOffset: {
                    x: infoX._snappedHandleOffset,
                    y: infoY._snappedHandleOffset
                  },
                  isRTL: _isRTL,
                  isRTLNormalized: _normalizeRTLCache
                };
              }
              _base.update(_strSync);
              var normalizeRTL = _normalizeRTLCache;
              var coordinatesXAxisProps = [_strX, _strLeft, "l"];
              var coordinatesYAxisProps = [_strY, _strTop, "t"];
              var coordinatesOperators = ["+=", "-=", "*=", "/="];
              var durationIsObject = type(duration) == TYPES.o;
              var completeCallback = durationIsObject ? duration.complete : complete;
              var i;
              var finalScroll = {};
              var specialEasing = {};
              var doScrollLeft;
              var doScrollTop;
              var animationOptions;
              var strEnd = "end";
              var strBegin = "begin";
              var strCenter = "center";
              var strNearest = "nearest";
              var strAlways = "always";
              var strNever = "never";
              var strIfNeeded = "ifneeded";
              var strLength = LEXICON.l;
              var settingsAxis;
              var settingsScroll;
              var settingsBlock;
              var settingsMargin;
              var finalElement;
              var elementObjSettingsAxisValues = [_strX, _strY, "xy", "yx"];
              var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
              var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
              var coordinatesIsElementObj = coordinates[LEXICON.hOP]("el");
              var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
              var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
              var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
              var updateScrollbarInfos = function() {
                if (doScrollLeft)
                  refreshScrollbarHandleOffset(true);
                if (doScrollTop)
                  refreshScrollbarHandleOffset(false);
              };
              var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined2 : function() {
                updateScrollbarInfos();
                completeCallback();
              };
              function checkSettingsStringValue(currValue, allowedValues) {
                for (i = 0; i < allowedValues[strLength]; i++) {
                  if (currValue === allowedValues[i])
                    return true;
                }
                return false;
              }
              function getRawScroll(isX, coordinates2) {
                var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                coordinates2 = type(coordinates2) == TYPES.s || type(coordinates2) == TYPES.n ? [coordinates2, coordinates2] : coordinates2;
                if (COMPATIBILITY.isA(coordinates2))
                  return isX ? coordinates2[0] : coordinates2[1];
                else if (type(coordinates2) == TYPES.o) {
                  for (i = 0; i < coordinateProps[strLength]; i++)
                    if (coordinateProps[i] in coordinates2)
                      return coordinates2[coordinateProps[i]];
                }
              }
              function getFinalScroll(isX, rawScroll) {
                var isString = type(rawScroll) == TYPES.s;
                var operator;
                var amount;
                var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                var currScroll = scrollInfo._currentScroll;
                var maxScroll = scrollInfo._maxScroll;
                var mult = " * ";
                var finalValue;
                var isRTLisX = _isRTL && isX;
                var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                var strReplace = "replace";
                var evalFunc = eval;
                var possibleOperator;
                if (isString) {
                  if (rawScroll[strLength] > 2) {
                    possibleOperator = rawScroll.substr(0, 2);
                    if (inArray(possibleOperator, coordinatesOperators) > -1)
                      operator = possibleOperator;
                  }
                  rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                  rawScroll = rawScroll[strReplace](/min/g, 0)[strReplace](/</g, 0)[strReplace](/max/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/>/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/px/g, _strEmpty)[strReplace](/%/g, mult + maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100)[strReplace](/vw/g, mult + _viewportSize.w)[strReplace](/vh/g, mult + _viewportSize.h);
                  amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                } else {
                  amount = rawScroll;
                }
                if (amount !== undefined2 && !isNaN(amount) && type(amount) == TYPES.n) {
                  var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                  var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                  var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                  var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                  operatorCurrScroll = invert ? maxScroll - operatorCurrScroll : operatorCurrScroll;
                  switch (operator) {
                    case "+=":
                      finalValue = operatorCurrScroll + amount;
                      break;
                    case "-=":
                      finalValue = operatorCurrScroll - amount;
                      break;
                    case "*=":
                      finalValue = operatorCurrScroll * amount;
                      break;
                    case "/=":
                      finalValue = operatorCurrScroll / amount;
                      break;
                    default:
                      finalValue = amount;
                      break;
                  }
                  finalValue = invert ? maxScroll - finalValue : finalValue;
                  finalValue *= negate ? -1 : 1;
                  finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                }
                return finalValue === currScroll ? undefined2 : finalValue;
              }
              function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                var resultDefault = [defaultValue, defaultValue];
                var valueType = type(value);
                var valueArrLength;
                var valueArrItem;
                if (valueType == valueInternalType) {
                  value = [value, value];
                } else if (valueType == TYPES.a) {
                  valueArrLength = value[strLength];
                  if (valueArrLength > 2 || valueArrLength < 1)
                    value = resultDefault;
                  else {
                    if (valueArrLength === 1)
                      value[1] = defaultValue;
                    for (i = 0; i < valueArrLength; i++) {
                      valueArrItem = value[i];
                      if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                        value = resultDefault;
                        break;
                      }
                    }
                  }
                } else if (valueType == TYPES.o)
                  value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                else
                  value = resultDefault;
                return { x: value[0], y: value[1] };
              }
              function generateMargin(marginTopRightBottomLeftArray) {
                var result = [];
                var currValue;
                var currValueType;
                var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                  if (i === valueDirections[strLength])
                    break;
                  currValue = marginTopRightBottomLeftArray[i];
                  currValueType = type(currValue);
                  if (currValueType == TYPES.b)
                    result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                  else
                    result.push(currValueType == TYPES.n ? currValue : 0);
                }
                return result;
              }
              if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                var block = coordinatesIsElementObj ? coordinates.block : 0;
                var marginDefault = [0, 0, 0, 0];
                var marginType = type(margin);
                var marginLength;
                finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);
                if (finalElement[strLength] > 0) {
                  if (marginType == TYPES.n || marginType == TYPES.b)
                    margin = generateMargin([margin, margin, margin, margin]);
                  else if (marginType == TYPES.a) {
                    marginLength = margin[strLength];
                    if (marginLength === 2)
                      margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                    else if (marginLength >= 4)
                      margin = generateMargin(margin);
                    else
                      margin = marginDefault;
                  } else if (marginType == TYPES.o)
                    margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                  else
                    margin = marginDefault;
                  settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : "xy";
                  settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                  settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                  settingsMargin = margin;
                  var viewportScroll = {
                    l: _scrollHorizontalInfo._currentScroll,
                    t: _scrollVerticalInfo._currentScroll
                  };
                  var viewportOffset = _paddingElement.offset();
                  var elementOffset = finalElement.offset();
                  var doNotScroll = {
                    x: settingsScroll.x == strNever || settingsAxis == _strY,
                    y: settingsScroll.y == strNever || settingsAxis == _strX
                  };
                  elementOffset[_strTop] -= settingsMargin[0];
                  elementOffset[_strLeft] -= settingsMargin[3];
                  var elementScrollCoordinates = {
                    x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                    y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                  };
                  if (_isRTL) {
                    if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                      elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                    if (_rtlScrollBehavior.n && normalizeRTL)
                      elementScrollCoordinates.x *= -1;
                    if (_rtlScrollBehavior.i && normalizeRTL)
                      elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                  }
                  if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                    var measuringElm = finalElement[0];
                    var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                      width: measuringElm[LEXICON.oW],
                      height: measuringElm[LEXICON.oH]
                    };
                    var elementSize = {
                      w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                      h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                    };
                    var finalizeBlock = function(isX) {
                      var vars = getScrollbarVars(isX);
                      var wh = vars._w_h;
                      var lt = vars._left_top;
                      var xy = vars._x_y;
                      var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                      var blockIsCenter = settingsBlock[xy] == strCenter;
                      var blockIsNearest = settingsBlock[xy] == strNearest;
                      var scrollNever = settingsScroll[xy] == strNever;
                      var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                      var vpSize = _viewportSize[wh];
                      var vpOffset = viewportOffset[lt];
                      var elSize = elementSize[wh];
                      var elOffset = elementOffset[lt];
                      var divide = blockIsCenter ? 2 : 1;
                      var elementCenterOffset = elOffset + elSize / 2;
                      var viewportCenterOffset = vpOffset + vpSize / 2;
                      var isInView = elSize <= vpSize && elOffset >= vpOffset && elOffset + elSize <= vpOffset + vpSize;
                      if (scrollNever)
                        doNotScroll[xy] = true;
                      else if (!doNotScroll[xy]) {
                        if (blockIsNearest || scrollIfNeeded) {
                          doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                          blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                        }
                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? (vpSize / divide - elSize / divide) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                      }
                    };
                    finalizeBlock(true);
                    finalizeBlock(false);
                  }
                  if (doNotScroll.y)
                    delete elementScrollCoordinates.y;
                  if (doNotScroll.x)
                    delete elementScrollCoordinates.x;
                  coordinates = elementScrollCoordinates;
                }
              }
              finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
              finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
              doScrollLeft = finalScroll[_strScrollLeft] !== undefined2;
              doScrollTop = finalScroll[_strScrollTop] !== undefined2;
              if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                if (durationIsObject) {
                  duration.complete = proxyCompleteCallback;
                  _viewportElement.animate(finalScroll, duration);
                } else {
                  animationOptions = {
                    duration,
                    complete: proxyCompleteCallback
                  };
                  if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
                    specialEasing[_strScrollLeft] = easing[0] || easing.x;
                    specialEasing[_strScrollTop] = easing[1] || easing.y;
                    animationOptions.specialEasing = specialEasing;
                  } else {
                    animationOptions.easing = easing;
                  }
                  _viewportElement.animate(finalScroll, animationOptions);
                }
              } else {
                if (doScrollLeft)
                  _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                if (doScrollTop)
                  _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                updateScrollbarInfos();
              }
            };
            _base.scrollStop = function(param1, param2, param3) {
              _viewportElement.stop(param1, param2, param3);
              return _base;
            };
            _base.getElements = function(elementName) {
              var obj = {
                target: _targetElementNative,
                host: _hostElementNative,
                padding: _paddingElementNative,
                viewport: _viewportElementNative,
                content: _contentElementNative,
                scrollbarHorizontal: {
                  scrollbar: _scrollbarHorizontalElement[0],
                  track: _scrollbarHorizontalTrackElement[0],
                  handle: _scrollbarHorizontalHandleElement[0]
                },
                scrollbarVertical: {
                  scrollbar: _scrollbarVerticalElement[0],
                  track: _scrollbarVerticalTrackElement[0],
                  handle: _scrollbarVerticalHandleElement[0]
                },
                scrollbarCorner: _scrollbarCornerElement[0]
              };
              return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
            };
            _base.getState = function(stateProperty) {
              function prepare(obj2) {
                if (!FRAMEWORK.isPlainObject(obj2))
                  return obj2;
                var extended = extendDeep({}, obj2);
                var changePropertyName = function(from, to) {
                  if (extended[LEXICON.hOP](from)) {
                    extended[to] = extended[from];
                    delete extended[from];
                  }
                };
                changePropertyName("w", _strWidth);
                changePropertyName("h", _strHeight);
                delete extended.c;
                return extended;
              }
              ;
              var obj = {
                destroyed: !!prepare(_destroyed),
                sleeping: !!prepare(_sleeping),
                autoUpdate: prepare(!_mutationObserversConnected),
                widthAuto: prepare(_widthAutoCache),
                heightAuto: prepare(_heightAutoCache),
                padding: prepare(_cssPaddingCache),
                overflowAmount: prepare(_overflowAmountCache),
                hideOverflow: prepare(_hideOverflowCache),
                hasOverflow: prepare(_hasOverflowCache),
                contentScrollSize: prepare(_contentScrollSizeCache),
                viewportSize: prepare(_viewportSize),
                hostSize: prepare(_hostSizeCache),
                documentMixed: prepare(_documentMixed)
              };
              return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
            };
            _base.ext = function(extName) {
              var result;
              var privateMethods = _extensionsPrivateMethods.split(" ");
              var i = 0;
              if (type(extName) == TYPES.s) {
                if (_extensions[LEXICON.hOP](extName)) {
                  result = extendDeep({}, _extensions[extName]);
                  for (; i < privateMethods.length; i++)
                    delete result[privateMethods[i]];
                }
              } else {
                result = {};
                for (i in _extensions)
                  result[i] = extendDeep({}, _base.ext(i));
              }
              return result;
            };
            _base.addExt = function(extName, extensionOptions) {
              var registeredExtensionObj = _plugin.extension(extName);
              var instance;
              var instanceAdded;
              var instanceContract;
              var contractResult;
              var contractFulfilled = true;
              if (registeredExtensionObj) {
                if (!_extensions[LEXICON.hOP](extName)) {
                  instance = registeredExtensionObj.extensionFactory.call(
                    _base,
                    extendDeep({}, registeredExtensionObj.defaultOptions),
                    FRAMEWORK,
                    COMPATIBILITY
                  );
                  if (instance) {
                    instanceContract = instance.contract;
                    if (type(instanceContract) == TYPES.f) {
                      contractResult = instanceContract(window2);
                      contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                    }
                    if (contractFulfilled) {
                      _extensions[extName] = instance;
                      instanceAdded = instance.added;
                      if (type(instanceAdded) == TYPES.f)
                        instanceAdded(extensionOptions);
                      return _base.ext(extName);
                    }
                  }
                } else
                  return _base.ext(extName);
              } else
                console.warn('A extension with the name "' + extName + `" isn't registered.`);
            };
            _base.removeExt = function(extName) {
              var instance = _extensions[extName];
              var instanceRemoved;
              if (instance) {
                delete _extensions[extName];
                instanceRemoved = instance.removed;
                if (type(instanceRemoved) == TYPES.f)
                  instanceRemoved();
                return true;
              }
              return false;
            };
            function construct(targetElement, options2, extensions2) {
              _defaultOptions = globals.defaultOptions;
              _nativeScrollbarStyling = globals.nativeScrollbarStyling;
              _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
              _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
              _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
              _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);
              setOptions(extendDeep({}, _defaultOptions, options2));
              _cssCalc = globals.cssCalc;
              _msieVersion = globals.msie;
              _autoUpdateRecommended = globals.autoUpdateRecommended;
              _supportTransition = globals.supportTransition;
              _supportTransform = globals.supportTransform;
              _supportPassiveEvents = globals.supportPassiveEvents;
              _supportResizeObserver = globals.supportResizeObserver;
              _supportMutationObserver = globals.supportMutationObserver;
              _restrictedMeasuring = globals.restrictedMeasuring;
              _documentElement = FRAMEWORK(targetElement.ownerDocument);
              _documentElementNative = _documentElement[0];
              _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
              _windowElementNative = _windowElement[0];
              _htmlElement = findFirst(_documentElement, "html");
              _bodyElement = findFirst(_htmlElement, "body");
              _targetElement = FRAMEWORK(targetElement);
              _targetElementNative = _targetElement[0];
              _isTextarea = _targetElement.is("textarea");
              _isBody = _targetElement.is("body");
              _documentMixed = _documentElementNative !== document;
              _domExists = _isTextarea ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement) : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];
              var initBodyScroll;
              var bodyMouseTouchDownListener;
              if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                _initialized = true;
                dispatchCallback("onInitializationWithdrawn");
                if (_domExists) {
                  setupStructureDOM(true);
                  setupScrollbarsDOM(true);
                  setupScrollbarCornerDOM(true);
                }
                _initialized = false;
                _destroyed = true;
                _sleeping = true;
                return _base;
              }
              if (_isBody) {
                initBodyScroll = {};
                initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());
                bodyMouseTouchDownListener = function() {
                  _viewportElement.removeAttr(LEXICON.ti);
                  setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
                };
              }
              setupStructureDOM();
              setupScrollbarsDOM();
              setupScrollbarCornerDOM();
              setupStructureEvents();
              setupScrollbarEvents(true);
              setupScrollbarEvents(false);
              setupScrollbarCornerEvents();
              createMutationObservers();
              setupResizeObserver(_sizeObserverElement, hostOnResized);
              if (_isBody) {
                _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);
                if (document.activeElement == targetElement && _viewportElementNative.focus) {
                  _viewportElement.attr(LEXICON.ti, "-1");
                  _viewportElementNative.focus();
                  setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
                }
              }
              _base.update(_strAuto);
              _initialized = true;
              dispatchCallback("onInitialized");
              each(_callbacksInitQeueue, function(index, value) {
                dispatchCallback(value.n, value.a);
              });
              _callbacksInitQeueue = [];
              if (type(extensions2) == TYPES.s)
                extensions2 = [extensions2];
              if (COMPATIBILITY.isA(extensions2))
                each(extensions2, function(index, value) {
                  _base.addExt(value);
                });
              else if (FRAMEWORK.isPlainObject(extensions2))
                each(extensions2, function(key, value) {
                  _base.addExt(key, value);
                });
              setTimeout(function() {
                if (_supportTransition && !_destroyed)
                  addClass(_hostElement, _classNameHostTransition);
              }, 333);
              return _base;
            }
            if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
              INSTANCES(pluginTargetElement, _base);
            }
            return _base;
          }
          _plugin = window2[PLUGINNAME] = function(pluginTargetElements, options, extensions) {
            if (arguments[LEXICON.l] === 0)
              return this;
            var arr = [];
            var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
            var inst;
            var result;
            if (!pluginTargetElements)
              return optsIsPlainObj || !options ? result : arr;
            pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined2 ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
            initOverlayScrollbarsStatics();
            if (pluginTargetElements[LEXICON.l] > 0) {
              if (optsIsPlainObj) {
                FRAMEWORK.each(pluginTargetElements, function(i, v) {
                  inst = v;
                  if (inst !== undefined2)
                    arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                });
              } else {
                FRAMEWORK.each(pluginTargetElements, function(i, v) {
                  inst = INSTANCES(v);
                  if (options === "!" && _plugin.valid(inst) || COMPATIBILITY.type(options) == TYPES.f && options(v, inst))
                    arr.push(inst);
                  else if (options === undefined2)
                    arr.push(inst);
                });
              }
              result = arr[LEXICON.l] === 1 ? arr[0] : arr;
            }
            return result;
          };
          _plugin.globals = function() {
            initOverlayScrollbarsStatics();
            var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
            delete globals["msie"];
            return globals;
          };
          _plugin.defaultOptions = function(newDefaultOptions) {
            initOverlayScrollbarsStatics();
            var currDefaultOptions = _pluginsGlobals.defaultOptions;
            if (newDefaultOptions === undefined2)
              return FRAMEWORK.extend(true, {}, currDefaultOptions);
            _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
          };
          _plugin.valid = function(osInstance) {
            return osInstance instanceof _plugin && !osInstance.getState().destroyed;
          };
          _plugin.extension = function(extensionName, extension, defaultOptions) {
            var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
            var argLen = arguments[LEXICON.l];
            var i = 0;
            if (argLen < 1 || !extNameTypeString) {
              return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
            } else if (extNameTypeString) {
              if (COMPATIBILITY.type(extension) == TYPES.f) {
                _pluginsExtensions.push({
                  name: extensionName,
                  extensionFactory: extension,
                  defaultOptions
                });
              } else {
                for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                  if (_pluginsExtensions[i].name === extensionName) {
                    if (argLen > 1)
                      _pluginsExtensions.splice(i, 1);
                    else
                      return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]);
                  }
                }
              }
            }
          };
          return _plugin;
        }();
        if (JQUERY && JQUERY.fn) {
          JQUERY.fn.overlayScrollbars = function(options, extensions) {
            var _elements = this;
            if (JQUERY.isPlainObject(options)) {
              JQUERY.each(_elements, function() {
                PLUGIN(this, options, extensions);
              });
              return _elements;
            } else
              return PLUGIN(_elements, options);
          };
        }
        return PLUGIN;
      }
    );
  }
});

// node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js
var import_react = __toESM(require_react());
var import_overlayscrollbars = __toESM(require_OverlayScrollbars());
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var OverlayScrollbarsComponent = class extends import_react.Component {
  constructor(props) {
    super(props);
    this._osInstance = null;
    this._osTargetRef = import_react.default.createRef();
  }
  osInstance() {
    return this._osInstance;
  }
  osTarget() {
    return this._osTargetRef.current || null;
  }
  componentDidMount() {
    this._osInstance = (0, import_overlayscrollbars.default)(this.osTarget(), this.props.options || {}, this.props.extensions);
    mergeHostClassNames(this._osInstance, this.props.className);
  }
  componentWillUnmount() {
    if (import_overlayscrollbars.default.valid(this._osInstance)) {
      this._osInstance.destroy();
      this._osInstance = null;
    }
  }
  componentDidUpdate(prevProps) {
    if (import_overlayscrollbars.default.valid(this._osInstance)) {
      this._osInstance.options(this.props.options);
      if (prevProps.className !== this.props.className) {
        mergeHostClassNames(this._osInstance, this.props.className);
      }
    }
  }
  render() {
    const _a = this.props, divProps = __rest(_a, ["options", "extensions", "children", "className"]);
    return import_react.default.createElement(
      "div",
      Object.assign({ className: "os-host" }, divProps, { ref: this._osTargetRef }),
      import_react.default.createElement("div", { className: "os-resize-observer-host" }),
      import_react.default.createElement(
        "div",
        { className: "os-padding" },
        import_react.default.createElement(
          "div",
          { className: "os-viewport" },
          import_react.default.createElement("div", { className: "os-content" }, this.props.children)
        )
      ),
      import_react.default.createElement(
        "div",
        { className: "os-scrollbar os-scrollbar-horizontal " },
        import_react.default.createElement(
          "div",
          { className: "os-scrollbar-track" },
          import_react.default.createElement("div", { className: "os-scrollbar-handle" })
        )
      ),
      import_react.default.createElement(
        "div",
        { className: "os-scrollbar os-scrollbar-vertical" },
        import_react.default.createElement(
          "div",
          { className: "os-scrollbar-track" },
          import_react.default.createElement("div", { className: "os-scrollbar-handle" })
        )
      ),
      import_react.default.createElement("div", { className: "os-scrollbar-corner" })
    );
  }
};
function mergeHostClassNames(osInstance, className) {
  if (import_overlayscrollbars.default.valid(osInstance)) {
    const { host } = osInstance.getElements();
    const regex = new RegExp(`(^os-host([-_].+|)$)|${osInstance.options().className.replace(/\s/g, "$|")}$`, "g");
    const osClassNames = host.className.split(" ").filter((name) => name.match(regex)).join(" ");
    host.className = `${osClassNames} ${className || ""}`;
  }
}
export {
  OverlayScrollbarsComponent
};
/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.3
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 20.07.2022
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
//# sourceMappingURL=overlayscrollbars-react.js.map
