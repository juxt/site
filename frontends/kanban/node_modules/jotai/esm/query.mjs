import { QueryClient, QueryObserver, InfiniteQueryObserver, isCancelledError } from '@tanstack/query-core';
import { atom } from 'jotai';

const queryClientAtom = atom(new QueryClient());

function atomWithQuery(createQuery, getQueryClient = (get) => get(queryClientAtom)) {
  const observerAtom = atom((get) => {
    const queryClient = getQueryClient(get);
    const defaultedOptions = queryClient.defaultQueryOptions();
    const observer = new QueryObserver(queryClient, defaultedOptions);
    return observer;
  });
  const queryDataAtom = atom(
    (get) => {
      const queryClient = getQueryClient(get);
      const options = typeof createQuery === "function" ? createQuery(get) : createQuery;
      const defaultedOptions = queryClient.defaultQueryOptions(options);
      const observer = get(observerAtom);
      observer.destroy();
      observer.setOptions(defaultedOptions);
      const initialResult = observer.getCurrentResult();
      let resolve = null;
      const resultAtom = atom(
        initialResult.data === void 0 && options.enabled !== false ? new Promise((r) => {
          resolve = r;
        }) : initialResult
      );
      let setResult = null;
      let unsubscribe = null;
      const unsubIfNotMounted = () => {
        if (!setResult) {
          unsubscribe == null ? void 0 : unsubscribe();
          unsubscribe = null;
        }
      };
      const listener = (result) => {
        if (result.isFetching || !result.isError && result.data === void 0) {
          return;
        }
        if (resolve) {
          setTimeout(unsubIfNotMounted, 1e3);
          resolve(result);
          resolve = null;
        } else if (setResult) {
          setResult(result);
        } else {
          throw new Error("setting result without mount");
        }
      };
      if (options.enabled !== false) {
        unsubscribe = observer.subscribe(listener);
      }
      resultAtom.onMount = (update) => {
        setResult = update;
        if (options.enabled !== false && !unsubscribe) {
          unsubscribe = observer.subscribe(listener);
          listener(observer.getCurrentResult());
        }
        return () => {
          setResult = null;
          unsubscribe == null ? void 0 : unsubscribe();
        };
      };
      return { options, resultAtom, unsubIfNotMounted };
    },
    (get, set, action) => {
      const observer = get(observerAtom);
      const { options, resultAtom, unsubIfNotMounted } = get(queryDataAtom);
      if (options.enabled === false) {
        return;
      }
      switch (action.type) {
        case "refetch": {
          set(resultAtom, new Promise(() => {
          }));
          unsubIfNotMounted();
          return observer.refetch({ cancelRefetch: true }).then((result) => {
            set(resultAtom, result);
          });
        }
      }
    }
  );
  const queryAtom = atom(
    (get) => {
      const { resultAtom } = get(queryDataAtom);
      const result = get(resultAtom);
      if (result.isError) {
        throw result.error;
      }
      return result.data;
    },
    (_get, set, action) => set(queryDataAtom, action)
  );
  return queryAtom;
}

function atomWithInfiniteQuery(createQuery, getQueryClient = (get) => get(queryClientAtom)) {
  const queryDataAtom = atom(
    (get) => {
      const queryClient = getQueryClient(get);
      const options = typeof createQuery === "function" ? createQuery(get) : createQuery;
      const defaultedOptions = queryClient.defaultQueryOptions(options);
      const observer = new InfiniteQueryObserver(queryClient, defaultedOptions);
      const initialResult = observer.getCurrentResult();
      let resolve = null;
      const resultAtom = atom(
        initialResult.data === void 0 && options.enabled !== false ? new Promise((r) => {
          resolve = r;
        }) : initialResult
      );
      let setResult = () => {
        throw new Error("setting result without mount");
      };
      const state = {
        isMounted: false,
        unsubscribe: null
      };
      const listener = (result) => {
        if (result.isFetching || !result.isError && result.data === void 0 || result.isError && isCancelledError(result.error)) {
          return;
        }
        if (resolve) {
          setTimeout(() => {
            var _a;
            if (!state.isMounted) {
              (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
              state.unsubscribe = null;
            }
          }, 1e3);
          resolve(result);
          resolve = null;
        } else {
          setResult(result);
        }
      };
      if (options.enabled !== false) {
        state.unsubscribe = observer.subscribe(listener);
      }
      resultAtom.onMount = (update) => {
        setResult = update;
        state.isMounted = true;
        if (options.enabled !== false && !state.unsubscribe) {
          state.unsubscribe = observer.subscribe(listener);
          listener(observer.getCurrentResult());
        }
        return () => {
          var _a;
          return (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
        };
      };
      return { options, resultAtom, observer, state };
    },
    (get, set, action) => {
      var _a;
      const { options, resultAtom, observer, state } = get(queryDataAtom);
      if (options.enabled === false) {
        return;
      }
      switch (action.type) {
        case "refetch": {
          set(resultAtom, new Promise(() => {
          }));
          if (!state.isMounted) {
            (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
            state.unsubscribe = null;
          }
          observer.refetch(action.payload).then((result) => {
            set(resultAtom, result);
          });
          return;
        }
        case "fetchPreviousPage": {
          observer.fetchPreviousPage();
          return;
        }
        case "fetchNextPage": {
          observer.fetchNextPage();
          return;
        }
      }
    }
  );
  const queryAtom = atom(
    (get) => {
      const { resultAtom } = get(queryDataAtom);
      const result = get(resultAtom);
      if (result.isError) {
        throw result.error;
      }
      return result.data;
    },
    (_get, set, action) => set(queryDataAtom, action)
  );
  return queryAtom;
}

export { atomWithInfiniteQuery, atomWithQuery, queryClientAtom };
