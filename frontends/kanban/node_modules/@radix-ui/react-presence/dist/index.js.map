{"mappings":"IAYgCA,EAAMC,8HAAND,KAAMC,mBACpCC,OAAOC,KAAKF,GAAQG,SAAQ,SAASC,GACvB,YAARA,GAA6B,eAARA,GAIzBH,OAAOI,eAAeN,EAAMK,EAAK,CAC/BE,YAAY,EACZC,IAAK,WACH,OAAOP,EAAOI,SAKbL,GChBT,MAAMS,EAAqCC,IACzC,MAAMC,QAAEA,EAAFC,SAAWA,GAAaF,EACxBG,EAmBR,SAAqBF,GACnB,MAAOG,EAAMC,GAAWC,EAAMC,WACxBC,EAAYF,EAAMG,OAA4B,IAC9CC,EAAiBJ,EAAMG,OAAOR,GAC9BU,EAAuBL,EAAMG,OAAe,QAC5CG,EAAeX,EAAU,UAAY,aACpCY,EAAOC,GC1BT,SACLF,EACAG,GAEA,OAAOT,EAAMU,YAAW,CAACH,EAAwBI,KAC/C,MAAMC,EAAaH,EAAQF,GAAeI,GAC1C,OAAOC,MAAAA,EAAAA,EAAaL,IACnBD,GDmBmBO,CAAgBP,EAAc,CAClDQ,QAAS,CACPC,QAAS,YACTC,cAAe,oBAEjBC,iBAAkB,CAChBC,MAAO,UACPC,cAAe,aAEjBC,UAAW,CACTF,MAAO,aA+EX,OA3EAlB,EAAMqB,WAAU,KACd,MAAMC,EAAuBC,EAAiBrB,EAAUsB,SACxDnB,EAAqBmB,QAAoB,YAAVjB,EAAsBe,EAAuB,SAC3E,CAACf,IAEJkB,GAAgB,KACd,MAAMC,EAASxB,EAAUsB,QACnBG,EAAavB,EAAeoB,QAGlC,GAF0BG,IAAehC,EAElB,CACrB,MAAMiC,EAAoBvB,EAAqBmB,QACzCF,EAAuBC,EAAiBG,GAE9C,GAAI/B,EACFa,EAAK,cACA,GAA6B,SAAzBc,GAAuD,UAApBI,MAAAA,OAAA,EAAAA,EAAQG,SAGpDrB,EAAK,eACA,CAOL,MAAMsB,EAAcF,IAAsBN,EAGxCd,EADEmB,GAAcG,EACX,gBAEA,WAIT1B,EAAeoB,QAAU7B,KAE1B,CAACA,EAASa,IAEbiB,GAAgB,KACd,GAAI3B,EAAM,CAMR,MAAMiC,EAAsBpB,IAC1B,MACMqB,EADuBT,EAAiBrB,EAAUsB,SACRS,SAAStB,EAAMuB,eAC3DvB,EAAMwB,SAAWrC,GAAQkC,GAC3BxB,EAAK,kBAGH4B,EAAwBzB,IACxBA,EAAMwB,SAAWrC,IAEnBO,EAAqBmB,QAAUD,EAAiBrB,EAAUsB,WAM9D,OAHA1B,EAAKuC,iBAAiB,iBAAkBD,GACxCtC,EAAKuC,iBAAiB,kBAAmBN,GACzCjC,EAAKuC,iBAAiB,eAAgBN,GAC/B,KACLjC,EAAKwC,oBAAoB,iBAAkBF,GAC3CtC,EAAKwC,oBAAoB,kBAAmBP,GAC5CjC,EAAKwC,oBAAoB,eAAgBP,IAK3CvB,EAAK,mBAEN,CAACV,EAAMU,IAEH,CACL+B,UAAW,CAAC,UAAW,oBAAoBN,SAAS1B,GACpDiC,IAAKxC,EAAMyC,aAAa3C,IAClBA,IAAMI,EAAUsB,QAAUkB,iBAAiB5C,IAC/CC,EAAQD,KACP,KAvHY6C,CAAYhD,GAEvBiD,EACgB,mBAAbhD,EACHA,EAAS,CAAED,QAASE,EAAS0C,YAC7BvC,EAAM6C,SAASC,KAAKlD,GAGpB4C,EAAMO,EAAgBlD,EAAS2C,IAAMI,EAAcJ,KAEzD,MADuC,mBAAb5C,GACLC,EAAS0C,uBAAYvC,EAAMgD,aAAaJ,EAAO,CAAEJ,IAAAA,IAAS,MAmHjF,SAASjB,EAAiBG,GACxB,OAAOA,MAAAA,OAAA,EAAAA,EAAQQ,gBAAiB,0BAjHlCzC,EAASwD,YAAc","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/presence/src/Presence.tsx","./packages/react/presence/src/useStateMachine.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  present: boolean;\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          send('ANIMATION_END');\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// ðŸ¤¯ https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"],"names":["dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","Presence","props","present","children","presence","node","setNode","React","useState","stylesRef","useRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","machine","useReducer","event","nextState","$dbcc0409145c648e23373d561744ca9$export$useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","useEffect","currentAnimationName","getAnimationName","current","useLayoutEffect","styles","wasPresent","prevAnimationName","display","isAnimating","handleAnimationEnd","isCurrentAnimation","includes","animationName","target","handleAnimationStart","addEventListener","removeEventListener","isPresent","ref","useCallback","getComputedStyle","usePresence","child","Children","only","useComposedRefs","cloneElement","displayName"],"version":3,"file":"index.js.map"}