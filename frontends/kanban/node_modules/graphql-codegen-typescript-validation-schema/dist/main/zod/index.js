"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodSchemaVisitor = void 0;
const graphql_1 = require("./../graphql");
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
const typescript_1 = require("@graphql-codegen/typescript");
const directive_1 = require("../directive");
const importZod = `import { z } from 'zod'`;
const anySchema = `definedNonNullAnySchema`;
const ZodSchemaVisitor = (schema, config) => {
    const tsVisitor = new typescript_1.TsVisitor(schema, config);
    const importTypes = [];
    return {
        buildImports: () => {
            if (config.importFrom && importTypes.length > 0) {
                return [importZod, `import { ${importTypes.join(', ')} } from '${config.importFrom}'`];
            }
            return [importZod];
        },
        initialEmit: () => '\n' +
            [
                // Unfortunately, zod doesnâ€™t provide non-null defined any schema.
                // This is a temporary hack until it is fixed.
                // see: https://github.com/colinhacks/zod/issues/884
                new visitor_plugin_common_1.DeclarationBlock({}).asKind('type').withName('definedNonNullAny').withContent('{}').string,
                new visitor_plugin_common_1.DeclarationBlock({})
                    .export()
                    .asKind('const')
                    .withName(`isDefinedNonNullAny`)
                    .withContent(`(v: any): v is definedNonNullAny => v !== undefined && v !== null`).string,
                new visitor_plugin_common_1.DeclarationBlock({})
                    .export()
                    .asKind('const')
                    .withName(`${anySchema}: z.ZodSchema<definedNonNullAny>`)
                    .withContent(`z.any().refine((v) => isDefinedNonNullAny(v))`).string,
            ].join('\n'),
        InputObjectTypeDefinition: (node) => {
            var _a;
            const name = tsVisitor.convertName(node.name.value);
            importTypes.push(name);
            const shape = (_a = node.fields) === null || _a === void 0 ? void 0 : _a.map(field => generateInputObjectFieldYupSchema(config, tsVisitor, schema, field, 2)).join(',\n');
            return new visitor_plugin_common_1.DeclarationBlock({})
                .export()
                .asKind('function')
                .withName(`${name}Schema(): z.ZodSchema<${name}>`)
                .withBlock([(0, visitor_plugin_common_1.indent)(`return z.object({`), shape, (0, visitor_plugin_common_1.indent)('})')].join('\n')).string;
        },
        EnumTypeDefinition: (node) => {
            var _a;
            const enumname = tsVisitor.convertName(node.name.value);
            importTypes.push(enumname);
            if (config.enumsAsTypes) {
                return new visitor_plugin_common_1.DeclarationBlock({})
                    .export()
                    .asKind('const')
                    .withName(`${enumname}Schema`)
                    .withContent(`z.enum([${(_a = node.values) === null || _a === void 0 ? void 0 : _a.map(enumOption => `'${enumOption.name.value}'`).join(', ')}])`).string;
            }
            return new visitor_plugin_common_1.DeclarationBlock({})
                .export()
                .asKind('const')
                .withName(`${enumname}Schema`)
                .withContent(`z.nativeEnum(${enumname})`).string;
        },
    };
};
exports.ZodSchemaVisitor = ZodSchemaVisitor;
const generateInputObjectFieldYupSchema = (config, tsVisitor, schema, field, indentCount) => {
    let gen = generateInputObjectFieldTypeZodSchema(config, tsVisitor, schema, field.type);
    if (config.directives && field.directives) {
        const formatted = (0, directive_1.formatDirectiveConfig)(config.directives);
        gen += (0, directive_1.buildApi)(formatted, field.directives);
    }
    return (0, visitor_plugin_common_1.indent)(`${field.name.value}: ${maybeLazy(field.type, gen)}`, indentCount);
};
const generateInputObjectFieldTypeZodSchema = (config, tsVisitor, schema, type, parentType) => {
    if ((0, graphql_1.isListType)(type)) {
        const gen = generateInputObjectFieldTypeZodSchema(config, tsVisitor, schema, type.type, type);
        if (!(0, graphql_1.isNonNullType)(parentType)) {
            return `z.array(${maybeLazy(type.type, gen)}).nullish()`;
        }
        return `z.array(${maybeLazy(type.type, gen)})`;
    }
    if ((0, graphql_1.isNonNullType)(type)) {
        const gen = generateInputObjectFieldTypeZodSchema(config, tsVisitor, schema, type.type, type);
        return maybeLazy(type.type, gen);
    }
    if ((0, graphql_1.isNamedType)(type)) {
        const gen = generateNameNodeZodSchema(config, tsVisitor, schema, type.name);
        if ((0, graphql_1.isNonNullType)(parentType)) {
            if (config.notAllowEmptyString === true) {
                const tsType = tsVisitor.scalars[type.name.value];
                if (tsType === 'string')
                    return `${gen}.min(1)`;
            }
            return gen;
        }
        if ((0, graphql_1.isListType)(parentType)) {
            return `${gen}.nullable()`;
        }
        return `${gen}.nullish()`;
    }
    console.warn('unhandled type:', type);
    return '';
};
const generateNameNodeZodSchema = (config, tsVisitor, schema, node) => {
    var _a, _b;
    const typ = schema.getType(node.value);
    if (typ && ((_a = typ.astNode) === null || _a === void 0 ? void 0 : _a.kind) === 'InputObjectTypeDefinition') {
        const enumName = tsVisitor.convertName(typ.astNode.name.value);
        return `${enumName}Schema()`;
    }
    if (typ && ((_b = typ.astNode) === null || _b === void 0 ? void 0 : _b.kind) === 'EnumTypeDefinition') {
        const enumName = tsVisitor.convertName(typ.astNode.name.value);
        return `${enumName}Schema`;
    }
    return zod4Scalar(config, tsVisitor, node.value);
};
const maybeLazy = (type, schema) => {
    if ((0, graphql_1.isNamedType)(type) && (0, graphql_1.isInput)(type.name.value)) {
        return `z.lazy(() => ${schema})`;
    }
    return schema;
};
const zod4Scalar = (config, tsVisitor, scalarName) => {
    var _a;
    if ((_a = config.scalarSchemas) === null || _a === void 0 ? void 0 : _a[scalarName]) {
        return config.scalarSchemas[scalarName];
    }
    const tsType = tsVisitor.scalars[scalarName];
    switch (tsType) {
        case 'string':
            return `z.string()`;
        case 'number':
            return `z.number()`;
        case 'boolean':
            return `z.boolean()`;
    }
    console.warn('unhandled name:', scalarName);
    return anySchema;
};
