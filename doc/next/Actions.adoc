= Actions
:toc: left
:experimental:

(((action, definition)))
Users can be permitted to query, create, update and/or delete certain Documents.

Such activities are termed Actions.

== Introduction

Actions authorize all reads and writes to the database. Actions also record all
writes, and some reads from the database.

////
TODO: Use xrefs from these bullet-points to more detailed explanations, such
that these set of items can become a launchpad for diving into the
documentation.
////

Actions run in transaction functions to ensure atomicity and consistency.

Actions can provide involve input validation.

Actions define their access control in rules, which are sufficient powerful to
model any access control policy (RBAC, ABAC, PBAC, etc.)

Actions leave an audit trail and may trigger alerts.

Actions can be grouped into OAuth2 scopes.

Actions can be exposed to the network, using OpenAPI and/or GraphQL operations.

Actions can cause side-effects (e.g. lambda functions).

Actions decouple network APIs from lower-level effects. For example, an API
implementation can use a 'send-email', without having to know the implementation
details of sending emails.

////
(old text)

A Site instance is a collection of documents, stored in XTDB.

Like XTDB, Site is schemaless and requires that you define your own
documents. However, by included document attributes known to Site (usually in
the `juxt.site.alpha` namespace) Site is able to interpret the documents as web
or API resources, and serve them over HTTP.

We need to set up sufficient resources in the REPL so that we no longer need to
access Site via the REPL.

Secure remote access to Site resources requires an *access token*.

In this section we use the REPL to build up the minimal resources required to
acquire an access token which can let us continue setting up the server
remotely, without requiring further REPL access.

An access token is granted for a *subject* and an *application*, so we'll need
to create those too.

But first, we need to install some preliminary resources into our REPL.
////

=== Data consistency

(((data consistency)))
Actions that modify the database are run in a transaction function. This ensures
that the authorization check is made at the latest possible point, just before
the database is potentially modified. This avoids any potential for
race-conditions, for example, if the authorization to perform an Action is
revoked just before the Action is invoked.

=== Audit logging

(((audit logging)))
(((do-action)))
Whenever an Action is invoked, the `do-action` transaction function is executed
which results in a *transaction metadata record* being created in the
database.

This makes it possible to find out when an Action was invoked, by whom, which
entities were affected and, potentially, other details such as the 'business
justification'.

(((transaction, metadata)))
If the Action is denied, or if errors occur when the Action is executed, details
will be recorded in the transaction metadata.

This allows us later to answer questions as to whether an Action was allowed or
denied, with an explanation. We will also be able to answer questions regarding
the who, when, why and how for each resource in the database.

A copy of the transaction metadata record is returned as a result of the
`do-action` function, as shown in <<transaction-metadata-record-example>>.

[[transaction-metadata-record-example]]
.A *transaction metadata record*
====

[source,clojure]
----
{:xt/id "urn:site:action-log:134"
 :xtdb.api/tx-id 134
 :juxt.pass.alpha/subject "urn:site:subjects:repl"
 :juxt.pass.alpha/action "https://site.test/actions/create-action"
 :juxt.pass.alpha/purpose nil
 :juxt.pass.alpha/puts ["https://site.test/actions/grant-permission"]
 :juxt.pass.alpha/deletes []}
----
====

== Document structure of an Action

(((action, document structure)))
<<action-doc-structure>> lists the attributes found in Action documents.

.Document structure of an Action
[[action-doc-structure]]
[%header,cols="2l,3d,1"]
|===
|Attribute|Value|Required?

|:xt/id
|Actions are resources, so this is a URI. Callers of actions use this id.
s|Required

|:juxt.site.alpha/type
l|"https://meta.juxt.site/pass/action"
s|Required

|:juxt.pass.alpha/rules
|A collection of Datalog rules that determine whether the action is allowed.
s|Required

|:juxt.pass.alpha.malli/args-schema
|A Malli tuple schema that the action's arguments must conform to.
|Optional

|:juxt.pass.alpha/process
|A vector of processing steps which are executed when the action is invoked.
|Optional

|:juxt.pass.alpha/scope
|A _String_ representing the OAuth 2.0 scope containing the action.
|Optional
|===

== Performing Actions (Flip)

Actions are performed in transaction functions. A transaction function must
return one or more transaction operations that will be submitted to the database
atomically.

Often, actions are required to validate input and construct documents that must
be put into the database.

Flip is a bespoke language that is used in transaction functions which is
specially designed for the purpose of producing transaction operations.

Flip is a stack-based
https://www.concatenative.org/wiki/view/Front%20Page[concatenative] language,
drawing heavily from https://factorcode.org/[Factor] and
https://www.nsl.com/k/xy/xy.htm[XY].

.Why a dedicated language?
****
The rationale for Flip is that we need a DSL that is constrained so that it is
easier to secure. Another issue with allowing a general purpose language such as
Clojure or JavaScript is that we cannot know whether the program will terminate.

The problem with only allowing extensions to be defmethods is that this implies
that we need to allow users to add methods to the code-base, and track versions,
etc.

The benefit of an internal language is that its primitives can be established
earlier on and compositions can be defined in terms of primitives. Compositions
can be added to the database rather than the codebase.
****


== Installing a 'create-action' Action

(((create-action)))
We must install an Action which allows us to create other Actions.

NOTE: This is the one Action that has to be put directly into the database because we
don't have a way of creating actions yet!

This gives us an opportunity to inspect the document structure of a real Action
(see <<example-create-action>>).

.Installing a create-action Action
[[example-create-action]]
====
[source,clojure]
----
include::../../test/juxt/book.clj[tag=install-create-action!,indent=0]
----
<1> The URI of the create-action Action. This may have to be modified if you
have chosen a different base URI.

<2> This Malli schema restricts the URIs of new Actions. Again, this should be
modified if necessary to correspond to a different base URI.

<3> The Action arguments will be updated such that the first (0th) argument is
updated so that it contains a `:juxt.site.alpha/type` attribute with the value
string "`Action`".

<4> The arguments will then be validated according to the Malli schema in
`:juxt.pass.alpha.malli/args-schema`. By this point it must be a map containing
an `:xt/id` value prefixed with `https://site.test/actions/` and a
`:juxt.site.alpha/type` with the constant `"Action"`.

<5> then the arguments will be submitted, as documents, to the database.

<6> This is a Rule. It ensures that the Action will be allowed only if there
exists a Permission granting users of a given role to invoke the Action. These
concepts will be covered in <<ch-users>>. If you decide on a different data
model for users, then this Rule will have to be modified to reflect
that. Granting Permissions indirectly to Users via a role or group, rather than
directly to a specific User, can make it easier to manage when there are lot of
Users added.
====

[IMPORTANT]
--
. Copy the code in <<example-create-action>> into an editor.
. Make any changes required (for example, to change the host in the URIs).
. Copy into the REPL
. Evaluate.
--

== Installing the transaction function

(((do-action, transaction function, registration)))
Actions can be invoked at the REPL with `do-action`.

This depends on a transaction function that must be first registered in the
database.

[IMPORTANT]
--
Type:
[source,clojure]
----
include::../../test/juxt/book.clj[tag=install-do-action-fn!,indent=0]
----
into the REPL and evaluate.
--

////

Moved from Concepts

These prescriptions are encoded as Datalog rules, as shown in <<ex-action>>.

Each rule is a collection of clauses, the first clause is always:

----
(allowed? permission subject resource)
----

Think of this as an equation where the 'permission' variable must be found,
in the same way as a mathematical equation might ask for solutions for latexmath:[y = 2x + 6]. If
there are no permissions which satisfy the logic, then the Action is disallowed.

Rules are applied to queries as well as to mutating writes.

[[ex-action]]
.An Action
====
[source,clojure]
----
{:xt/id "https://example.org/actions/sit"
 :just.pass.alpha/rules
 [(allowed? permission subject resource)
  [subject :juxt.pass.alpha/identity id]
  [id :juxt.pass.alpha/user user]
  [user :species "cat"]
  [permission :resource "https://example.org/mat"]
  [permission :user user]]}
----
====

Rules can be as simple or as complex as the domain requires. The power and
expressiveness of Datalog allows for a wide range of possibilities.

When compared to other 'third-party' solutions, Site's authorization system has
two further key advantages:

* Action rules are written as graphs which are free to traverse as deep as
  necessary into the complete database of facts. Other systems must often rely
  on a small subset of facts which place limits on the flexibility of
  authorization policies.

* Action rules benefit from strong database consistency. Rules are run only
  after any pending updates to Permission have been applied. Other systems often
  cannot achieve consistency because they are implemented as services across a
  network boundary and their database of facts may be out-of-date when making
  critical authorization decisions.

////

== Rules & Permissions


With Actions and Users established, we've got everything we need to start
creating other resources.

However, in practice, it is cumbersome to have to update Actions every time we
want to authorize a new User to perform an Action. This is where Permissions
come in.

(((permission, definition)))
Permissions are separate Documents that represent a specific authorization. A
document can be put into the database to represent a permission when it is
granted, and (just as easily) deleted from the database when the authorization
is revoked.

TIP: Permissions are straight-forward to grant and revoke, as they are
represented as XTDB documents, so granting and revoking a permission can be done
with XTDB's respective `:xtdb.api/put` and `:xtdb.api/delete` operations.

An Action's Rules specify how Permissions determine the outcome of authorization
decisions.

By writing Rules in terms of Permissions, as opposed to Users, grants and
revocations are easier to manage and report on.

=== Document structure of a Permission

(((permission, document structure)))
<<permission-doc-structure>> lists the attributes found in Permission documents.

.Document structure of a Permission
[[permission-doc-structure]]
[%header,cols="2l,3d,1"]
|===
|Attribute|Value|Required?

|:xt/id
|Permssions are resources, so this is a URI.
s|Required

|:juxt.site.alpha/type
l|"https://meta.juxt.site/pass/permission"
s|Required

|:juxt.pass.alpha/action
|The URI of the Action this Permission grants access to.
s|Required

|:juxt.pass.alpha/purpose
|The purpose of the Permission. Can be nil.
s|Required
|===

=== Creating a permission

We must install a Permission which will allow our user to call our
`create-action` Action.

This gives us an opportunity to inspect the document structure of a real
Permission.

<<example-put-permission-to-create-action>> demonstrates creating a Permission
that works with the Action we created in <<example-create-action>>.

.Permitting the create-action action
[[example-put-permission-to-create-action]]
====
[source,clojure]
----
include::../../test/juxt/book.clj[tag=permit-create-action!,indent=0]
----

<1> Permissions are individual resources, and must have unique URIs.

<2> Each Permission must have a `:juxt.site.alpha/type` attribute of
"`Permission`".

<3> The Permission must be tied to a specific Action.

<4> The Permission can be granted for a particular purpose, but if not, this
attribute must be nil.

<5> In this case, the Permission references the `Administrator` role. All Users
with this `Administrator` role will be able to call the
`+https://site.test/actions/create-action+` action.

====

[NOTE]
--
In future we might allow different users using the same REPL to identify
themselves. Of course, REPL users have no restrictions to what they can do, so
this is just for audit purposes among trusted users.
--

WARNING: Access to the REPL must be restricted to a very limited set of
authorized users.

[IMPORTANT]
--
Grant your user the Permission to invoke the create-action function you created in <<example-create-action>>:

. Copy the code in <<example-put-permission-to-create-action>> to an editor.
. Update it according to the Base URI you have chosen.
. Copy the modified code into the REPL.
. Evaluate!
--

=== Creating the grant-permssion action

We have now created a `create-action` Action and granted a Permission for our
User to invoke it. Let's invoke this action to create a new `grant-permission`
action.

<<ex-create-grant-permission-action>> demonstrates how this is achieved.

.Creating the grant-permission action
[[ex-create-grant-permission-action]]
====
[source,clojure]
----
include::../../test/juxt/book.clj[tag=create-grant-permission-action!,indent=0]
----
====

[IMPORTANT]
--
Create the grant-permission action by following these steps:

. Copy the code from <<ex-create-grant-permission-action>> into an editor
. Make appropriate changes
. Copy into the REPL
. Evaluate
--

Finally, we need to permit our REPL user to invoke this grant-permission action, and this
permission too needs to be put directly into the database since we don't yet
have a way of granting permissions!

This is shown in <<ex-permit-grant-permission-action>>.

.Permitting the grant-permission action
[[ex-permit-grant-permission-action]]
====
[source,clojure]
----
include::../../test/juxt/book.clj[tag=permit-grant-permission-action!,indent=0]
----
====

[IMPORTANT]
--
Permit the grant-permission action by following these steps:

. Copy the code from <<ex-permit-grant-permission-action>> into an editor
. Make appropriate changes
. Copy into the REPL
. Evaluate
--

Now that we have the ability to create actions, and grant permissions to invoke
them, we have the building blocks we need to start creating
<<ch-resources,Resources>>.


////

Moved from Concepts

The Action in <<ex-action>> potentially allows cats to sit on the mat, but a
Permission must still explicitly exist for the rule to be satisfied.

The reason for this is simply that we often want to be able grant and revoke
access without having to continually update rules. Permissions are documents
that mark the event when access was granted or revoked, and the history of
Permission documents is recorded on the timeline just as it is for every other
type of document.

This architecture leads to a wide number of possible designs. For example, it's
possible to construct a permission to last for a few hours. Or model actions in
terms of roles, and have the Permission document grant an individual their
membership of a particular role.

////
