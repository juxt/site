{"mappings":"IAYgCA,EAAMC,EAZNC,2DAYAF,KAAMC,mBACpCE,OAAOC,KAAKH,GAAQI,SAAQ,SAASC,GACvB,YAARA,GAA6B,eAARA,GAIzBH,OAAOI,eAAeP,EAAMM,EAAK,CAC/BE,YAAY,EACZC,IAAK,WACH,OAAOR,EAAOK,SAKbN,MA1BuBE,8CAClBA,EAAEQ,WAAaR,EAAES,QAAUT,ECUzC,MAAMU,eAAOC,EAAMC,YAAmC,CAACC,EAAOC,KAC5D,MAAMC,SAAEA,KAAaC,GAAcH,EAEnC,OAAIF,EAAMM,SAASC,QAAQH,GAAUI,KAAKC,gBAEtCC,EAAAC,cAAAD,EAAAE,SAAA,KACGZ,EAAMM,SAASO,IAAIT,GAAWU,GACtBL,EAAYK,gBACjBJ,EAAAC,cAACI,EAADC,EAAA,GAAeX,EAAf,CAA0BY,IAAKd,IAC5BW,EAAMZ,MAAME,UAGfU,kBAQRJ,EAAAC,cAACI,EAADC,EAAA,GAAeX,EAAf,CAA0BY,IAAKd,IAC5BC,qBAKPL,EAAKmB,YAAc,OAUnB,MAAMC,eAAYnB,EAAMC,YAAgC,CAACC,EAAOC,KAC9D,MAAMC,SAAEA,KAAaC,GAAcH,eAEnC,OAAIF,EAAMoB,eAAehB,gBAChBJ,EAAMqB,aAAajB,EAAU,IAC/BkB,EAAWjB,EAAWD,EAASF,OAClCe,IAAKM,EAAYpB,EAAeC,EAAiBa,OAI9CjB,EAAMM,SAASkB,MAAMpB,GAAY,EAAIJ,EAAMM,SAASmB,KAAK,MAAQ,QAG1EN,EAAUD,YAAc,YAMxB,MAAMQ,EAAY,EAAGtB,SAAAA,kBACZM,EAAAC,cAAAD,EAAAE,SAAA,KAAGR,GAOZ,SAASK,EAAYK,gBACnB,OAAOd,EAAMoB,eAAeN,IAAUA,EAAMa,OAASD,EAGvD,SAASJ,EAAWjB,EAAqBuB,GAEvC,MAAMC,EAAgB,IAAKD,GAE3B,IAAK,MAAME,KAAYF,EAAY,CACjC,MAAMG,EAAgB1B,EAAUyB,GAC1BE,EAAiBJ,EAAWE,GAEhB,WAAWG,KAAKH,GAGhCD,EAAcC,GAAY,IAAII,KAC5BF,MAAAA,GAAAA,KAAoBE,GACpBH,MAAAA,GAAAA,KAAmBG,IAID,UAAbJ,EACPD,EAAcC,GAAY,IAAKC,KAAkBC,GAC3B,cAAbF,IACTD,EAAcC,GAAY,CAACC,EAAeC,GAAgBG,OAAOC,SAASC,KAAK,MAInF,MAAO,IAAKhC,KAAcwB,uBAG5B,MAAMS,EAAOvC","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/slot/src/Slot.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.Children.toArray(children).some(isSlottable)) {\n    return (\n      <>\n        {React.Children.map(children, (child) => {\n          return isSlottable(child) ? (\n            <SlotClone {...slotProps} ref={forwardedRef}>\n              {child.props.children}\n            </SlotClone>\n          ) : (\n            child\n          );\n        })}\n      </>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: composeRefs(forwardedRef, (children as any).ref),\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    // if it's a handler, modify the override by composing the base handler\n    if (isHandler) {\n      overrideProps[propName] = (...args: unknown[]) => {\n        childPropValue?.(...args);\n        slotPropValue?.(...args);\n      };\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n"],"names":["dest","source","a","Object","keys","forEach","key","defineProperty","enumerable","get","__esModule","default","Slot","React","forwardRef","props","forwardedRef","children","slotProps","Children","toArray","some","isSlottable","_react","createElement","Fragment","map","child","$bd3c7a2329cce5affa12c89d44fd473$var$SlotClone","_babelRuntimeHelpersExtends","ref","displayName","SlotClone","isValidElement","cloneElement","mergeProps","composeRefs","count","only","Slottable","type","childProps","overrideProps","propName","slotPropValue","childPropValue","test","args","filter","Boolean","join","Root"],"version":3,"file":"index.js.map"}