{
  "version": 3,
  "sources": ["../../history/index.js", "../../@tanstack/react-location/src/qss.ts", "../../@tanstack/react-location/src/index.tsx"],
  "sourcesContent": ["import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n", "// @ts-nocheck\n\n// We're inlining qss here for compression's sake, but we've included it as a hard dependency for the MIT license it requires.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n", "import * as React from 'react'\n\nimport {\n  createHashHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n  BrowserHistory,\n  MemoryHistory,\n  History,\n  HashHistory,\n} from 'history'\n\nexport { createHashHistory, createBrowserHistory, createMemoryHistory }\n\nimport { decode, encode } from './qss'\n\n// Types\n\ntype Timeout = ReturnType<typeof setTimeout>\n\ntype Maybe<T, TUnknown> = T extends {} ? T : TUnknown\n\nexport type DefaultGenerics = {\n  LoaderData: LoaderData<unknown>\n  Params: Params<string>\n  Search: Search<unknown>\n  RouteMeta: RouteMeta<unknown>\n}\n\nexport type PartialGenerics = Partial<DefaultGenerics>\n\nexport type MakeGenerics<TGenerics extends PartialGenerics> = TGenerics\n\nexport type Search<T> = Record<string, T>\nexport type Params<T> = Record<string, T>\nexport type LoaderData<T> = Record<string, T>\nexport type RouteMeta<T> = Record<string, T>\n\nexport type UseGeneric<\n  TGenerics extends PartialGenerics,\n  TGeneric extends keyof PartialGenerics,\n> = TGeneric extends 'LoaderData' | 'Search'\n  ? Partial<Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>>\n  : Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>\n\nexport type ReactLocationOptions = {\n  // The history object to be used internally by react-location\n  // A history will be created automatically if not provided.\n  history?: BrowserHistory | MemoryHistory | HashHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n\nexport type Updater<TResult> = TResult | ((prev?: TResult) => TResult)\n\nexport type Location<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  href: string\n  pathname: string\n  search: UseGeneric<TGenerics, 'Search'>\n  searchStr: string\n  hash: string\n  key?: string\n  // nextAction?: 'push' | 'replace'\n}\n\nexport type Route<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  // The path to match (relative to the nearest parent `Route` component or root basepath)\n  path?: string\n  // An ID to uniquely identify this route within its siblings. This is only required for routes that *only match on search* or if you have multiple routes with the same path\n  id?: string\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // Either (1) an object that will be used to shallowly match the current location's search or (2) A function that receives the current search params and can return truthy if they are matched.\n  search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n  // The duration to wait during `loader` execution before showing the `pendingElement`\n  pendingMs?: number\n  // _If the `pendingElement` is shown_, the minimum duration for which it will be visible.\n  pendingMinMs?: number\n  // Search filters can be used to rewrite, persist, default and manipulate search params for link that\n  // point to their routes or child routes. See the \"basic\" example to see them in action.\n  searchFilters?: SearchFilter<TGenerics>[]\n  // An array of child routes\n  children?: Route<TGenerics>[]\n  // Route Loaders (see below) can be inline on the route, or resolved async\n} & RouteLoaders<TGenerics> & {\n    // If `import` is defined, this route can resolve its elements and loaders in a single asynchronous call\n    // This is particularly useful for code-splitting or module federation\n    import?: (opts: {\n      params: UseGeneric<TGenerics, 'Params'>\n      search: UseGeneric<TGenerics, 'Search'>\n    }) => Promise<RouteLoaders<TGenerics>>\n  }\n\nexport type RouteLoaders<TGenerics> = {\n  // The content to be rendered when the route is matched. If no element is provided, defaults to `<Outlet />`\n  element?: SyncOrAsyncElement<TGenerics>\n  // The content to be rendered when `loader` encounters an error\n  errorElement?: SyncOrAsyncElement<TGenerics>\n  // The content to be rendered when the duration of `loader` execution surpasses the `pendingMs` duration\n  pendingElement?: SyncOrAsyncElement<TGenerics>\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  loader?: LoaderFn<TGenerics>\n  // An asynchronous function responsible for cleaning up when the match cache is cleared. This is useful when\n  // the loader function has side effects that need to be cleaned up when the match is no longer in use.\n  unloader?: UnloaderFn<TGenerics>\n  // An integer of milliseconds representing how long data should be cached for the route\n  loaderMaxAge?: number\n  // Similar to React's useEffect hook, this function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onMatch?: (\n    match: RouteMatch<TGenerics>,\n  ) => void | undefined | ((match: RouteMatch<TGenerics>) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: RouteMatch<TGenerics>) => void\n  // An object of whatever you want! This object is accessible anywhere matches are.\n  meta?: UseGeneric<TGenerics, 'RouteMeta'>\n}\n\nexport type SearchFilter<TGenerics> = (\n  prev: UseGeneric<TGenerics, 'Search'>,\n) => UseGeneric<TGenerics, 'Search'>\n\nexport type MatchLocation<TGenerics extends PartialGenerics = DefaultGenerics> =\n  {\n    to?: string | number | null\n    search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n    fuzzy?: boolean\n    caseSensitive?: boolean\n  }\n\nexport type SearchPredicate<TSearch> = (search: TSearch) => any\n\nexport type SyncOrAsyncElement<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = React.ReactNode | AsyncElement<TGenerics>\n\nexport type AsyncElement<TGenerics extends PartialGenerics = DefaultGenerics> =\n  (opts: {\n    params: UseGeneric<TGenerics, 'Params'>\n  }) => Promise<React.ReactNode>\n\nexport type UnloadedMatch<TGenerics extends PartialGenerics = DefaultGenerics> =\n  {\n    id: string\n    route: Route<TGenerics>\n    pathname: string\n    params: UseGeneric<TGenerics, 'Params'>\n    search: UseGeneric<TGenerics, 'Search'>\n  }\n\nexport type LoaderFn<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  routeMatch: RouteMatch<TGenerics>,\n  opts: LoaderFnOptions<TGenerics>,\n) => PromiseLike<UseGeneric<TGenerics, 'LoaderData'>>\n\nexport type UnloaderFn<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  routeMatch: RouteMatch<TGenerics>,\n) => void\n\nexport type LoaderFnOptions<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = {\n  parentMatch?: RouteMatch<TGenerics>\n  dispatch: (event: LoaderDispatchEvent<TGenerics>) => void\n}\n\ntype PromiseLike<T> = Promise<T> | T\n\nexport type ListenerFn = () => void\n\nexport type Segment = {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport type RouterProps<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  // Children will default to `<Outlet />` if not provided\n  children?: React.ReactNode\n  location: ReactLocation<TGenerics>\n} & RouterOptions<TGenerics>\n\nexport type RouterOptions<TGenerics> = {\n  // An array of route objects to match\n  routes: Route<TGenerics>[]\n  basepath?: string\n  filterRoutes?: FilterRoutesFn\n  defaultLinkPreloadMaxAge?: number\n  defaultLoaderMaxAge?: number\n  useErrorBoundary?: boolean\n  defaultElement?: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  caseSensitive?: boolean\n  __experimental__snapshot?: __Experimental__RouterSnapshot<TGenerics>\n}\n\nexport type __Experimental__RouterSnapshot<TGenerics> = {\n  // matches: Partial<RouteMatch<TGenerics>>[]\n  location: Location<TGenerics>\n  matches: SnapshotRouteMatch<TGenerics>[]\n}\n\nexport type SnapshotRouteMatch<TGenerics> = {\n  id: string\n  ownData: UseGeneric<TGenerics, 'LoaderData'>\n}\n\nexport type BuildNextOptions<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = {\n  to?: string | number | null\n  search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n  hash?: true | Updater<string>\n  from?: Partial<Location<TGenerics>>\n  key?: string\n  __searchFilters?: SearchFilter<TGenerics>[]\n}\n\nexport type NavigateOptions<TGenerics> = BuildNextOptions<TGenerics> & {\n  replace?: boolean\n  fromCurrent?: boolean\n}\n\nexport type PromptProps = {\n  message: string\n  when?: boolean | any\n  children?: React.ReactNode\n}\n\nexport type LinkProps<TGenerics extends PartialGenerics = DefaultGenerics> =\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'href' | 'children'> & {\n    // The absolute or relative destination pathname\n    to?: string | number | null\n    // The new search object or a function to update it\n    search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n    // The new has string or a function to update it\n    hash?: Updater<string>\n    // Whether to replace the current history stack instead of pushing a new one\n    replace?: boolean\n    // A function that is passed the [Location API](#location-api) and returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n    getActiveProps?: () => Record<string, any>\n    // A function that is passed the [Location API](#location-api) and returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n    getInactiveProps?: () => Record<string, any>\n    // Defaults to `{ exact: false, includeHash: false }`\n    activeOptions?: ActiveOptions\n    // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n    preload?: number\n    // If true, will render the link without the href attribute\n    disabled?: boolean\n    // A custom ref prop because of this: https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref/58473012\n    _ref?: React.Ref<HTMLAnchorElement>\n    // If a function is pass as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\ntype ActiveOptions = {\n  exact?: boolean\n  includeHash?: boolean\n}\n\nexport type LinkPropsType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  LinkProps<TGenerics>\n\nexport type LoaderDispatchEvent<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> =\n  | {\n      type: 'maxAge'\n      maxAge: number\n    }\n  | {\n      type: 'loading'\n    }\n  | {\n      type: 'resolve'\n      data: UseGeneric<TGenerics, 'LoaderData'>\n    }\n  | {\n      type: 'reject'\n      error: unknown\n    }\n\nexport type LoadRouteFn<TGenerics> = (\n  next: Location<TGenerics>,\n) => MatchLoader<TGenerics>\n\nexport type TransitionState<TGenerics> = {\n  location: Location<TGenerics>\n  matches: RouteMatch<TGenerics>[]\n}\n\nexport type FilterRoutesFn = <\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  routes: Route<TGenerics>[],\n) => Route<TGenerics>[]\n\nexport type RouterPropsType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = RouterProps<TGenerics>\n\nexport type RouterType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: RouterProps<TGenerics>,\n) => JSX.Element\n\ntype Listener = () => void\n\n// Source\n\nconst LocationContext = React.createContext<{ location: ReactLocation<any> }>(\n  null!,\n)\nconst MatchesContext = React.createContext<RouteMatch<any>[]>(null!)\nconst routerContext = React.createContext<{ router: RouterInstance<any> }>(\n  null!,\n)\n\n// Detect if we're in the DOM\nconst isDOM = Boolean(\n  typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement,\n)\n\nconst useLayoutEffect = isDOM ? React.useLayoutEffect : React.useEffect\n\n// This is the default history object if none is defined\nconst createDefaultHistory = () =>\n  isDOM ? createBrowserHistory() : createMemoryHistory()\n\nclass Subscribable {\n  listeners: Listener[]\n\n  constructor() {\n    this.listeners = []\n  }\n\n  subscribe(listener: Listener): () => void {\n    this.listeners.push(listener as Listener)\n\n    return () => {\n      this.listeners = this.listeners.filter((x) => x !== listener)\n    }\n  }\n\n  notify(): void {\n    this.listeners.forEach((listener) => listener())\n  }\n}\n\nexport class ReactLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  history: BrowserHistory | MemoryHistory\n  stringifySearch: SearchSerializer\n  parseSearch: SearchParser\n\n  current: Location<TGenerics>\n  destroy: () => void\n  navigateTimeout?: Timeout\n  nextAction?: 'push' | 'replace'\n\n  //\n\n  isTransitioning: boolean = false\n\n  constructor(options?: ReactLocationOptions) {\n    super()\n    this.history = options?.history || createDefaultHistory()\n    this.stringifySearch = options?.stringifySearch ?? defaultStringifySearch\n    this.parseSearch = options?.parseSearch ?? defaultParseSearch\n\n    this.current = this.parseLocation(this.history.location)\n\n    this.destroy = this.history.listen((event) => {\n      this.current = this.parseLocation(event.location, this.current)\n      this.notify()\n    })\n  }\n\n  buildNext(\n    basepath: string = '/',\n    dest: BuildNextOptions<TGenerics> = {},\n  ): Location<TGenerics> {\n    const from = {\n      ...this.current,\n      ...dest.from,\n    }\n\n    const pathname = resolvePath(basepath, from.pathname, `${dest.to ?? '.'}`)\n\n    const filteredSearch = dest.__searchFilters?.length\n      ? dest.__searchFilters.reduce((prev, next) => next(prev), from.search)\n      : from.search\n\n    const updatedSearch =\n      dest.search === true\n        ? filteredSearch // Preserve from true\n        : dest.search\n        ? functionalUpdate(dest.search, filteredSearch) ?? {} // Updater\n        : dest.__searchFilters?.length\n        ? filteredSearch // Preserve from filters\n        : {}\n\n    const search = replaceEqualDeep(from.search, updatedSearch)\n\n    const searchStr = this.stringifySearch(search)\n    let hash =\n      dest.hash === true ? from.hash : functionalUpdate(dest.hash, from.hash)\n    hash = hash ? `#${hash}` : ''\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      hash,\n      href: `${pathname}${searchStr}${hash}`,\n      key: dest.key,\n    }\n  }\n\n  navigate(next: Location<TGenerics>, replace?: boolean): void {\n    this.current = next\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl =\n      this.parseLocation(this.history.location).href === this.current.href\n\n    if (isSameUrl && !this.current.key) {\n      nextAction = 'replace'\n    }\n\n    if (nextAction === 'replace') {\n      return this.history.replace({\n        pathname: this.current.pathname,\n        hash: this.current.hash,\n        search: this.current.searchStr,\n      })\n    }\n\n    return this.history.push({\n      pathname: this.current.pathname,\n      hash: this.current.hash,\n      search: this.current.searchStr,\n    })\n  }\n\n  parseLocation(\n    location: History['location'],\n    previousLocation?: Location<TGenerics>,\n  ): Location<TGenerics> {\n    const parsedSearch = this.parseSearch(location.search)\n\n    return {\n      pathname: location.pathname,\n      searchStr: location.search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: location.hash.split('#').reverse()[0] ?? '',\n      href: `${location.pathname}${location.search}${location.hash}`,\n      key: location.key,\n    }\n  }\n}\n\nexport type MatchesProviderProps<TGenerics> = {\n  value: RouteMatch<TGenerics>[]\n  children: React.ReactNode\n}\n\nexport function MatchesProvider<TGenerics>(\n  props: MatchesProviderProps<TGenerics>,\n) {\n  return <MatchesContext.Provider {...props} />\n}\n\nexport function Router<TGenerics extends PartialGenerics = DefaultGenerics>({\n  children,\n  location,\n  __experimental__snapshot,\n  ...rest\n}: RouterProps<TGenerics>) {\n  const routerRef = React.useRef<RouterInstance<TGenerics>>(null!)\n  if (!routerRef.current) {\n    routerRef.current = new RouterInstance<TGenerics>({\n      location,\n      __experimental__snapshot,\n      routes: rest.routes,\n    })\n  }\n  const router = routerRef.current\n\n  const [nonce, rerender] = React.useReducer(() => ({}), {})\n\n  router.update(rest)\n\n  useLayoutEffect(() => {\n    return router.subscribe(() => {\n      rerender()\n    })\n  }, [])\n\n  useLayoutEffect(() => {\n    return router.updateLocation(location.current).unsubscribe\n  }, [location.current.key])\n\n  return (\n    <LocationContext.Provider value={{ location }}>\n      <routerContext.Provider value={{ router }}>\n        <InitialSideEffects />\n        <MatchesProvider value={[router.rootMatch!, ...router.state.matches]}>\n          {children ?? <Outlet />}\n        </MatchesProvider>\n      </routerContext.Provider>\n    </LocationContext.Provider>\n  )\n}\n\nfunction InitialSideEffects() {\n  const location = useLocation()\n  const buildNext = useBuildNext()\n  const navigate = useNavigate()\n\n  useLayoutEffect(() => {\n    const next = buildNext({\n      to: '.',\n      search: true,\n      hash: true,\n    })\n\n    if (next.href !== location.current.href) {\n      navigate({\n        to: '.',\n        search: true,\n        hash: true,\n        fromCurrent: true,\n        replace: true,\n      })\n    }\n  }, [])\n\n  return null\n}\n\ntype RouterInstanceState<TGenerics> = {\n  state: TransitionState<TGenerics>\n  pending?: TransitionState<TGenerics>\n}\n\nexport class RouterInstance<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  basepath?: string\n  rootMatch?: RouteMatch<TGenerics>\n  state: TransitionState<TGenerics>\n  pending?: TransitionState<TGenerics>\n  routes!: Route<TGenerics>[]\n  filterRoutes?: FilterRoutesFn\n  defaultLinkPreloadMaxAge?: number\n  defaultLoaderMaxAge?: number\n  useErrorBoundary?: boolean\n  defaultElement: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement: SyncOrAsyncElement<TGenerics>\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  caseSensitive?: boolean\n\n  routesById: Record<string, Route<TGenerics>> = {}\n\n  constructor({\n    location,\n    __experimental__snapshot,\n    ...rest\n  }: {\n    location: ReactLocation<TGenerics>\n    __experimental__snapshot?: __Experimental__RouterSnapshot<TGenerics>\n  } & RouterOptions<TGenerics>) {\n    super()\n\n    this.update(rest)\n\n    let matches: RouteMatch<TGenerics>[] = []\n\n    if (__experimental__snapshot) {\n      const matchLoader = new MatchLoader(this, location.current)\n      matchLoader.matches.forEach((match, index) => {\n        if (match.id !== __experimental__snapshot.matches[index]?.id) {\n          throw new Error(\n            `Router hydration mismatch: ${match.id} !== ${__experimental__snapshot.matches[index]?.id}`,\n          )\n        }\n        match.ownData = __experimental__snapshot.matches[index]?.ownData ?? {}\n      })\n      cascadeMatchData(matchLoader.matches)\n\n      matches = matchLoader.matches\n    }\n\n    this.state = {\n      location: __experimental__snapshot?.location ?? location.current,\n      matches: matches,\n    }\n\n    location.subscribe(() => this.notify())\n  }\n\n  update = ({ basepath, routes, ...opts }: RouterOptions<TGenerics>) => {\n    Object.assign(this, opts)\n\n    this.basepath = cleanPath(`/${basepath ?? ''}`)\n\n    this.routesById = {}\n\n    const recurseRoutes = (\n      routes: Route<TGenerics>[],\n      parent?: Route<TGenerics>,\n    ): Route<TGenerics>[] => {\n      return routes.map((route) => {\n        const path = route.path ?? '*'\n\n        const id = joinPaths([\n          parent?.id === 'root' ? '' : parent?.id,\n          `${path?.replace(/(.)\\/$/, '$1')}${route.id ? `-${route.id}` : ''}`,\n        ])\n\n        route = {\n          ...route,\n          pendingMs: route.pendingMs ?? opts?.defaultPendingMs,\n          pendingMinMs: route.pendingMinMs ?? opts?.defaultPendingMinMs,\n          id,\n        }\n\n        if (this.routesById[id]) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `Duplicate routes found with id: ${id}`,\n              this.routesById,\n              route,\n            )\n          }\n          throw new Error()\n        }\n\n        this.routesById[id] = route\n\n        route.children = route.children?.length\n          ? recurseRoutes(route.children, route)\n          : undefined\n\n        return route\n      })\n    }\n\n    this.routes = recurseRoutes(routes)\n\n    this.rootMatch = {\n      id: 'root',\n      params: {} as any,\n      search: {} as any,\n      pathname: this.basepath,\n      route: null!,\n      ownData: {},\n      data: {},\n      isLoading: false,\n      status: 'resolved',\n    }\n  }\n\n  setState = (\n    updater: (\n      old: RouterInstanceState<TGenerics>,\n    ) => RouterInstanceState<TGenerics>,\n  ) => {\n    const newState = updater({ state: this.state, pending: this.pending })\n    this.state = newState.state\n    this.pending = newState.pending\n    this.cleanMatchCache()\n    this.notify()\n  }\n\n  matchCache: Record<string, RouteMatch<TGenerics>> = {}\n\n  cleanMatchCache = () => {\n    const activeMatchIds = [\n      ...(this?.state.matches ?? []),\n      ...(this?.pending?.matches ?? []),\n    ].map((d) => d.id)\n\n    Object.values(this.matchCache).forEach((match) => {\n      if (!match.updatedAt) {\n        return\n      }\n\n      if (activeMatchIds.includes(match.id)) {\n        return\n      }\n\n      const age = Date.now() - (match.updatedAt ?? 0)\n\n      if (!match.maxAge || age > match.maxAge) {\n        if (match.route.unloader) {\n          match.route.unloader(match)\n        }\n\n        delete this.matchCache[match.id]\n      }\n    })\n  }\n\n  updateLocation = (next: Location<TGenerics>) => {\n    let unsubscribe: () => void\n\n    const promise = new Promise<void>((resolve) => {\n      const matchLoader = new MatchLoader(this, next)\n\n      this.setState((old) => {\n        return {\n          ...old,\n          pending: {\n            location: matchLoader.location,\n            matches: matchLoader.matches,\n          },\n        }\n      })\n\n      unsubscribe = matchLoader.subscribe(() => {\n        const currentMatches = this.state.matches\n\n        currentMatches\n          .filter((d) => {\n            return !matchLoader.matches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.onExit?.(d)\n          })\n\n        currentMatches\n          .filter((d) => {\n            return matchLoader.matches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.route.onTransition?.(d)\n          })\n\n        matchLoader.matches\n          .filter((d) => {\n            return !currentMatches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.onExit = d.route.onMatch?.(d)\n          })\n\n        this.setState((old) => {\n          return {\n            ...old,\n            state: {\n              location: matchLoader.location,\n              matches: matchLoader.matches,\n            },\n            pending: undefined,\n          }\n        })\n\n        resolve()\n      })\n\n      matchLoader.loadData()\n      matchLoader.startPending()\n    })\n\n    return {\n      promise,\n      unsubscribe: unsubscribe!,\n    }\n  }\n\n  __experimental__createSnapshot =\n    (): __Experimental__RouterSnapshot<TGenerics> => {\n      return {\n        location: this.state.location,\n        matches: this.state.matches.map(({ ownData, id }) => {\n          return {\n            id,\n            ownData,\n          }\n        }),\n      }\n    }\n}\n\nexport type UseLocationType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => ReactLocation<TGenerics>\n\nexport function useLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): ReactLocation<TGenerics> {\n  const context = React.useContext(LocationContext) as {\n    location: ReactLocation<TGenerics>\n  }\n  warning(!!context, 'useLocation must be used within a <ReactLocation />')\n\n  return context.location\n}\n\nexport class RouteMatch<TGenerics extends PartialGenerics = DefaultGenerics> {\n  id!: string\n  route!: Route<TGenerics>\n  pathname!: string\n  params!: UseGeneric<TGenerics, 'Params'>\n  search!: UseGeneric<TGenerics, 'Search'>\n  updatedAt?: number\n  element?: React.ReactNode\n  errorElement?: React.ReactNode\n  pendingElement?: React.ReactNode\n  error?: unknown\n  loaderPromise?: Promise<UseGeneric<TGenerics, 'LoaderData'>>\n  maxAge?: number\n  matchLoader?: MatchLoader<TGenerics>\n  pendingTimeout?: Timeout\n  pendingMinPromise?: Promise<void>\n  onExit?: void | ((match: RouteMatch<TGenerics>) => void)\n\n  constructor(unloadedMatch: UnloadedMatch<TGenerics>) {\n    Object.assign(this, unloadedMatch)\n  }\n\n  status: 'loading' | 'pending' | 'resolved' | 'rejected' = 'loading'\n  ownData: UseGeneric<TGenerics, 'LoaderData'> = {}\n  data: UseGeneric<TGenerics, 'LoaderData'> = {}\n  isLoading: boolean = false\n\n  private notify? = (isSoft?: boolean) => {\n    this.matchLoader?.preNotify(isSoft ? this : undefined)\n  }\n\n  assignMatchLoader? = (matchLoader: MatchLoader<TGenerics>) => {\n    this.matchLoader = matchLoader\n  }\n\n  startPending? = () => {\n    if (this.pendingTimeout) {\n      clearTimeout(this.pendingTimeout)\n    }\n\n    if (this.route.pendingMs !== undefined) {\n      this.pendingTimeout = setTimeout(() => {\n        if (this.status === 'loading') {\n          this.status = 'pending'\n        }\n        this.notify?.()\n        if (typeof this.route.pendingMinMs !== 'undefined') {\n          this.pendingMinPromise = new Promise((r) =>\n            setTimeout(r, this.route.pendingMinMs),\n          )\n        }\n      }, this.route.pendingMs)\n    }\n  }\n\n  load? = (opts: {\n    maxAge?: number\n    parentMatch?: RouteMatch<TGenerics>\n    router: RouterInstance<TGenerics>\n  }) => {\n    this.maxAge =\n      opts.maxAge ?? this.route.loaderMaxAge ?? opts.router.defaultLoaderMaxAge\n\n    if (this.loaderPromise) {\n      return\n    }\n\n    const importer = this.route.import\n\n    // First, run any importers\n    this.loaderPromise = (\n      !importer\n        ? Promise.resolve()\n        : (() => {\n            this.isLoading = true\n            return importer({ params: this.params, search: this.search }).then(\n              (imported) => {\n                this.route = {\n                  ...this.route,\n                  ...imported,\n                }\n              },\n            )\n          })()\n    )\n      // then run all element and data loaders in parallel\n      .then(() => {\n        const elementPromises: Promise<void>[] = []\n\n        // For each element type, potentially load it asynchronously\n        const elementTypes = [\n          'element',\n          'errorElement',\n          'pendingElement',\n        ] as const\n\n        elementTypes.forEach((type) => {\n          const routeElement = this.route[type]\n\n          if (this[type]) {\n            return\n          }\n\n          if (typeof routeElement === 'function') {\n            this.isLoading = true\n            elementPromises.push(\n              (routeElement as AsyncElement)(this).then((res) => {\n                this[type] = res\n              }),\n            )\n          } else {\n            this[type] = this.route[type]\n          }\n        })\n\n        const loader = this.route.loader\n\n        const dataPromise = !loader\n          ? Promise.resolve()\n          : new Promise(async (resolveLoader) => {\n              this.isLoading = true\n\n              const loaderReady = (status: 'resolved' | 'rejected') => {\n                this.updatedAt = Date.now()\n                resolveLoader(this.ownData)\n                this.status = status\n              }\n\n              const resolve = (data: any) => {\n                this.ownData = data\n                this.error = undefined\n                loaderReady('resolved')\n              }\n\n              const reject = (err: any) => {\n                console.error(err)\n                this.error = err\n                loaderReady('rejected')\n              }\n\n              try {\n                resolve(\n                  await loader(this, {\n                    parentMatch: opts.parentMatch,\n                    dispatch: async (event) => {\n                      if (event.type === 'resolve') {\n                        resolve(event.data)\n                      } else if (event.type === 'reject') {\n                        reject(event.error)\n                      } else if (event.type === 'loading') {\n                        this.isLoading = true\n                      } else if (event.type === 'maxAge') {\n                        this.maxAge = event.maxAge\n                      }\n\n                      this.updatedAt = Date.now()\n                      this.notify?.(true)\n                    },\n                  }),\n                )\n              } catch (err) {\n                reject(err)\n              }\n            })\n\n        return Promise.all([...elementPromises, dataPromise])\n          .then(() => {\n            this.status = 'resolved'\n            this.isLoading = false\n            this.startPending = undefined\n          })\n          .then(() => this.pendingMinPromise)\n          .then(() => {\n            if (this.pendingTimeout) {\n              clearTimeout(this.pendingTimeout)\n            }\n            this.notify?.(true)\n          })\n      })\n      .then(() => {\n        return this.ownData\n      })\n  }\n}\n\nclass MatchLoader<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  router: RouterInstance<TGenerics>\n  location: Location<TGenerics>\n  matches: RouteMatch<TGenerics>[]\n  prepPromise?: Promise<void>\n  matchPromise?: Promise<UnloadedMatch<TGenerics>[]>\n  firstRenderPromises?: Promise<any>[]\n  preNotifiedMatches: RouteMatch<TGenerics>[] = []\n\n  constructor(\n    router: RouterInstance<TGenerics>,\n    nextLocation: Location<TGenerics>,\n  ) {\n    super()\n    this.router = router\n    this.location = nextLocation\n    this.matches = []\n\n    const unloadedMatches = matchRoutes(this.router, this.location)\n\n    this.matches = unloadedMatches?.map(\n      (unloadedMatch): RouteMatch<TGenerics> => {\n        if (!this.router.matchCache[unloadedMatch.id]) {\n          this.router.matchCache[unloadedMatch.id] = new RouteMatch(\n            unloadedMatch,\n          )\n        }\n\n        return this.router.matchCache[unloadedMatch.id]!\n      },\n    )\n  }\n\n  status: 'pending' | 'resolved' = 'pending'\n\n  preNotify = (routeMatch?: RouteMatch<TGenerics>) => {\n    if (routeMatch) {\n      if (!this.preNotifiedMatches.includes(routeMatch)) {\n        this.preNotifiedMatches.push(routeMatch)\n      }\n    }\n\n    if (!routeMatch || this.preNotifiedMatches.length === this.matches.length) {\n      this.status = 'resolved'\n      cascadeMatchData(this.matches)\n      this.notify()\n    }\n  }\n\n  loadData = async ({ maxAge }: { maxAge?: number } = {}) => {\n    this.router.cleanMatchCache()\n\n    if (!this.matches?.length) {\n      this.preNotify()\n      return\n    }\n\n    this.firstRenderPromises = []\n\n    this.matches.forEach((match, index) => {\n      const parentMatch = this.matches?.[index - 1]\n      match.assignMatchLoader?.(this)\n      match.load?.({ maxAge, parentMatch, router: this.router })\n      this.firstRenderPromises?.push(match.loaderPromise!)\n    })\n\n    return await Promise.all(this.firstRenderPromises).then(() => {\n      this.preNotify()\n      return this.matches\n    })\n  }\n\n  load = async ({ maxAge }: { maxAge?: number } = {}) => {\n    return await this.loadData({ maxAge })\n  }\n\n  startPending = async () => {\n    this.matches.forEach((match) => match.startPending?.())\n  }\n}\n\nfunction cascadeMatchData<TGenerics>(matches?: RouteMatch<TGenerics>[]) {\n  matches?.forEach((match, index) => {\n    const parentMatch = matches?.[index - 1]\n\n    match.data = {\n      ...(parentMatch?.data ?? ({} as any)),\n      ...match.ownData,\n    }\n  })\n}\n\nexport type UseRouterType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouterInstance<TGenerics>\n\nexport function useRouter<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouterInstance<TGenerics> {\n  const value = React.useContext(routerContext)\n  if (!value) {\n    warning(true, 'You are trying to use useRouter() outside of ReactLocation!')\n    throw new Error()\n  }\n\n  return value.router as RouterInstance<TGenerics>\n}\n\nexport interface MatchRoutesOptions<TGenerics> {\n  filterRoutes?: FilterRoutesFn\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultElement?: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement?: SyncOrAsyncElement<TGenerics>\n}\n\nexport type MatchRoutesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  router: RouterInstance<TGenerics>[],\n  currentLocation: Location<TGenerics>,\n) => Promise<UnloadedMatch<TGenerics>[]>\n\nexport function matchRoutes<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  router: RouterInstance<TGenerics>,\n  currentLocation: Location<TGenerics>,\n): UnloadedMatch<TGenerics>[] {\n  if (!router.routes.length) {\n    return []\n  }\n\n  const matches: UnloadedMatch<TGenerics>[] = []\n\n  const recurse = async (\n    routes: Route<TGenerics>[],\n    parentMatch: UnloadedMatch<TGenerics>,\n  ): Promise<void> => {\n    let { pathname, params } = parentMatch\n    const filteredRoutes = router?.filterRoutes\n      ? router?.filterRoutes(routes)\n      : routes\n\n    const route = filteredRoutes.find((route) => {\n      const fullRoutePathName = joinPaths([pathname, route.path])\n\n      const fuzzy = !!(route.path !== '/' || route.children?.length)\n\n      const matchParams = matchRoute(currentLocation, {\n        to: fullRoutePathName,\n        search: route.search,\n        fuzzy,\n        caseSensitive: route.caseSensitive ?? router.caseSensitive,\n      })\n\n      if (matchParams) {\n        params = {\n          ...params,\n          ...matchParams,\n        }\n      }\n\n      return !!matchParams\n    })\n\n    if (!route) {\n      return\n    }\n\n    const interpolatedPath = interpolatePath(route.path, params)\n    pathname = joinPaths([pathname, interpolatedPath])\n\n    const interpolatedId = interpolatePath(route.id, params, true)\n\n    const match: UnloadedMatch<TGenerics> = {\n      id: interpolatedId,\n      route,\n      params,\n      pathname,\n      search: currentLocation.search,\n    }\n\n    matches.push(match)\n\n    if (route.children?.length) {\n      recurse(route.children, match)\n    }\n  }\n\n  recurse(router.routes, router.rootMatch!)\n\n  return matches\n}\n\nfunction interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.value === '*' && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport type UseLoadRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (routes?: Route<TGenerics>[]) => void\n\nexport function useLoadRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const router = useRouter<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  return useLatestCallback(\n    async (\n      navigate: NavigateOptions<TGenerics> = location.current,\n      opts?: { maxAge?: number },\n    ) => {\n      const next = buildNext({\n        ...navigate,\n        from: navigate.from ?? { pathname: match.pathname },\n      })\n\n      const matchLoader = new MatchLoader(router, next)\n\n      return await matchLoader.load(opts)\n    },\n  )\n}\n\nexport type UseMatchesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => RouteMatch<TGenerics>[]\n\nexport function useParentMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  const router = useRouter<TGenerics>()\n  const match = useMatch()\n\n  const matches = router.state.matches\n\n  return matches.slice(0, matches.findIndex((d) => d.id === match.id) - 1)\n}\n\nexport function useMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  return React.useContext(MatchesContext)\n}\n\nexport type UseMatchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouteMatch<TGenerics>\n\nexport function useMatch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics> {\n  return useMatches<TGenerics>()?.[0]!\n}\n\nexport type UseNavigateType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (options: NavigateOptions<TGenerics>) => void\n\nexport function useNavigate<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  function navigate({\n    search,\n    hash,\n    replace,\n    from,\n    to,\n    fromCurrent,\n  }: NavigateOptions<TGenerics> & {\n    replace?: boolean\n  }) {\n    fromCurrent = fromCurrent ?? typeof to === 'undefined'\n\n    const next = buildNext({\n      to,\n      search,\n      hash,\n      from: fromCurrent\n        ? location.current\n        : from ?? { pathname: match.pathname },\n    })\n\n    location.navigate(next, replace)\n  }\n\n  return useLatestCallback(navigate)\n}\n\nexport type NavigateType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  (options: NavigateOptions<TGenerics>) => null\n\nexport function Navigate<TGenerics extends PartialGenerics = DefaultGenerics>(\n  options: NavigateOptions<TGenerics>,\n) {\n  let navigate = useNavigate<TGenerics>()\n\n  useLayoutEffect(() => {\n    navigate(options)\n  }, [navigate])\n\n  return null\n}\n\nfunction useBuildNext<TGenerics>() {\n  const location = useLocation<TGenerics>()\n  const router = useRouter<TGenerics>()\n\n  const buildNext = (opts: BuildNextOptions<TGenerics>) => {\n    const next = location.buildNext(router.basepath, opts)\n\n    const matches = matchRoutes<TGenerics>(router, next)\n\n    const __searchFilters = matches\n      .map((match) => match.route.searchFilters ?? [])\n      .flat()\n      .filter(Boolean)\n\n    return location.buildNext(router.basepath, { ...opts, __searchFilters })\n  }\n\n  return useLatestCallback(buildNext)\n}\n\nexport type LinkType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: LinkProps<TGenerics>,\n) => JSX.Element\n\nexport const Link = function Link<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  to = '.',\n  search,\n  hash,\n  children,\n  target,\n  style = {},\n  replace,\n  onClick,\n  onMouseEnter,\n  className = '',\n  getActiveProps = () => ({ className: 'active' }),\n  getInactiveProps = () => ({}),\n  activeOptions,\n  preload,\n  disabled,\n  _ref,\n  ...rest\n}: LinkProps<TGenerics>) {\n  const loadRoute = useLoadRoute<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const location = useLocation<TGenerics>()\n  const router = useRouter<TGenerics>()\n  const navigate = useNavigate<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  preload = preload ?? router.defaultLinkPreloadMaxAge\n\n  // If this `to` is a valid external URL, log a warning\n  try {\n    const url = new URL(`${to}`)\n    warning(\n      false,\n      `<Link /> should not be used for external URLs like: ${url.href}`,\n    )\n  } catch (e) {}\n\n  const next = buildNext({\n    to,\n    search,\n    hash,\n    from: { pathname: match.pathname },\n  })\n\n  // The click handler\n  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    if (disabled) return\n    if (onClick) onClick(e)\n\n    if (\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n      // All is well? Navigate!\n      navigate({\n        to,\n        search,\n        hash,\n        replace,\n        from: { pathname: match.pathname },\n      })\n    }\n  }\n\n  // The click handler\n  const handleMouseEnter = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    if (onMouseEnter) onMouseEnter(e)\n\n    if (preload && preload > 0) {\n      loadRoute(\n        {\n          to,\n          search,\n          hash,\n        },\n        { maxAge: preload },\n      )\n    }\n  }\n\n  // Compare path/hash for matches\n  const pathIsEqual = location.current.pathname === next.pathname\n  const currentPathSplit = location.current.pathname.split('/')\n  const nextPathSplit = next.pathname.split('/')\n  const pathIsFuzzyEqual = nextPathSplit.every(\n    (d, i) => d === currentPathSplit[i],\n  )\n  const hashIsEqual = location.current.hash === next.hash\n\n  // Combine the matches based on user options\n  const pathTest = activeOptions?.exact ? pathIsEqual : pathIsFuzzyEqual\n  const hashTest = activeOptions?.includeHash ? hashIsEqual : true\n\n  // The final \"active\" test\n  const isActive = pathTest && hashTest\n\n  // Get the active props\n  const {\n    style: activeStyle = {},\n    className: activeClassName = '',\n    ...activeRest\n  } = isActive ? getActiveProps() : {}\n\n  // Get the inactive props\n  const {\n    style: inactiveStyle = {},\n    className: inactiveClassName = '',\n    ...inactiveRest\n  } = isActive ? {} : getInactiveProps()\n\n  return (\n    <a\n      {...{\n        ref: _ref,\n        href: disabled ? undefined : next.href,\n        onClick: handleClick,\n        onMouseEnter: handleMouseEnter,\n        target,\n        style: {\n          ...style,\n          ...activeStyle,\n          ...inactiveStyle,\n        },\n        className:\n          [className, activeClassName, inactiveClassName]\n            .filter(Boolean)\n            .join(' ') || undefined,\n        ...(disabled\n          ? {\n              role: 'link',\n              'aria-disabled': true,\n            }\n          : undefined),\n        ...rest,\n        ...activeRest,\n        ...inactiveRest,\n        children:\n          typeof children === 'function' ? children({ isActive }) : children,\n      }}\n    />\n  )\n}\n\nexport function Outlet<TGenerics extends PartialGenerics = DefaultGenerics>() {\n  const router = useRouter<TGenerics>()\n  const [_, ...matches] = useMatches<TGenerics>()\n\n  const match = matches[0]\n\n  if (!match) {\n    return null\n  }\n\n  const errorElement = match.errorElement ?? router.defaultErrorElement\n\n  const element = (() => {\n    if (match.status === 'rejected') {\n      if (errorElement) {\n        return errorElement\n      }\n\n      if (!router.useErrorBoundary) {\n        if (process.env.NODE_ENV !== 'production') {\n          const preStyle: React.HTMLAttributes<HTMLPreElement>['style'] = {\n            whiteSpace: 'normal',\n            display: 'inline-block',\n            background: 'rgba(0,0,0,.1)',\n            padding: '.1rem .2rem',\n            margin: '.1rem',\n            lineHeight: '1',\n            borderRadius: '.25rem',\n          }\n\n          return (\n            <div style={{ lineHeight: '1.7' }}>\n              <strong>\n                The following error occured in the loader for you route at:{' '}\n                <pre style={preStyle}>{match.pathname}</pre>\n              </strong>\n              .\n              <br />\n              <pre\n                style={{\n                  ...preStyle,\n                  display: 'block',\n                  padding: '.5rem',\n                  borderRadius: '.5rem',\n                }}\n              >\n                {(match.error as any).toString()}\n              </pre>\n              <br />\n              Your users won't see this message in production, but they will see{' '}\n              <strong>\"An unknown error occured!\"</strong>, which is at least\n              better than breaking your entire app. \uD83D\uDE0A For a better UX, please\n              specify an <pre style={preStyle}>errorElement</pre> for all of\n              your routes that contain asynchronous behavior, or at least\n              provide your own\n              <pre style={preStyle}>ErrorBoundary</pre> wrapper around your\n              renders to both the elements rendered by{' '}\n              <pre style={preStyle}>\n                {'useRoutes(routes, { useErrorBoundary: true })'}\n              </pre>{' '}\n              and <pre style={preStyle}>{'<Router useErrorBoundary />'}</pre>.{' '}\n              <br />\n              <br />\n            </div>\n          )\n        }\n        return 'An unknown error occured!'\n      }\n\n      throw match.error\n    }\n\n    const pendingElement = match.pendingElement ?? router.defaultPendingElement\n\n    if (match.status === 'loading') {\n      return null\n    }\n\n    if (match.status === 'pending') {\n      if (match.route.pendingMs || pendingElement) {\n        return pendingElement ?? null\n      }\n    }\n\n    const matchElement = match.element ?? router.defaultElement\n\n    return matchElement ?? <Outlet />\n  })()\n\n  return <MatchesProvider value={matches}>{element}</MatchesProvider>\n}\n\nexport function useResolvePath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const router = useRouter<TGenerics>()\n  const match = useMatch<TGenerics>()\n\n  return useLatestCallback((path: string) =>\n    resolvePath(router.basepath!, match.pathname!, cleanPath(path)),\n  )\n}\n\nexport type UseSearchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => Partial<Maybe<TGenerics['Search'], Search<any>>>\n\nexport function useSearch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  return location.current.search\n}\n\nexport type MatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) => UseGeneric<TGenerics, 'Params'> | undefined\n\nexport function matchRoute<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const pathParams = matchByPath(currentLocation, matchLocation)\n  const searchMatched = matchBySearch(currentLocation, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  if (matchLocation.search && !searchMatched) {\n    return\n  }\n\n  return (pathParams ?? {}) as UseGeneric<TGenerics, 'Params'>\n}\n\nexport type UseMatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => (\n  matchLocation: MatchLocation<TGenerics>,\n) => Maybe<TGenerics['Params'], Params<any>> | undefined\n\nexport type UseMatchRouteOptions<TGenerics> = MatchLocation<TGenerics> & {\n  pending?: boolean\n}\n\nexport function useMatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): (\n  matchLocation: UseMatchRouteOptions<TGenerics>,\n  opts?: { caseSensitive?: boolean },\n) => Maybe<TGenerics['Params'], Params<any>> | undefined {\n  const router = useRouter<TGenerics>()\n  const resolvePath = useResolvePath<TGenerics>()\n\n  return useLatestCallback(\n    ({\n      pending,\n      ...matchLocation\n    }: MatchLocation<TGenerics> & { pending?: boolean }) => {\n      matchLocation = {\n        ...matchLocation,\n        to: matchLocation.to ? resolvePath(`${matchLocation.to}`) : undefined,\n      }\n\n      if (pending) {\n        if (!router.pending?.location) {\n          return undefined\n        }\n        return matchRoute(router.pending.location, matchLocation)\n      }\n\n      return matchRoute(router.state.location, matchLocation)\n    },\n  )\n}\n\nexport function MatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  children,\n  ...rest\n}: UseMatchRouteOptions<TGenerics> & {\n  children:\n    | React.ReactNode\n    | ((isNextLocation?: Params<TGenerics>) => React.ReactNode)\n}) {\n  const matchRoute = useMatchRoute<TGenerics>()\n  const match = matchRoute(rest)\n\n  if (typeof children === 'function') {\n    return children(match as any)\n  }\n\n  return match ? children : null\n}\n\nexport function usePrompt(message: string, when: boolean | any): void {\n  const location = useLocation()\n\n  React.useEffect(() => {\n    if (!when) return\n\n    let unblock = location.history.block((transition) => {\n      if (window.confirm(message)) {\n        unblock()\n        transition.retry()\n      } else {\n        location.current.pathname = window.location.pathname\n      }\n    })\n\n    return unblock\n  }, [when, location, message])\n}\n\nexport function Prompt({ message, when, children }: PromptProps) {\n  usePrompt(message, when ?? true)\n  return (children ?? null) as React.ReactNode\n}\n\nfunction warning(cond: boolean, message: string) {\n  if (!cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater?: Updater<TResult>,\n  previous?: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nfunction joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return `${path}`.replace(/\\/{2,}/g, '/')\n}\n\nexport function matchByPath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const baseSegments = parsePathname(currentLocation.pathname)\n  const routeSegments = parsePathname(`${matchLocation.to ?? '*'}`)\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          params[routeSegment.value.substring(1)] = baseSegment.value\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as UseGeneric<TGenerics, 'Params'>) : undefined\n}\n\nfunction matchBySearch<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) {\n  return !!(\n    matchLocation.search && matchLocation.search(currentLocation.search)\n  )\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part.startsWith('*')) {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === ':') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nfunction isCtrlEvent(e: React.MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nfunction useLatestCallback<TCallback extends (...args: any[]) => any>(\n  cb: TCallback,\n) {\n  const stableFnRef =\n    React.useRef<(...args: Parameters<TCallback>) => ReturnType<TCallback>>()\n  const cbRef = React.useRef<TCallback>(cb)\n\n  cbRef.current = cb\n\n  if (!stableFnRef.current) {\n    stableFnRef.current = (...args) => cbRef.current(...args)\n  }\n\n  return stableFnRef.current\n}\n\nfunction useGetIsMounted() {\n  const ref = React.useRef(false)\n\n  React.useEffect(() => {\n    ref.current = true\n\n    return () => {\n      ref.current = false\n    }\n  })\n\n  return () => ref.current\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nfunction replaceEqualDeep(prev: any, next: any) {\n  if (prev === next) {\n    return prev\n  }\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const aSize = array ? prev.length : Object.keys(prev).length\n    const bItems = array ? next : Object.keys(next)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): Record<string, any> => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n"],
  "mappings": "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",
  "names": ["Action", "window", "index", "action", "location", "encode", "obj", "pfx", "k", "i", "tmp", "str", "Array", "isArray", "length", "encodeURIComponent", "toValue", "mix", "decodeURIComponent", "decode", "out", "arr", "split", "shift", "concat", "LocationContext", "createContext", "MatchesContext", "routerContext", "isDOM", "Boolean", "window", "document", "createElement", "useLayoutEffect", "useEffect", "createDefaultHistory", "createBrowserHistory", "createMemoryHistory", "Subscribable", "constructor", "listeners", "subscribe", "listener", "push", "filter", "x", "notify", "forEach", "ReactLocation", "options", "isTransitioning", "history", "stringifySearch", "defaultStringifySearch", "parseSearch", "defaultParseSearch", "current", "parseLocation", "location", "destroy", "listen", "event", "buildNext", "basepath", "dest", "from", "_extends", "pathname", "resolvePath", "to", "filteredSearch", "__searchFilters", "reduce", "prev", "next", "search", "updatedSearch", "functionalUpdate", "replaceEqualDeep", "searchStr", "hash", "href", "key", "navigate", "replace", "navigateTimeout", "clearTimeout", "nextAction", "isSameUrl", "previousLocation", "parsedSearch", "reverse", "MatchesProvider", "props", "Router", "children", "__experimental__snapshot", "rest", "routerRef", "useRef", "RouterInstance", "routes", "router", "nonce", "rerender", "useReducer", "update", "updateLocation", "unsubscribe", "rootMatch", "state", "matches", "InitialSideEffects", "useLocation", "useBuildNext", "useNavigate", "fromCurrent", "routesById", "opts", "Object", "assign", "cleanPath", "recurseRoutes", "parent", "map", "route", "path", "id", "joinPaths", "pendingMs", "defaultPendingMs", "pendingMinMs", "defaultPendingMinMs", "process", "console", "warn", "Error", "undefined", "params", "ownData", "data", "isLoading", "status", "setState", "updater", "newState", "pending", "cleanMatchCache", "matchCache", "activeMatchIds", "d", "values", "match", "updatedAt", "includes", "age", "Date", "now", "maxAge", "unloader", "promise", "Promise", "resolve", "matchLoader", "MatchLoader", "old", "currentMatches", "find", "dd", "onExit", "onTransition", "onMatch", "loadData", "startPending", "__experimental__createSnapshot", "index", "cascadeMatchData", "context", "useContext", "warning", "RouteMatch", "unloadedMatch", "isSoft", "preNotify", "assignMatchLoader", "pendingTimeout", "setTimeout", "pendingMinPromise", "r", "load", "loaderMaxAge", "defaultLoaderMaxAge", "loaderPromise", "importer", "import", "then", "imported", "elementPromises", "elementTypes", "type", "routeElement", "res", "loader", "dataPromise", "resolveLoader", "loaderReady", "error", "reject", "err", "parentMatch", "dispatch", "all", "nextLocation", "preNotifiedMatches", "routeMatch", "firstRenderPromises", "unloadedMatches", "matchRoutes", "useRouter", "value", "currentLocation", "recurse", "filteredRoutes", "filterRoutes", "fullRoutePathName", "fuzzy", "matchParams", "matchRoute", "caseSensitive", "interpolatedPath", "interpolatePath", "interpolatedId", "leaveWildcard", "interpolatedPathSegments", "parsePathname", "segment", "substring", "useLoadRoute", "useMatch", "useLatestCallback", "useParentMatches", "slice", "findIndex", "useMatches", "Navigate", "searchFilters", "flat", "Link", "target", "style", "onClick", "onMouseEnter", "className", "getActiveProps", "getInactiveProps", "activeOptions", "preload", "disabled", "_ref", "loadRoute", "defaultLinkPreloadMaxAge", "url", "URL", "e", "handleClick", "isCtrlEvent", "defaultPrevented", "button", "preventDefault", "handleMouseEnter", "pathIsEqual", "currentPathSplit", "nextPathSplit", "pathIsFuzzyEqual", "every", "hashIsEqual", "pathTest", "exact", "hashTest", "includeHash", "isActive", "activeStyle", "activeClassName", "activeRest", "inactiveStyle", "inactiveClassName", "inactiveRest", "ref", "join", "role", "Outlet", "_", "errorElement", "defaultErrorElement", "element", "useErrorBoundary", "preStyle", "whiteSpace", "display", "background", "padding", "margin", "lineHeight", "borderRadius", "toString", "pendingElement", "defaultPendingElement", "matchElement", "defaultElement", "useResolvePath", "useSearch", "matchLocation", "pathParams", "matchByPath", "searchMatched", "matchBySearch", "useMatchRoute", "MatchRoute", "usePrompt", "message", "when", "React", "unblock", "block", "transition", "confirm", "retry", "Prompt", "cond", "isFunction", "previous", "paths", "baseSegments", "routeSegments", "isMatch", "Math", "max", "baseSegment", "routeSegment", "isLastRouteSegment", "isLastBaseSegment", "toLowerCase", "segments", "part", "startsWith", "charAt", "base", "RegExp", "toSegments", "toSegment", "pop", "joined", "metaKey", "altKey", "ctrlKey", "shiftKey", "cb", "stableFnRef", "cbRef", "array", "isPlainObject", "aSize", "keys", "bItems", "bSize", "copy", "equalItems", "o", "hasObjectPrototype", "ctor", "prot", "prototype", "hasOwnProperty", "call", "parseSearchWith", "JSON", "parse", "stringifySearchWith", "stringify", "parser", "query", "val"]
}
