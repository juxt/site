{"version":3,"file":"index.production.min.js","sources":["../../src/jsurl.ts","../../src/index.tsx"],"sourcesContent":["// We're inlining our own version of qss here for compression's sake, but we've included it as a hard dependency for the MIT license it requires.\n// Types are naive, but at least it compiles!\n\n// Unreserved characters for URL encoding are: - . _ ~\n// Earlier versions of this library used a different encoding for strings, but in our version we use a period for the string delimiter.\nconst previousStringPrefixes = [\"'\"] as const\nconst stringPrefix = '-'\n\nexport function stringify(v: any): string {\n  function encode(s: any) {\n    return !/[^\\w-.]/.test(s)\n      ? s\n      : s.replace(/[^\\w-.]/g, function (ch: any) {\n          if (ch === '$') return '!'\n          ch = ch.charCodeAt(0)\n          // thanks to Douglas Crockford for the negative slice trick\n          return ch < 0x100\n            ? '*' + ('00' + ch.toString(16)).slice(-2)\n            : '**' + ('0000' + ch.toString(16)).slice(-4)\n        })\n  }\n\n  var tmpAry\n\n  switch (typeof v) {\n    case 'number':\n      return isFinite(v) ? '~' + v : '~null'\n    case 'boolean':\n      return '~' + v\n    case 'string':\n      return '~' + stringPrefix + encode(v)\n    case 'object':\n      if (!v) return '~null'\n\n      tmpAry = []\n\n      if (Array.isArray(v)) {\n        for (var i = 0; i < v.length; i++) {\n          tmpAry[i] = stringify(v[i]!) || '~null'\n        }\n\n        return '~(' + (tmpAry.join('') || '~') + ')'\n      } else {\n        for (var key in v) {\n          if (v.hasOwnProperty(key)) {\n            var val = stringify(v[key]!)\n\n            // skip undefined and functions\n            if (val) {\n              tmpAry.push(encode(key) + val)\n            }\n          }\n        }\n\n        return '~(' + tmpAry.join('~') + ')'\n      }\n    default:\n      // function, undefined\n      return ''\n  }\n}\n\nvar reserved: Record<string, boolean | null> = {\n  true: true,\n  false: false,\n  null: null,\n} as const\n\nexport function parse(s: string): unknown {\n  if (!s) return s\n  s = s.replace(/%(25)*27/g, \"'\")\n  var i = 0,\n    len = s.length\n\n  function eat(expected: any) {\n    if (s.charAt(i) !== expected) {\n      // throw new Error(\n      //   'bad JSURL syntax: expected ' +\n      //     expected +\n      //     ', got ' +\n      //     (s && s.charAt(i)),\n      // )\n      throw new Error()\n    }\n    i++\n  }\n\n  function decode() {\n    var beg = i,\n      ch,\n      r = ''\n    while (i < len && (ch = s.charAt(i)) !== '~' && ch !== ')') {\n      switch (ch) {\n        case '*':\n          if (beg < i) r += s.substring(beg, i)\n          if (s.charAt(i + 1) === '*')\n            (r += String.fromCharCode(parseInt(s.substring(i + 2, i + 6), 16))),\n              (beg = i += 6)\n          else\n            (r += String.fromCharCode(parseInt(s.substring(i + 1, i + 3), 16))),\n              (beg = i += 3)\n          break\n        case '!':\n          if (beg < i) r += s.substring(beg, i)\n          ;(r += '$'), (beg = ++i)\n          break\n        default:\n          i++\n      }\n    }\n    return r + s.substring(beg, i)\n  }\n\n  return (function parseOne(): any {\n    var result: any, ch, beg\n    eat('~')\n    const current = (ch = s.charAt(i))\n    if (current === '(') {\n      i++\n      if (s.charAt(i) === '~') {\n        result = []\n        if (s.charAt(i + 1) === ')') i++\n        else {\n          do {\n            result.push(parseOne())\n          } while (s.charAt(i) === '~')\n        }\n      } else {\n        result = {}\n        if (s.charAt(i) !== ')') {\n          do {\n            var key = decode()\n            result[key] = parseOne()\n          } while (s.charAt(i) === '~' && ++i)\n        }\n      }\n      eat(')')\n    } else if ([stringPrefix, ...previousStringPrefixes].includes(current)) {\n      i++\n      result = decode()\n    } else {\n      beg = i++\n      while (i < len && /[^)~]/.test(s.charAt(i))) i++\n      var sub: string = s.substring(beg, i)\n      if (/[\\d\\-]/.test(ch)) {\n        result = parseFloat(sub)\n      } else {\n        result = reserved[sub]\n        if (typeof result === 'undefined') {\n          // throw new Error('bad value keyword: ' + sub)\n          throw new Error()\n        }\n      }\n    }\n    return result\n  })()\n}\n\nexport function tryParse<T>(s: string, def: any): unknown | T {\n  try {\n    return parse(s)\n  } catch (ex) {\n    return def\n  }\n}\n","import { parseSearchWith, stringifySearchWith } from '@tanstack/react-location'\nimport { stringify, parse } from './jsurl'\n\nexport function stringifySearch(search: Record<string, unknown>) {\n  return stringifySearchWith(stringify)(search)\n}\n\nexport function parseSearch(searchStr: string) {\n  return parseSearchWith(parse)(searchStr)\n}\n"],"names":["previousStringPrefixes","stringPrefix","stringify","v","encode","s","test","replace","ch","charCodeAt","toString","slice","tmpAry","isFinite","Array","isArray","i","length","join","key","hasOwnProperty","val","push","reserved","parse","len","eat","expected","charAt","Error","decode","beg","r","substring","String","fromCharCode","parseInt","parseOne","result","current","includes","sub","parseFloat","searchStr","parseSearchWith","search","stringifySearchWith"],"mappings":";;;;;;;;;;2UAKA,IAAMA,EAAyB,CAAC,KAC1BC,EAAe,IAEd,SAASC,EAAUC,YACfC,EAAOC,SACN,UAAUC,KAAKD,GAEnBA,EAAEE,QAAQ,YAAY,SAAUC,SACnB,MAAPA,EAAmB,KACvBA,EAAKA,EAAGC,WAAW,IAEP,IACR,KAAO,KAAOD,EAAGE,SAAS,KAAKC,OAAO,GACtC,MAAQ,OAASH,EAAGE,SAAS,KAAKC,OAAO,MAP/CN,MAWFO,gBAEWT,OACR,gBACIU,SAASV,GAAK,IAAMA,EAAI,YAC5B,gBACI,IAAMA,MACV,eACI,IAAMF,EAAeG,EAAOD,OAChC,aACEA,EAAG,MAAO,WAEfS,EAAS,GAELE,MAAMC,QAAQZ,GAAI,KACf,IAAIa,EAAI,EAAGA,EAAIb,EAAEc,OAAQD,IAC5BJ,EAAOI,GAAKd,EAAUC,EAAEa,KAAQ,cAG3B,MAAQJ,EAAOM,KAAK,KAAO,KAAO,QAEpC,IAAIC,KAAOhB,KACVA,EAAEiB,eAAeD,GAAM,KACrBE,EAAMnB,EAAUC,EAAEgB,IAGlBE,GACFT,EAAOU,KAAKlB,EAAOe,GAAOE,SAKzB,KAAOT,EAAOM,KAAK,KAAO,kBAI5B,IAIb,IAAIK,EAA2C,OACvC,SACC,OACD,MAGD,SAASC,EAAMnB,OACfA,EAAG,OAAOA,EACfA,EAAIA,EAAEE,QAAQ,YAAa,SACvBS,EAAI,EACNS,EAAMpB,EAAEY,gBAEDS,EAAIC,MACPtB,EAAEuB,OAAOZ,KAAOW,QAOZ,IAAIE,MAEZb,aAGOc,YAELtB,EADEuB,EAAMf,EAERgB,EAAI,GACChB,EAAIS,GAA8B,OAAtBjB,EAAKH,EAAEuB,OAAOZ,KAAsB,MAAPR,UACtCA,OACD,IACCuB,EAAMf,IAAGgB,GAAK3B,EAAE4B,UAAUF,EAAKf,IACX,MAApBX,EAAEuB,OAAOZ,EAAI,IACdgB,GAAKE,OAAOC,aAAaC,SAAS/B,EAAE4B,UAAUjB,EAAI,EAAGA,EAAI,GAAI,KAC3De,EAAMf,GAAK,IAEbgB,GAAKE,OAAOC,aAAaC,SAAS/B,EAAE4B,UAAUjB,EAAI,EAAGA,EAAI,GAAI,KAC3De,EAAMf,GAAK,aAEb,IACCe,EAAMf,IAAGgB,GAAK3B,EAAE4B,UAAUF,EAAKf,IACjCgB,GAAK,IAAOD,IAAQf,gBAGtBA,WAGCgB,EAAI3B,EAAE4B,UAAUF,EAAKf,UAGtB,SAASqB,QACXC,EAAa9B,EAAIuB,EACrBL,EAAI,SACEa,EAAW/B,EAAKH,EAAEuB,OAAOZ,MACf,MAAZuB,EAAiB,IACnBvB,IACoB,MAAhBX,EAAEuB,OAAOZ,MACXsB,EAAS,GACe,MAApBjC,EAAEuB,OAAOZ,EAAI,GAAYA,YAGzBsB,EAAOhB,KAAKe,WACW,MAAhBhC,EAAEuB,OAAOZ,YAGpBsB,EAAS,GACW,MAAhBjC,EAAEuB,OAAOZ,KACR,CAEDsB,EADUR,KACIO,UACS,MAAhBhC,EAAEuB,OAAOZ,MAAgBA,GAGtCU,EAAI,UACC,GAAI,CAACzB,UAAiBD,GAAwBwC,SAASD,GAC5DvB,IACAsB,EAASR,QACJ,KACLC,EAAMf,IACCA,EAAIS,GAAO,QAAQnB,KAAKD,EAAEuB,OAAOZ,KAAKA,QACzCyB,EAAcpC,EAAE4B,UAAUF,EAAKf,MAC/B,SAASV,KAAKE,GAChB8B,EAASI,WAAWD,gBAGE,KADtBH,EAASf,EAASkB,UAGV,IAAIZ,aAITS,EAzCD,iBC1GH,SAAqBK,UACnBC,kBAAgBpB,EAAhBoB,CAAuBD,sBALzB,SAAyBE,UACvBC,sBAAoB5C,EAApB4C,CAA+BD"}